<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano XL - HD Quality</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            background: #000000;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            min-height: 100vh;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: auto;
            /* Prevent text selection and drag behavior globally */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            transition: background-image 0.5s ease-in-out;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            top: -50px; /* shift entire UI up by 50px */
            min-width: 1000px;
            width: 100%;
        }



        /* Piano XL Section */
        .piano-xl-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            position: relative;
            min-width: 1000px;
            margin: 31px 100px 0 100px;
        }

        /* Controls Row */
        .controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 750px;
            flex-shrink: 0;
            margin-top: 16px;
        }

        .control-btn {
            background: linear-gradient(145deg, #4a4a4a 0%, #2a2a2a 50%, #1a1a1a 100%);
            border: 1px solid #555;
            border-radius: 12px;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.8),
                0 4px 8px rgba(0, 0, 0, 0.6),
                inset 0 1px 2px rgba(255, 255, 255, 0.2),
                inset 0 -1px 2px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            position: relative;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .control-btn:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 2px 4px rgba(0, 0, 0, 0.6),
                inset 0 -1px 1px rgba(255, 255, 255, 0.1);
        }

        .control-btn.selected {
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px 2px rgba(78, 34, 16, 0.9), 0 0 22px 6px rgba(78, 34, 16, 0.5);
        }

        /* Easy mode border - change white border to gold/brown for IONIAN, AEOLIAN, HARMONIC_MAJOR, HARMONIC_MINOR */
        .mode-btn[data-current-mode="IONIAN"].selected,
        .mode-btn[data-current-mode="AEOLIAN"].selected,
        .mode-btn[data-current-mode="HARMONIC_MAJOR"].selected,
        .mode-btn[data-current-mode="HARMONIC_MINOR"].selected {
            border: 4px solid #4e2210 !important;
            box-shadow: none !important;
        }

        /* Specific widths and layouts for each control */
        .bass-btn { width: 64px; height: 64px; font-size: 24px; }
        .filter-knob { width: 64px; height: 64px; }
        .transpose-knob { width: 64px; height: 64px; }
        .sounds-btn { width: 80px; height: 64px; font-size: 14px; }

        .knob {
            background: radial-gradient(ellipse at 30% 30%, #5a5a5a 0%, #3a3a3a 30%, #2a2a2a 60%, #1a1a1a 80%, #000 100%);
            border: 1px solid #666;
            border-radius: 50%;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.8),
                0 4px 8px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.15),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
            position: relative;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .knob.selected {
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px 2px rgba(78, 34, 16, 0.9), 0 0 22px 6px rgba(78, 34, 16, 0.5);
        }

        .knob:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 3px 6px rgba(0, 0, 0, 0.7),
                inset 0 -1px 2px rgba(255, 255, 255, 0.1);
        }

        /* Knob indicators removed - using numbers as indicators instead */

        .knob-name {
            color: #aaa;
            font-size: 10px;
            font-weight: 500;
            position: absolute;
            top: calc(25% - 4px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
            width: 100%;
        }

        .knob-value {
            color: white;
            font-size: 14px;
            font-weight: 100;
            position: absolute;
            top: calc(65% - 7px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .key-btn { width: 56px; height: 64px; }
        .mode-btn { 
            width: 101px; 
            height: 64px; 
            position: relative;
        }

        .mode-header {
            font-size: 10px;
            color: #aaa;
            text-align: center;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: absolute;
            top: -36px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            white-space: normal;
        }

        /* All mode headers now positioned at same height */
        .mode-header[data-system="harmonicMinor"],
        .mode-header[data-system="harmonicMajor"] {
            top: -36px;
        }
        .oct-btn { width: 56px; height: 64px; }
        .inv-btn { width: 56px; height: 64px; }
        .chord-btn { width: 96px; height: 64px; }

        .btn-label {
            font-size: 10px;
            color: #aaa;
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 100%;
        }

        .btn-value {
            font-size: 18px;
            font-weight: 400;
            text-align: center;
            width: 100%;
        }

        /* Mode button value centering with multi-line support */
        .mode-btn .btn-value {
            text-align: center;
            width: 100%;
            left: 0;
            transform: none;
            white-space: normal;
            line-height: 1.4;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1px 4px;
            min-height: 100%;
        }

        /* Special styling for AEOLIAN mode to show NATURAL MINOR header */
        .mode-btn[data-current-mode="AEOLIAN"] .btn-value::before {
            content: "NATURAL MINOR";
            font-size: 14px;
            color: #fff;
            line-height: 1.2;
            margin-bottom: 3px;
            font-weight: 500;
            transform: translateY(3px);
        }
        
        /* Make AEOLIAN text smaller and lighter */
        .mode-btn[data-current-mode="AEOLIAN"] .btn-value {
            font-size: 10px !important;
            font-weight: 300;
            color: #888;
        }
        
        /* Special styling for IONIAN mode to show NATURAL MAJOR header */
        .mode-btn[data-current-mode="IONIAN"] .btn-value::before {
            content: "NATURAL MAJOR";
            font-size: 14px;
            color: #fff;
            line-height: 1.2;
            margin-bottom: 3px;
            font-weight: 500;
            transform: translateY(3px);
        }
        
        /* Make IONIAN text smaller and lighter */
        .mode-btn[data-current-mode="IONIAN"] .btn-value {
            font-size: 10px !important;
            font-weight: 300;
            color: #888;
        }
        
        /* Scale degree display styling - uses existing app colors */
        .scale-degree {
            font-size: 18px !important;
            font-weight: 700 !important;
            /* Uses existing white text color from the app */
        }

        /* Base font size for mode button values */
        .mode-btn .btn-value {
            font-size: 16px; /* Smaller default size */
        }

        /* Piano keys */
        .piano-section {
            margin-top: 40px;
            position: relative;
        }

        .black-keys {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .white-keys {
            display: flex;
            justify-content: center;
            gap: 16px;
        }

        .piano-key {
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            /* Children (.key-slot) will evenly fill using flex */
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            padding: 2px;
        }

        .white-key {
            width: 64px;
            height: 128px;
            background: linear-gradient(145deg, #606060 0%, #505050 30%, #404040 70%, #2a2a2a 100%);
            border: 1px solid #777;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.8),
                0 4px 8px rgba(0, 0, 0, 0.6),
                0 0 12px rgba(255, 140, 0, 0.6),
                0 0 24px rgba(255, 140, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.15),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4);
        }

        .black-key {
            width: 64px;
            height: 128px;
            background: linear-gradient(145deg, #2a2a2a 0%, #1a1a1a 30%, #0a0a0a 70%, #000000 100%);
            border: 1px solid #444;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.9),
                0 4px 8px rgba(0, 0, 0, 0.7),
                0 0 12px rgba(255, 140, 0, 0.6),
                0 0 24px rgba(255, 140, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.08),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }

        .piano-key.disabled {
            /* Visuals remain unchanged when disabled; behavior handled in JS */
        }

        .piano-key.out-of-scale {
            background: linear-gradient(145deg, #404040 0%, #303030 50%, #202020 100%);
            border: 1px solid rgba(102, 102, 102, 0.5);
            opacity: 0.5;
        }

        .piano-key:active {
            transform: translateY(2px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 3px 6px rgba(0, 0, 0, 0.6);
        }

        /* When any slot in a key is active, make the whole key transparent to show the skin */
        .piano-key.pressed {
            background: transparent !important;
        }

        .spacer {
            width: 64px;
        }

        .key-slot {
            flex: 1 1 0%;
            min-height: 0;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 4px;
            box-sizing: border-box; /* include padding/border in height */
            transition: all 0.2s ease;
            cursor: pointer;
            border-radius: 0; /* will be set on first/last child below */
            /* Prevent text selection and drag behavior */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            /* Prevent drag behavior */
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
        }

        .key-slot:not(:last-child) {
            border-bottom: 1px solid rgba(128, 128, 128, 0.35);
        }

        /* Rounded corners for stacks */
        .piano-key .key-slot:first-child { border-radius: 12px 12px 0 0; }
        .piano-key .key-slot:last-child { border-radius: 0 0 12px 12px; }
        .mode-xl .key-slot { border-radius: 12px; }

        .key-slot.active {
            background: transparent;
            box-shadow: none;
        }

        /* Only XL uses whole-key pressed visuals */
        .mode-xl .piano-key.pressed .key-slot {
            background: transparent !important;
        }

        .key-slot.disabled {
            /* Visuals remain unchanged when disabled; only text is hidden via logic */
        }

        .slot-text {
            color: white;
            font-weight: 500;
            text-align: center;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            font-size: 14px;
        }

        .slot-text.hidden {
            color: transparent !important;
        }

        /* (removed) per-key copy badge */

        /* In stacked modes, give slots their own fill so active can go transparent to reveal skin */
        .mode-xxl .key-slot,
        .mode-xxxl .key-slot,
        .mode-x .key-slot {
            background: linear-gradient(145deg, #606060 0%, #505050 30%, #404040 70%, #2a2a2a 100%);
            border-radius: 4px !important;
        }

        /* In stacked modes, individual sharp slots are dark, but become fully transparent when active */
        .mode-xxl #key-C\# .key-slot,
        .mode-xxl #key-D\# .key-slot,
        .mode-xxl #key-F\# .key-slot,
        .mode-xxl #key-G\# .key-slot,
        .mode-xxl #key-A\# .key-slot,
        .mode-xxxl #key-C\# .key-slot,
        .mode-xxxl #key-D\# .key-slot,
        .mode-xxxl #key-F\# .key-slot,
        .mode-xxxl #key-G\# .key-slot,
        .mode-xxxl #key-A\# .key-slot,
        .mode-x #key-C\# .key-slot,
        .mode-x #key-D\# .key-slot,
        .mode-x #key-F\# .key-slot,
        .mode-x #key-G\# .key-slot,
        .mode-x #key-A\# .key-slot {
            background: linear-gradient(145deg, #2a2a2a 0%, #1a1a1a 30%, #0a0a0a 70%, #000000 100%);
            border: 1px solid #444;
        }

        /* Ensure active slots in stacked modes become transparent on press */
        .mode-xxl .key-slot.active,
        .mode-xxxl .key-slot.active,
        .mode-x .key-slot.active {
            background: transparent !important;
            box-shadow: none;
        }

        /* Ensure sharp key slots in stacked modes also become transparent on press */
        .mode-xxl #key-C\# .key-slot.active,
        .mode-xxl #key-D\# .key-slot.active,
        .mode-xxl #key-F\# .key-slot.active,
        .mode-xxl #key-G\# .key-slot.active,
        .mode-xxl #key-A\# .key-slot.active,
        .mode-xxxl #key-C\# .key-slot.active,
        .mode-xxxl #key-D\# .key-slot.active,
        .mode-xxxl #key-F\# .key-slot.active,
        .mode-xxxl #key-G\# .key-slot.active,
        .mode-xxxl #key-A\# .key-slot.active,
        .mode-x #key-C\# .key-slot.active,
        .mode-x #key-D\# .key-slot.active,
        .mode-x #key-F\# .key-slot.active,
        .mode-x #key-G\# .key-slot.active,
        .mode-x #key-A\# .key-slot.active {
            background: transparent !important;
        }

        /* In stacked modes, keep black keys visually black, but allow press to reveal skin */
        .mode-xxl .black-key,
        .mode-xxxl .black-key,
        .mode-x .black-key {
            /* Parent key stays transparent so active slot can reveal skin */
            background: transparent !important;
            border: 1px solid #444;
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.9),
                0 4px 8px rgba(0, 0, 0, 0.7),
                0 0 12px rgba(255, 140, 0, 0.6),
                0 0 24px rgba(255, 140, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.08),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6) !important;
        }

        /* Pressed state must be transparent even in stacked modes for black keys */
        .mode-xxl .black-key.pressed,
        .mode-xxxl .black-key.pressed,
        .mode-x .black-key.pressed {
            background: transparent !important;
        }

        /* White keys in stacked modes remain transparent to show skin beneath slots */
        .mode-xxl .white-key,
        .mode-xxxl .white-key,
        .mode-x .white-key {
            background: transparent !important;
        }

        /* Match white key overlays to black key overlays for consistent transparency */
        .mode-xxl .white-key,
        .mode-xxxl .white-key,
        .mode-x .white-key {
            border: 1px solid #444 !important;
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.9),
                0 4px 8px rgba(0, 0, 0, 0.7),
                0 0 12px rgba(255, 140, 0, 0.6),
                0 0 24px rgba(255, 140, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.08),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6) !important;
        }

        /* Mode-specific heights */
        .mode-xl .piano-key { height: 128px; }
        .mode-xxl .piano-key { height: 128px; }
        .mode-xxxl .piano-key { height: 128px; }
        .mode-x .piano-key { height: 192px; }

        .mode-xl .key-slot {
            align-items: flex-end;
            padding-bottom: 8px;
        }

        /* Side PIANO Label (original position) */
        .piano-text-container {
            position: absolute;
            left: 39px;
            top: calc(50% + 140px);
            transform: translateY(-50%) rotate(-90deg);
            pointer-events: auto;
            z-index: 1001;
        }

        /* Top title */
        .top-title-container {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translate(-50%, -50px); /* move header up by 50px */
            pointer-events: none;
            z-index: 10;
        }

        .xl-button-container {
            position: absolute;
            left: 50px;
            top: calc(50% - 6px);
            transform: translateY(-50%) rotate(-90deg);
            pointer-events: none;
        }

        /* Keyboard help panel (appears on P I A N O hover) */
        .kbd-help-panel {
            position: fixed;
            display: none;
            background: rgba(0,0,0,0.85);
            border: 1px solid #444;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            padding: 12px 14px;
            z-index: 2147483647; /* ensure above absolutely everything */
            pointer-events: auto; /* allow interaction when open */
            color: #fff;
            font-size: 14px;
            line-height: 1.4;
            max-width: 360px;
        }
        .kbd-help-panel.show { display: block; }
        .kbd-help-panel img { display: none; }
        .kbd-help-panel pre {
            margin: 0;
            white-space: pre; /* preserve exact newlines and spacing */
            text-align: center;
            font-size: 14px;
            line-height: 1.6;
        }
        .kbd-help-title {
            text-align: center;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 1px;
            margin: 2px 0 8px;
        }

        /* Static shortcut-keys visual button (no action) */
        .shortcut-keys-btn {
            width: 112px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid #444;
            background: #111;
            position: relative;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.06), 0 4px 8px rgba(0,0,0,0.5);
            pointer-events: none; /* purely visual */
            opacity: 0.9;
        }
        .shortcut-keys-btn::after {
            content: '';
            position: absolute;
            inset: 4px 6px;
            background-image: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='200' height='60' viewBox='0 0 200 60'>\
  <rect x='0' y='0' width='200' height='60' rx='8' ry='8' fill='none' stroke='#2b2b2b' stroke-width='6'/>\
  <g fill='#4b1d58' stroke='#ff8c00' stroke-width='2'>\
    <rect x='10' y='8' width='20' height='16'/>\
    <rect x='62' y='20' width='20' height='16'/>\
    <rect x='86' y='20' width='20' height='16'/>\
    <rect x='114' y='20' width='20' height='16'/>\
    <rect x='142' y='20' width='20' height='16'/>\
    <rect x='22' y='36' width='70' height='16'/>\
    <rect x='54' y='8' width='30' height='16'/>\
    <rect x='132' y='8' width='30' height='16'/>\
  </g>\
</svg>");
            background-size: cover;
            background-repeat: no-repeat;
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.6));
        }

        .piano-text {
            color: white;
            font-size: 23px;
            font-weight: 100;
            letter-spacing: 4px;
            cursor: pointer;
        }
        /* Enlarge only the top title */
        .top-title-container .piano-text { font-size: 46px; }

        .xl-button {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 2px solid #333;
            border-radius: 16px;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
            width: 94px;
            height: 69px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 23px;
            font-weight: 100;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            pointer-events: auto;
            position: relative;
        }

        .xl-button.selected {
            border-color: #ffffff;
            box-shadow: 0 0 10px 2px rgba(78, 34, 16, 0.9), 0 0 22px 6px rgba(78, 34, 16, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .vertical-fader.selected {
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px 2px rgba(78, 34, 16, 0.9), 0 0 22px 6px rgba(78, 34, 16, 0.5);
        }

        .xl-button:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 3px 6px rgba(0, 0, 0, 0.6);
        }

        /* Plus/Minus side buttons */
        .side-buttons {
            position: absolute;
            right: 100px;
            top: calc(50% + 67px);
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* Vertical Fader */
        .fader-container {
            position: absolute;
            right: 203px;
            top: calc(50% - 5px);
            transform: translateY(-50%);
            z-index: 50;
        }

        .vertical-fader {
            width: 6px;
            height: 114px;
            background: #2b2b2b; /* grey track */
            border: 2px solid #000; /* black border */
            border-radius: 15px;
            box-shadow: none;
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .fader-thumb {
            width: 33px;
            height: 10px;
            background: #2b2b2b; /* match track grey */
            border: 1px solid #000; /* black border */
            border-radius: 4px;
            box-shadow: none;
            position: absolute;
            left: -13.5px;
            top: 85px;
            cursor: grab;
            transition: all 0.1s ease;
        }

        .side-btn {
            width: 48px;
            height: 128px;
            background: linear-gradient(145deg, #4a4a4a 0%, #2a2a2a 50%, #1a1a1a 100%);
            border: 1px solid #555;
            border-radius: 8px;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.8),
                0 4px 8px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.15),
                inset 0 -2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .side-btn:active {
            transform: translateY(2px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 3px 6px rgba(0, 0, 0, 0.6);
        }

        /* Bottom buttons */
        .bottom-buttons {
            position: absolute;
            bottom: -96px; /* Moved up 11px from -107px to -96px for better centering between PIANO and Sequencer */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .bottom-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 2px solid #333;
            border-radius: 12px;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bottom-btn:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 3px 6px rgba(0, 0, 0, 0.6);
        }

        .camera-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
        }

        .disable-btn {
            width: 48px;
            height: 48px;
        }

        .save-btn {
            width: 48px;
            height: 48px;
        }

        .progression-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            color: white;
        }

        /* MIDI Indicator */
        .midi-indicator {
            position: absolute;
            top: 24px;
            right: 24px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 14px;
        }

        .midi-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .midi-dot.active {
            background: #4ade80;
        }



        /* Slot level indicator */
        .slot-indicator {
            position: absolute;
            top: 60px;
            right: 24px;
            color: #fbbf24;
            font-size: 12px;
            display: none;
        }

        .slot-indicator.show {
            display: block;
        }

        /* Background image */
        .background-image {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -2;
        }

        .background-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: -1;
        }

        /* Preset/Finder popup anchored near camera button */
        .bg-menu {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            border: 1px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.6);
            padding: 8px;
            display: none;
            z-index: 9999;
            min-width: 160px;
        }
        .bg-menu.show { display: block; }
        .bg-menu button {
            width: 100%;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            color: #fff;
            border-radius: 8px;
            padding: 8px 10px;
            margin: 4px 0;
            cursor: pointer;
            text-align: left;
        }
        .bg-presets {
            margin-top: 6px;
            display: none;
            max-height: 220px;
            overflow: auto;
        }
        .bg-presets.show { display: block; }
        .bg-preset-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            border-radius: 8px;
            cursor: pointer;
        }
        .bg-preset-item:hover {
            background: rgba(255,255,255,0.06);
        }
        .bg-thumb {
            width: 48px;
            height: 28px;
            object-fit: cover;
            border-radius: 6px;
            border: 1px solid #333;
        }

        /* Chord input field */
        .chord-input-container {
            position: relative;
        }

        .ask-ai-btn {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 10px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 6px;
            color: #fff;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
        }

        .ask-ai-btn:hover {
            background: #2a2a2a;
            border-color: #444;
        }

        .ask-ai-btn.active {
            background: #1a1a1a;
            border-color: #666;
            color: #fff;
        }

        .chord-input {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(0, 0, 0, 0.4);
            width: 240px;
            height: 40px;
            padding: 0 12px;
            color: #aaa;
            font-size: 12px;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
            text-align: center;
            transition: all 0.2s ease;
            outline: none;
        }

        .chord-input:focus {
            border-color: white;
            color: white;
        }

        .chord-input::placeholder {
            color: #666;
            font-style: normal; /* Removed italic to prevent leaning */
            text-align: center;
            line-height: 24px; /* Match the main line-height for centering */
            vertical-align: middle;
            font-size: 60%; /* Reduced by 40% for better artistic balance */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; /* Softer, less sharp font */
        }


        
        .ai-response-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 16px 0;
            padding: 12px 0;
            border-top: 1px solid #333;
        }
        


        /* Chord Progression Sequencer */
        .sequencer-container {
            background: transparent;
            border: none;
            padding: 19px;
            position: absolute;
            top: calc(100% + 118px); /* Moved up by 22px from 140px to 118px */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1;
            width: 100%; /* container spans page; inner elements manage their own width */
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        /* Keep control row fixed width and centered */
        .sequencer-controls {
            width: 640px;
            margin: 0 auto 20px;
        }

        /* Base step grid width and centered */
        #step-container {
            width: 640px;
            margin: 0 auto;
        }

        /* Expand only the step grid area for >4 bars; controls remain fixed */
        .sequencer-container.bars-4 #step-container { width: 640px; }
        .sequencer-container.bars-5 #step-container,
        .sequencer-container.bars-6 #step-container { width: 960px; }
        .sequencer-container.bars-7 #step-container,
        .sequencer-container.bars-8 #step-container { width: 1280px; }

        .sequencer-container.hidden {
            opacity: 0;
            pointer-events: none;
            height: 0;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        /* Sequencer Status Area */
        .sequencer-status {
            margin-top: 15px;
            text-align: center;
            min-height: 20px;
        }

        .status-text {
            color: #ccc;
            font-size: 14px;
            font-style: italic;
            transition: all 0.3s ease;
        }

        .status-text.looping {
            color: #ff6b35;
            font-weight: bold;
            font-style: normal;
        }

        .status-text.copied {
            color: #4ade80;
            font-weight: bold;
            font-style: normal;
        }





        .sequencer-header {
            color: white;
            font-size: 18px;
            font-weight: 400;
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: 1px;
        }

        .sequencer-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 6px;
        }

        .sequencer-btn {
            background: linear-gradient(145deg, #232323 0%, #141414 40%, #050505 100%);
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.6),
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 2px rgba(255, 255, 255, 0.02),
                inset 0 -2px 3px rgba(0, 0, 0, 0.4);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
        }

        /* White border when a sequencer control (like SEQ) is selected */
        #seq-btn.selected {
            border: 2px solid #ffffff !important;
            box-shadow: 0 0 10px 2px rgba(78, 34, 16, 0.9), 0 0 22px 6px rgba(78, 34, 16, 0.5);
        }

        .sequencer-btn:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 2px 4px rgba(0, 0, 0, 0.6);
        }

        .play-btn {
            width: 72px;
            height: 55px;
            font-size: 22px;
            color: #8B4513;
        }

        .stop-btn {
            width: 48px;
            height: 55px;
            font-size: 18px;
            color: #888;
        }

        .clear-btn {
            width: 72px;
            height: 55px;
            font-size: 14px;
            color: #888;
        }

        .tempo-display, .bars-display {
            background: linear-gradient(145deg, #232323 0%, #141414 40%, #050505 100%);
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.6),
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 2px rgba(255, 255, 255, 0.02),
                inset 0 -2px 3px rgba(0, 0, 0, 0.4);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
            width: 72px;
            height: 55px;
            flex-direction: column;
            position: relative; /* keep BPM/BARS label anchored inside button */
        }

        /* BPM selected white border (from bak) */
        .tempo-display.selected {
            border: 2px solid #ffffff !important;
            box-shadow: 0 0 10px 2px rgba(78, 34, 16, 0.9), 0 0 22px 6px rgba(78, 34, 16, 0.5);
        }

        .tempo-label, .bars-label {
            font-size: 10px;
            color: #aaa;
            margin-bottom: 1px;
            line-height: 1;
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }

        .tempo-value,         .bars-value {
            font-size: 18px;
            line-height: 1;
            margin-top: 8px;
        }
        
        .time-signature-label {
            font-size: 10px;
            color: #aaa;
            margin-top: 2px;
            line-height: 1;
        }
        


        .tempo-display:active, .bars-display:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                inset 0 2px 4px rgba(0, 0, 0, 0.6);
        }

        .click-btn {
            width: 72px;
            height: 55px;
            font-size: 14px;
            color: #888;
        }
        .tap-btn {
            width: 72px;
            height: 55px;
            font-size: 14px;
            color: #ffffff;
        }

        .midi-btn {
            width: 72px;
            height: 55px;
            font-size: 18px;
            color: #6366f1; /* keep purple text */
            position: relative;
        }
        .seq-label {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #9aa0ff;
            line-height: 1;
            pointer-events: none;
        }
        .seq-value {
            margin-top: 10px;
        }

        .step-grid-container {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            justify-content: center;
            width: 100%;
        }

        .step-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 9px;
            align-items: start;
        }
        
        /* 3/4 time signature grid - 3 columns instead of 4 */
        .step-grid[data-time-signature="3/4"] {
            grid-template-columns: repeat(3, 1fr);
        }
        
        /* Adjust spacing for 3/4 time to make it look balanced */
        .step-grid[data-time-signature="3/4"] .step-slot {
            min-width: 40px; /* Slightly wider slots for 3/4 time */
        }

        /* Keep step-grid flexible; container width scales for >4 bars */

        .step-slot {
            width: calc(100% - 7px);
            height: 38px;
            background: linear-gradient(145deg, #232323 0%, #141414 40%, #050505 100%);
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.45),
                inset 0 1px 2px rgba(255, 255, 255, 0.02),
                inset 0 -2px 3px rgba(0, 0, 0, 0.4);
            color: #ddd;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
            min-width: 33px;
        }
        
        /* Keep step-slot sizing consistent; widen container instead of shrinking buttons */

        .step-slot:hover {
            border-color: #444;
            background: linear-gradient(145deg, #2b2b2b 0%, #191919 40%, #0b0b0b 100%);
        }

        .step-slot.active {
            border-color: #ff8c00 !important;
            background: linear-gradient(145deg, #3a2a1a, #2a1a0a) !important;
            color: white !important;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.6),
                0 0 8px rgba(255, 140, 0, 0.3),
                inset 0 1px 2px rgba(255, 140, 0, 0.2) !important;
        }

        .step-slot.selected {
            border-color: rgba(255, 140, 0, 0.4);
            background: linear-gradient(145deg, #2b1d10 0%, #180d04 50%, #090909 100%);
            box-shadow: 
                0 0 8px rgba(255, 140, 0, 0.15),
                inset 0 1px 2px rgba(255, 140, 0, 0.1);
        }

        .step-slot.duration-edit {
            border-color: #ffffff;
            border-width: 2px;
            background: linear-gradient(145deg, #2b2b2b 0%, #191919 40%, #0b0b0b 100%);
            box-shadow: 
                0 0 12px rgba(255, 255, 255, 0.3),
                inset 0 1px 2px rgba(255, 255, 255, 0.1);
        }

        .bar-divider {
            width: 3px;
            background: #000000;
            margin: 0 2px;
        }

        /* Time Signature Modal */
        .time-signature-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .time-signature-modal.show { display: flex; }
        .time-signature-modal .time-signature-content {
            width: 400px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: hidden;
            border-radius: 12px;
            background: #111;
            border: 1px solid #333;
            box-shadow: 0 12px 24px rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
        }
        .time-signature-header {
            padding: 18px 20px;
            color: #fff;
            font-size: 21px;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .time-signature-close {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            border-radius: 10px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
        }
        .time-signature-body {
            padding: 21px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .time-signature-option {
            padding: 16px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .time-signature-option:hover {
            background: #2a2a2a;
            border-color: #555;
        }
        .time-signature-option.selected {
            background: #3a2a1a;
            border-color: #ff8c00;
        }
        .time-signature-display {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 8px;
        }
        .time-signature-description {
            font-size: 14px;
            color: #aaa;
        }

        /* Save/Load Modal */
        .song-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .song-modal.show { display: flex; }
        .song-modal .song-content {
            width: 720px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: hidden;
            border-radius: 12px;
            background: #111;
            border: 1px solid #333;
            box-shadow: 0 12px 24px rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
        }
        
        .palette-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: #3a3a3a;
            border-radius: 8px;
            border: 1px solid #555;
        }
        
        .palette-name {
            font-weight: 500;
            color: white;
        }
        
        .palette-actions {
            display: flex;
            gap: 8px;
        }
        
        .palette-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        
        .palette-btn.load {
            background: #4CAF50;
            color: white;
        }
        
        .palette-btn.load:hover {
            background: #45a049;
        }
        
        .palette-btn.delete {
            background: #f44336;
            color: white;
        }
        
        .palette-btn.delete:hover {
            background: #d32f2f;
        }
        .song-header {
            padding: 18px 20px; /* +30% */
            color: #fff;
            font-size: 21px; /* +30% */
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .song-tabs {
            display: flex;
            gap: 8px; /* +30% */
            padding: 13px 16px; /* +30% */
            border-bottom: 1px solid #222;
        }
        .song-tab {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ddd;
            padding: 8px 13px; /* +30% */
            border-radius: 10px; /* +25% */
            cursor: pointer;
            font-size: 18px; /* larger text */
        }
        .song-tab.active { border-color: #fff; color: #fff; }
        .song-body { padding: 21px; overflow: auto; color: #ddd; font-size: 18px; }
        .song-row { display: flex; gap: 10px; align-items: center; margin-bottom: 13px; }
        .song-input { flex: 1; background:#0f0f0f; color:#fff; border:1px solid #333; border-radius:10px; padding:10px 12px; font-size: 18px; }
        .song-btn { background:#222; color:#fff; border:1px solid #444; border-radius:10px; padding:10px 16px; cursor:pointer; font-size: 18px; }

        .send-to-ai-btn {
            background: #1a1a1a;
            border: 1px solid #4ade80;
            color: #4ade80;
        }

        .send-to-ai-btn:hover {
            background: #4ade80;
            color: #000;
        }
        .song-list { display:flex; flex-direction:column; gap:8px; }
        .song-item { display:flex; align-items:center; justify-content:space-between; background:#151515; border:1px solid #333; border-radius:10px; padding:10px 13px; font-size: 18px; }
        .song-name { color:#fff; }
        .song-actions { display:flex; gap:8px; }
        .song-checks { display:flex; gap:16px; margin: 8px 0 16px; font-size: 18px; }

        /* Global content offset (excludes fixed top title) */
        #app-content { transform: translateY(50px); }


    </style>
</head>
<body>
    <!-- Background elements -->
    <img id="background-image" class="background-image" style="display: none;">
    <div id="background-overlay" class="background-overlay" style="display: none;"></div>
    
    <!-- Hidden file inputs -->
    <input type="file" id="file-input" accept="image/*" style="display: none;">

    <!-- Eye button removed -->

    <!-- MIDI and slot indicators -->
    <div class="midi-indicator">
        <div class="midi-dot" id="midi-dot"></div>
        <span>MIDI <span id="midi-status">OFF</span></span>
    </div>



    <div class="slot-indicator" id="slot-indicator">
        <span>SLOT: <span id="slot-number">1</span> ↑↓</span>
    </div>

    <div id="app-content" class="main-container">


        <div class="piano-xl-container">
            <!-- Controls Row -->
            <div class="controls-row">
                <!-- Bass Button -->
                <div class="control-btn bass-btn" id="bass-btn">𝄢</div>

                <!-- Filter Knob -->
                <div class="knob filter-knob" id="filter-knob">
                    <div class="knob-name">REVERB</div>
                    <div class="knob-value" id="filter-value">1</div>
                </div>

                <!-- Transpose Knob -->
                <div class="knob transpose-knob" id="transpose-knob">
                    <div class="knob-name">DELAY</div>
                    <div class="knob-value" id="transpose-value">0</div>
                </div>

                <!-- Sounds Button -->
                <div class="control-btn sounds-btn" id="sounds-btn">
                    <div class="btn-label">SOUNDS</div>
                    <div class="btn-value" id="sound-name">11</div>
                </div>

                <!-- Key Button -->
                <div class="control-btn key-btn" id="key-btn">
                    <div class="btn-label">KEY</div>
                    <div class="btn-value" id="key-value">C</div>
                </div>

                <!-- Mode Button -->
                <div class="control-btn mode-btn" id="mode-btn">
                    <div class="mode-header" id="mode-header">MODE</div>
                    <div class="btn-value" id="mode-value">FREE</div>
                </div>

                <!-- Octave Button -->
                <div class="control-btn oct-btn" id="oct-btn">
                    <div class="btn-label">OCT</div>
                    <div class="btn-value" id="oct-value">0</div>
                </div>

                <!-- Inversion Button -->
                <div class="control-btn inv-btn" id="inv-btn">
                    <div class="btn-label">INV</div>
                    <div class="btn-value" id="inv-value">-2</div>
                </div>

                <!-- Chord Button -->
                <div class="control-btn chord-btn" id="chord-btn">
                    <div class="btn-label">CHORD</div>
                    <div class="btn-value" id="chord-value">---</div>
                </div>
            </div>

            
            <!-- Side PIANO Label (restored) -->
            <div class="piano-text-container">
                <span class="piano-text" id="piano-label">P I A N O</span>
                <!-- Keyboard help panel (hover text) -->
                <div class="kbd-help-panel" id="kbd-help"><div class="kbd-help-title">SHORTCUTS</div><pre>
PIANO WHITE KEYS:
A, S, D, F, G, H, J

PIANO BLACK KEYS:
W, E, T, Y, U

+ : SCROLL
- : SCROLL

LEFT & RIGHT ARROWS:
NAVIGATES THROUGH THE SETTINGS

UP & DOWN ARROWS:
TO PLAY THE VARIOUS SLOT LEVELS
(OF XXL, XXXL, AND X MODES)

0:
EXIT SELECTED SETTING

ESC:
EXIT TEXT INPUT FIELD

SHIFT:
HOLD SHIFT AND DOUBLE TAP CHORD
LOCKS THE CURRENT OCTAVE AND INVERSION
INTO A CHORD SLOT. (XXL, XXL, AND X MODES)

SPACEBAR:
SELECTS THE TEXT INPUT FIELD
(WHEN SEQUENCER IS CLOSED)

SPACEBAR:
PLAY / STOP
(WHEN SEQUENCER IS OPEN)
</pre></div>
            </div>

            <!-- XL Button -->
            <div class="xl-button-container">
                <div class="xl-button" id="xl-button">XL</div>
            </div>

            <!-- Vertical Fader -->
            <div class="fader-container">
                <div class="vertical-fader" id="vertical-fader">
                    <div class="fader-thumb" id="fader-thumb"></div>
                </div>
            </div>

            <!-- Plus/Minus side buttons -->
            <div class="side-buttons">
                <div class="side-btn" id="plus-btn">+</div>
                <div class="side-btn" id="minus-btn">−</div>
            </div>

            <!-- Piano Keys -->
            <div class="piano-section mode-xl" id="piano-section">
                <div class="black-keys">
                    <div class="spacer"></div>
                    <div class="piano-key black-key" data-note="C#" id="key-C#"></div>
                    <div class="piano-key black-key" data-note="D#" id="key-D#"></div>
                    <div class="spacer"></div>
                    <div class="piano-key black-key" data-note="F#" id="key-F#"></div>
                    <div class="piano-key black-key" data-note="G#" id="key-G#"></div>
                    <div class="piano-key black-key" data-note="A#" id="key-A#"></div>
                    <div class="spacer"></div>
                </div>

                <div class="white-keys">
                    <div class="piano-key white-key" data-note="C" id="key-C"></div>
                    <div class="piano-key white-key" data-note="D" id="key-D"></div>
                    <div class="piano-key white-key" data-note="E" id="key-E"></div>
                    <div class="piano-key white-key" data-note="F" id="key-F"></div>
                    <div class="piano-key white-key" data-note="G" id="key-G"></div>
                    <div class="piano-key white-key" data-note="A" id="key-A"></div>
                    <div class="piano-key white-key" data-note="B" id="key-B"></div>
                </div>

                <!-- Bottom buttons -->
                <div class="bottom-buttons">
                    <div class="bottom-btn camera-btn" id="camera-btn" style="position: relative;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                            <circle cx="12" cy="13" r="4"/>
                        </svg>
                    </div>

                    <div class="bottom-btn disable-btn" id="disable-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="m4.9 4.9 14.2 14.2"/>
                        </svg>
                    </div>




                    
                    <!-- Chord input field -->
                    <div class="chord-input-container">
                        <input type="text" class="chord-input" id="chord-input" placeholder="" maxlength="100">

                    </div>

                    <div class="bottom-btn save-btn" id="save-btn">
                        <svg width="19" height="19" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                            <polyline points="17,21 17,13 7,13 7,21"/>
                            <polyline points="7,3 7,8 15,8"/>
                        </svg>
                    </div>

                    <div class="bottom-btn progression-btn" id="progression-btn">
                        <span style="font-size: 18px; font-weight: 500;">▶</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chord Progression Sequencer -->
        <div class="sequencer-container hidden" id="sequencer">
            <!-- Control Row -->
            <div class="sequencer-controls">
                <div class="sequencer-btn play-btn" id="play-btn" title="Play sequence">▶</div>
                <div class="sequencer-btn stop-btn" id="stop-btn" title="Stop sequence">◼</div>
                <div class="sequencer-btn click-btn" id="click-btn" title="Toggle click track">CLICK</div>
                
                <div class="tempo-display" id="tempo-display" 
                     onmousedown="startTempoLongPress(event)" 
                     onmouseup="endTempoLongPress(event)" 
                     onmouseleave="endTempoLongPress(event)"
                     ontouchstart="startTempoLongPress(event)" 
                     ontouchend="endTempoLongPress(event)"
                     title="Long press to change tempo">
                    <div class="tempo-label">BPM</div>
                    <div class="tempo-value" id="tempo-value">85</div>
                </div>
                
                <div class="bars-display" id="bars-display" title="Long press to change time signature">
                    <div class="bars-label">BARS</div>
                    <div class="bars-value" id="bars-value">2</div>
                    <div class="time-signature-label" id="time-signature-label">4/4</div>
                </div>
                
                <div class="sequencer-btn tap-btn" id="tap-btn" title="Tap to set tempo">TAP</div>
                <div class="sequencer-btn midi-btn" id="seq-btn" title="Change sequence">
                    <div class="seq-label">SEQ</div>
                    <div class="seq-value">1</div>
                </div>
            </div>

            <!-- Dynamic Step Grid -->
            <div id="step-container">
                <!-- This will be populated by JavaScript -->
            </div>
            
            <!-- Sequencer Status Area -->
            <div class="sequencer-status" id="sequencer-status">
                <div class="status-text" id="status-text">
                    
                </div>
            </div>


        </div>
        </div>
    </div>

    <!-- Time Signature Modal -->
    <div class="time-signature-modal" id="time-signature-modal">
        <div class="time-signature-content">
            <div class="time-signature-header">
                <div>Time Signature</div>
                <button class="time-signature-close" id="time-signature-close">✕</button>
            </div>
            <div class="time-signature-body">
                <div class="time-signature-option" data-signature="4/4">
                    <div class="time-signature-display">4/4</div>
                    <div class="time-signature-description">Common Time (8 beats per bar)</div>
                </div>
                <div class="time-signature-option" data-signature="3/4">
                    <div class="time-signature-display">3/4</div>
                    <div class="time-signature-description">Waltz Time (6 beats per bar)</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Save/Load Modal (centered) -->
    <div class="song-modal" id="song-modal">
        <div class="song-content">
            <div class="song-header">
                <div>Save / Load</div>
                <button class="song-btn" id="song-close">Close</button>
            </div>
            <div class="song-tabs">
                <button class="song-tab active" data-tab="save">Save</button>
                <button class="song-tab" data-tab="load">Load</button>
                <button class="song-tab" data-tab="json">Import / Export</button>
                <button class="song-tab" data-tab="midi">MIDI</button>
            </div>
            <div class="song-body">
                <div class="song-panel" id="tab-save">
                    <div class="song-row">
                        <input class="song-input" id="song-name" placeholder="Song name"/>
                        <button class="song-btn" id="song-save">Save</button>
                    </div>
                </div>
                <div class="song-panel" id="tab-load" style="display:none;">
                    <div class="song-list" id="song-list"></div>
                </div>
                <div class="song-panel" id="tab-json" style="display:none;">
                    <div class="song-row">
                        <input type="file" id="song-import" accept=".json,.md,text/markdown,application/json" style="display:none;"/>
                        <button class="song-btn" id="song-import-btn">IMPORT SONG</button>
                        <button class="song-btn" id="song-export-btn">EXPORT CURRENT SONG</button>
                    </div>
                    <textarea class="song-input" id="song-json-preview" style="height:220px; display:none;"></textarea>
                </div>
                <div class="song-panel" id="tab-midi" style="display:none;">
                    <div class="song-checks">
                        <label><input type="checkbox" class="seq-check" value="0" checked/> Seq 1</label>
                        <label><input type="checkbox" class="seq-check" value="1"/> Seq 2</label>
                        <label><input type="checkbox" class="seq-check" value="2"/> Seq 3</label>
                        <label><input type="checkbox" class="seq-check" value="3"/> Seq 4</label>
                        <label><input type="checkbox" class="seq-check" value="4"/> Seq 5</label>
                        <label><input type="checkbox" class="seq-check" value="5"/> Seq 6</label>
                        <label><input type="checkbox" class="seq-check" value="6"/> Seq 7</label>
                        <label><input type="checkbox" class="seq-check" value="7"/> Seq 8</label>
                    </div>
                    <button class="song-btn" id="song-export-midi">Export Selected MIDI</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal removed -->

    <script>
        const SUPABASE_URL = 'https://0ec90b57d6e95fcbda19832f.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJib2x0IiwicmVmIjoiMGVjOTBiNTdkNmU5NWZjYmRhMTk4MzJmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg4ODE1NzQsImV4cCI6MTc1ODg4MTU3NH0.9I8-U0x86Ak8t2DGaIk0HfvTSLsAyzdnz-Nw00mMkKw';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        let currentUser = null;

        async function initAuth() {
            const { data: { session } } = await supabase.auth.getSession();
            currentUser = session?.user || null;

            if (currentUser) {
                await checkAccessAndRefresh();
            } else {
                window.location.href = '/';
            }

            supabase.auth.onAuthStateChange((event, session) => {
                (() => {
                    currentUser = session?.user || null;
                    if (currentUser) {
                        checkAccessAndRefresh();
                    } else {
                        window.location.href = '/';
                    }
                })();
            });
        }

        async function checkAccessAndRefresh() {
            if (!currentUser) return;

            try {
                const { data: profile, error } = await supabase
                    .from('profiles')
                    .select('subscription_status, subscription_tier, tester_expires_at')
                    .eq('id', currentUser.id)
                    .maybeSingle();

                if (error) {
                    console.error('Error checking access:', error);
                    window.location.href = '/';
                    return;
                }

                let hasAccess = false;

                if (profile?.subscription_status === 'active') {
                    if (profile?.subscription_tier === 'tester') {
                        if (profile?.tester_expires_at) {
                            hasAccess = new Date(profile.tester_expires_at) > new Date();
                        } else {
                            hasAccess = true;
                        }
                    } else {
                        hasAccess = true;
                    }
                }

                if (!hasAccess) {
                    window.location.href = '/';
                    return;
                }

                await refreshSongList();
            } catch (error) {
                console.error('Error checking access:', error);
                window.location.href = '/';
            }
        }

        initAuth();

        // Sequencer state (backend wiring)
        let isPlaying = false;
        let currentStep = -1;
        let playInterval = null;
        let chordStopTimer = null;
        let currentBars = 2;
        let currentTimeSignature = "4/4";
let currentBeatsPerBar = 8;

// Duration edit mode state
let durationEditMode = false;
let durationEditStep = -1;
let durationEditSteps = new Set(); // Track multiple selected steps for duration editing
        let totalSteps = 16;
        let tempo = 85;
        let clickEnabled = true;
        let isBPMDoubled = false; // Track if BPM has been doubled
        // Each entry: { id: number, chord: { root: string, type: string } | null }
        let progression = Array(64).fill(null).map((_, i) => ({ id: i, chord: null }));
        // Eight independent sequence slots (1..8), each stores its own state
        const sequenceSlots = Array.from({ length: 8 }, () => ({
            bars: 2,
            tempo: 85,
            timeSignature: "4/4", // 4/4 or 3/4
            beatsPerBar: 8, // 8 for 4/4, 6 for 3/4
            progression: Array(64).fill(null).map((_, i) => ({ id: i, chord: null }))
        }));
        let currentSequenceIndex = 0; // 0..7 shown on button as 1..8
        let pendingSequenceIndex = null; // when set, switch at loop boundary

        function buildStepGrid() {
            const container = document.getElementById('step-container');
            if (!container) return;
            container.className = `step-container bars-${currentBars}`;
            // Also reflect bar class on the outer sequencer container for width scaling
            const sc = document.getElementById('sequencer');
            if (sc) {
                sc.classList.remove('bars-1','bars-2','bars-3','bars-4','bars-5','bars-6','bars-7','bars-8');
                sc.classList.add(`bars-${currentBars}`);
            }
            
            let html = '';
            const beatsPerBar = currentBeatsPerBar;
            const stepsPerBar = beatsPerBar; // 8 for 4/4, 6 for 3/4
            
            if (currentBars === 1) {
                // Single bar layout
                if (currentTimeSignature === "3/4") {
                    // 3/4 time: 1 bar = 6 steps = 2 rows of 3
                    for (let row = 0; row < 2; row++) {
                        html += '<div class="step-grid-container">';
                        html += `<div class="step-grid" data-time-signature="${currentTimeSignature}">`;
                        
                        for (let step = 0; step < 3; step++) {
                            const globalStep = row * 3 + step;
                            html += `<div class="step-slot" data-row="${row}" data-step="${globalStep}"></div>`;
                        }
                        
                        html += '</div></div>';
                    }
                } else {
                    // 4/4 time: 1 bar = 8 steps = 2 rows of 4
                    const rows = Math.ceil(stepsPerBar / 4);
                    for (let row = 0; row < rows; row++) {
                        html += '<div class="step-grid-container">';
                        html += `<div class="step-grid" data-time-signature="${currentTimeSignature}">`;
                        const stepsInThisRow = Math.min(4, stepsPerBar - (row * 4));
                        for (let step = 0; step < stepsInThisRow; step++) {
                            const globalStep = row * 4 + step;
                            html += `<div class="step-slot" data-row="${row}" data-step="${globalStep}"></div>`;
                        }
                        html += '</div></div>';
                    }
                }
            } else {
                // Multiple bars layout
                if (currentTimeSignature === "3/4") {
                    // 3/4 time: Follow exact same block structure as 4/4
                    // Each block = 2 bars = 12 steps (4 rows of 3)
                    const blocks = Math.ceil(currentBars / 2);
                    
                    for (let row = 0; row < 4; row++) {
                        html += '<div class="step-grid-container">';
                        for (let block = 0; block < blocks; block++) {
                            if (block > 0) html += '<div class="bar-divider"></div>';
                            html += `<div class="step-grid" data-time-signature="${currentTimeSignature}">`;
                            
                            const barsInThisBlock = Math.min(2, currentBars - (block * 2));
                            let shouldShowThisRow = true;
                            
                            // Handle odd bar counts (same logic as 4/4)
                            if (currentBars === 3 && block === 1) {
                                shouldShowThisRow = row < 2; // Only show top 2 rows for the last 1 bar
                            } else if (currentBars === 5 && block === 2) {
                                shouldShowThisRow = row < 2; // Only show top 2 rows for the last 1 bar
                            } else if (currentBars === 7 && block === 3) {
                                shouldShowThisRow = row < 2; // Only show top 2 rows for the last 1 bar
                            }
                            
                            if (shouldShowThisRow) {
                                for (let step = 0; step < 3; step++) {
                                    const sectionStart = block * 12; // 2 bars per section => 12 steps
                                    const barIndex = (row < 2) ? 0 : 1; // rows 0-1 = first bar, 2-3 = second bar
                                    const rowOffset = (row % 2 === 0) ? 0 : 3; // top row 0..2, bottom row 3..5
                                    const globalStep = sectionStart + (barIndex * 6) + rowOffset + step;
                                    
                                    html += `<div class="step-slot" data-row="${row}" data-step="${globalStep}"></div>`;
                                }
                            } else {
                                for (let step = 0; step < 3; step++) {
                                    html += `<div class="step-slot" style="visibility: hidden;"></div>`;
                                }
                            }
                            html += '</div>';
                        }
                        html += '</div>';
                    }
                } else {
                    // 4/4 time: Restore proper complex layout for multiple bars
                    const sections = Math.ceil(currentBars / 2);
                    for (let row = 0; row < 4; row++) {
                        html += '<div class="step-grid-container">';
                        for (let section = 0; section < sections; section++) {
                            if (section > 0) html += '<div class="bar-divider"></div>';
                            html += `<div class="step-grid" data-time-signature="${currentTimeSignature}">`;
                            
                            let stepsToShow = 4;
                            let shouldShowThisRow = true;
                            
                            // Handle odd bar counts
                            if (currentBars === 3 && section === 1) {
                                shouldShowThisRow = row < 2;
                            } else if (currentBars === 4) {
                                shouldShowThisRow = true;
                            } else if (currentBars === 5 && section === 2) {
                                shouldShowThisRow = row < 2;
                            } else if (currentBars === 7 && section === 3) {
                                shouldShowThisRow = row < 2;
                            }
                            
                            if (shouldShowThisRow) {
                                for (let step = 0; step < stepsToShow; step++) {
                                    const sectionStart = section * 16; // 2 bars per section => 16 steps
                                    const barIndex = (row < 2) ? 0 : 1; // rows 0-1 = first bar, 2-3 = second bar
                                    const rowOffset = (row % 2 === 0) ? 0 : 4; // top row 0..3, bottom row 4..7
                                    const globalStep = sectionStart + (barIndex * 8) + rowOffset + step;
                                    
                                    html += `<div class="step-slot" data-row="${row}" data-step="${globalStep}"></div>`;
                                }
                            } else {
                                for (let step = 0; step < 4; step++) {
                                    html += `<div class="step-slot" style="visibility: hidden;"></div>`;
                                }
                            }
                            html += '</div>';
                        }
                        html += '</div>';
                    }
                }
            }
            
            container.innerHTML = html;
            
            // Update total steps based on current time signature
            totalSteps = currentBars * beatsPerBar;
            

            

            
            ensureProgressionSize();
            attachStepHandlers();
            refreshStepSelections();
            
            // Clamp currentStep into new visible range so playback marker stays valid
            const maxSteps = currentBars * beatsPerBar;
            if (currentStep >= maxSteps) currentStep = maxSteps - 1;
        }

        function ensureProgressionSize() {
            // Never shrink (to preserve chords when cycling bar count). Only extend up to 64 steps.
            const needed = Math.min(totalSteps, 64);
            if (progression.length < needed) {
                const start = progression.length;
                for (let i = start; i < needed; i++) progression[i] = { id: i, chord: null };
            }
            
            // Ensure all existing chords have duration property (migration for older songs)
            progression.forEach(step => {
                if (step && step.chord && step.chord.duration === undefined) {
                    step.chord.duration = 2; // Default duration
                }
            });
            
            // Persist progression state to current sequence slot
            sequenceSlots[currentSequenceIndex].progression = progression.slice();
        }

        function attachStepHandlers() {
            const slots = document.querySelectorAll('.step-slot[data-step]');
            slots.forEach(slot => {
                const stepIndex = parseInt(slot.getAttribute('data-step'));
                // Long-press to COPY a step's chord/meta for placement
                let pressTimer = null;
                

                
                slot.onmousedown = (e) => {
                    e.preventDefault();
                    // Start long-press timer
                    pressTimer = setTimeout(() => {
                        const data = progression[stepIndex] && progression[stepIndex].chord;
                        if (data) {
                            state.selectedChordForStep = { root: data.root, type: data.type };
                            state.selectedChordMeta = {
                                slotIndex: data.slotIndex ?? 0,
                                bassOffset: data.bassOffset ?? 0,
                                octave: data.octave ?? state.octave,
                                inversion: data.inversion ?? state.inversion,
                                duration: data.duration ?? 2
                            };
                            showSequencerMessage('COPIED', 'copied');
                        }
                    }, 600);
                    handleStepClick(stepIndex, e);
                };
                slot.onmouseup = (e) => {
                    if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
                    handleStepRelease(stepIndex, e);
                };
                slot.ondblclick = () => handleStepClear(stepIndex);
            });
        }

        function refreshStepSelections() {
            const slots = document.querySelectorAll('.step-slot[data-step]');
            slots.forEach(slot => {
                const stepIndex = parseInt(slot.getAttribute('data-step'));
                const row = parseInt(slot.getAttribute('data-row'));
                const hasChord = progression[stepIndex] && progression[stepIndex].chord;
                if (hasChord) {
                    slot.classList.add('selected');
                    const chord = progression[stepIndex].chord;
                    
                    // Check if we're in duration edit mode for this step
                    if (durationEditMode && durationEditSteps.has(stepIndex)) {
                        // Show duration number instead of chord name and add duration-edit class
                        slot.textContent = String(chord.duration || 2);
                        slot.classList.add('duration-edit');
                    } else {
                        // Show normal chord name and remove duration-edit class
                        slot.classList.remove('duration-edit');
                        
                                                const chordKey = chord.root + '-' + chord.type + '-' + (chord.slotIndex ?? 0);
                        // Prefer stored name (may already include slash), otherwise build
                        let display = chord.name || MusicEngine.getChordName(chord.root, chord.type, state.useFlats);
                        if (!display.includes('/')) {
                            // Append slash from bassOffset if present
                            if (typeof chord.bassOffset === 'number' && chord.bassOffset !== 0) {
                                const rootIdx = KEYS.indexOf(chord.root);
                                if (rootIdx !== -1) {
                                    const bassIdx = (rootIdx + chord.bassOffset + 120) % 12;
                                    const bassNameSharp = KEYS[bassIdx];
                                    const bassName = state.useFlats && SHARP_TO_FLAT[bassNameSharp] ? SHARP_TO_FLAT[bassNameSharp] : bassNameSharp;
                                    display = `${display}/${bassName}`;
                                }
                            } else if (typeof state.bassOffsets[chordKey] === 'number' && state.bassOffsets[chordKey] !== 0) {
                                // Fallback to session bassOffsets if available
                                const rootIdx = KEYS.indexOf(chord.root);
                                const off = state.bassOffsets[chordKey];
                                if (rootIdx !== -1) {
                                    const bassIdx = (rootIdx + off + 120) % 12;
                                    const bassNameSharp = KEYS[bassIdx];
                                    const bassName = state.useFlats && SHARP_TO_FLAT[bassNameSharp] ? SHARP_TO_FLAT[bassNameSharp] : bassNameSharp;
                                    display = `${display}/${bassName}`;
                                }
                            }
                        }
                        slot.textContent = display;
                    }
                } else {
                    slot.classList.remove('selected');
                    slot.textContent = '';
                }
            });
        }

        function setTempo(value) {
            try {
                // Validate input and clamp to safe range (increased to 300)
                const v = Math.max(60, Math.min(300, parseInt(value) || 120));
                
                // Only update if tempo actually changed
                if (tempo !== v) {
                    // If BPM was doubled, reset the doubled state when tempo changes manually
                    if (isBPMDoubled) {
                        isBPMDoubled = false;
                    }
                    tempo = v;
                    
                    // Update UI
                    const tv = document.getElementById('tempo-value');
                    if (tv) tv.textContent = String(tempo);
                    
                    // Persist to current sequence slot
                    if (sequenceSlots[currentSequenceIndex]) {
                        sequenceSlots[currentSequenceIndex].tempo = tempo;
                    }
                    
                    // If playing, restart loop with new tempo
                    if (isPlaying && playInterval) {
                        // Clean restart to prevent timing issues
                        if (playInterval) { 
                            clearInterval(playInterval); 
                            playInterval = null; 
                        }
                        if (chordStopTimer) { 
                            clearTimeout(chordStopTimer); 
                            chordStopTimer = null; 
                        }
                        
                        // Small delay to ensure cleanup is complete
                        setTimeout(() => {
                            if (isPlaying) startPlayLoop();
                        }, 10);
                    }
                }
            } catch (error) {
                console.error('setTempo error:', error);
                // Fallback to safe tempo
                tempo = 120;
                const tv = document.getElementById('tempo-value');
                if (tv) tv.textContent = String(tempo);
            }
        }

        // Long-press BPM doubling/halving
        let tempoLongPressTimer = null;
        let originalTempo = 85; // Store original BPM value
        const LONG_PRESS_DELAY = 500; // 500ms for long press

        function startTempoLongPress(event) {
            event.preventDefault();
            tempoLongPressTimer = setTimeout(() => {
                // Long press detected - toggle between doubled and halved
                if (!isBPMDoubled) {
                    // Store original tempo before doubling
                    originalTempo = tempo;
                    // Double the BPM
                    const newTempo = Math.min(300, tempo * 2);
                    if (newTempo <= 300) {
                        tempo = newTempo;
                        isBPMDoubled = true;
                        // Update UI
                        const tv = document.getElementById('tempo-value');
                        if (tv) tv.textContent = String(tempo);
                        // Persist to current sequence slot
                        if (sequenceSlots[currentSequenceIndex]) {
                            sequenceSlots[currentSequenceIndex].tempo = tempo;
                        }
                        console.log(`BPM doubled from ${originalTempo} to ${tempo}`);
                    }
                } else {
                    // Return to original tempo (not just halve current)
                    tempo = originalTempo;
                    isBPMDoubled = false;
                    // Update UI
                    const tv = document.getElementById('tempo-value');
                    if (tv) tv.textContent = String(tempo);
                    // Persist to current sequence slot
                    if (sequenceSlots[currentSequenceIndex]) {
                        sequenceSlots[currentSequenceIndex].tempo = tempo;
                    }
                    console.log(`BPM returned to original: ${tempo}`);
                }
                
                // If playing, restart loop with new tempo
                if (isPlaying && playInterval) {
                    if (playInterval) { 
                        clearInterval(playInterval); 
                        playInterval = null; 
                    }
                    if (chordStopTimer) { 
                        clearTimeout(chordStopTimer); 
                        chordStopTimer = null; 
                    }
                    setTimeout(() => {
                        if (isPlaying) startPlayLoop();
                    }, 10);
                }
            }, LONG_PRESS_DELAY);
        }

        function endTempoLongPress(event) {
            if (tempoLongPressTimer) {
                clearTimeout(tempoLongPressTimer);
                tempoLongPressTimer = null;
            }
        }

        // Tap tempo support
        let tapTimes = [];
        function handleTapTempo() {
            const now = performance.now();
            // Keep only taps within last 2 seconds
            tapTimes = tapTimes.filter(t => now - t < 2000);
            tapTimes.push(now);
            if (tapTimes.length >= 2) {
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i - 1]);
                }
                const avgMs = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const bpm = Math.round(60000 / avgMs);
                // Only set when BPM is within sensible range
                setTempo(Math.max(20, Math.min(300, bpm)));
                // Ensure BPM selection is visible to reflect current target
                state.selectedControl = 'tempo';
                updateControlValues();
            }
        }

        function setMaxBars(value) {
            const v = Math.max(1, Math.min(8, parseInt(value) || 2));
            currentBars = v;
            const bv = document.getElementById('bars-value');
            if (bv) bv.textContent = String(currentBars);
            // Persist to current sequence slot
            sequenceSlots[currentSequenceIndex].bars = currentBars;
            buildStepGrid();
            if (isPlaying) handleStop();
        }

        function setTimeSignature(timeSig) {
            currentTimeSignature = timeSig;
            currentBeatsPerBar = timeSig === "3/4" ? 6 : 8;
            
            // Persist to current sequence slot
            sequenceSlots[currentSequenceIndex].timeSignature = currentTimeSignature;
            sequenceSlots[currentSequenceIndex].beatsPerBar = currentBeatsPerBar;
            
            // Update UI
            const timeSigEl = document.getElementById('time-signature-label');
            if (timeSigEl) timeSigEl.textContent = currentTimeSignature;
            
            // Rebuild grid with new time signature
            buildStepGrid();
            if (isPlaying) handleStop();
            
            // Close modal
            closeTimeSignatureModal();
        }

        function openTimeSignatureModal() {
            const modal = document.getElementById('time-signature-modal');
            if (modal) {
                modal.classList.add('show');
                
                // Highlight current selection
                const options = modal.querySelectorAll('.time-signature-option');
                options.forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.signature === currentTimeSignature) {
                        option.classList.add('selected');
                    }
                });
            }
        }

        function closeTimeSignatureModal() {
            const modal = document.getElementById('time-signature-modal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        function startPlayLoop() {
            // CRITICAL: Always clear any existing loop before starting a new one
            if (playInterval) { 
                clearInterval(playInterval); 
                playInterval = null; 
            }
            if (chordStopTimer) { 
                clearTimeout(chordStopTimer); 
                chordStopTimer = null; 
            }
            
            // Validate tempo and bars to prevent crashes
            const safeTempo = Math.max(60, Math.min(300, tempo || 120));
            const safeBars = Math.max(1, Math.min(8, currentBars || 2));
            
            const interval = (60 / safeTempo / 2) * 1000;
            
            // Ensure currentStep is within valid range
            if (currentStep >= safeBars * (currentTimeSignature === "3/4" ? 6 : 8)) currentStep = 0;
            
            const tick = () => {
                // Multiple safety guards
                if (!isPlaying || !playInterval) return;
                
                try {
                    // Calculate maxSteps dynamically based on current sequence settings
                    const maxSteps = currentBars * (currentTimeSignature === "3/4" ? 6 : 8);
                    
                    // Calculate next step first
                    const candidateNext = (currentStep + 1) % maxSteps;
                    

                    
                    // If a sequence change is pending and we're at the loop boundary, switch BEFORE playing step 0
                    if (pendingSequenceIndex !== null && candidateNext === 0) {
                        console.log(`Switching sequence at loop boundary: ${pendingSequenceIndex} -> ${currentSequenceIndex}`);
                        const slot = sequenceSlots[pendingSequenceIndex];
                        if (slot) {
                                                    currentSequenceIndex = pendingSequenceIndex;
                        currentBars = Math.max(1, Math.min(8, slot.bars || 2));
                        currentTimeSignature = slot.timeSignature || "4/4";
                        currentBeatsPerBar = slot.beatsPerBar || 8;
                        tempo = Math.max(60, Math.min(300, slot.tempo || 120));
                        progression = Array.isArray(slot.progression) ? slot.progression.slice() : Array(64).fill(null).map((_, i) => ({ id: i, chord: null }));
                            
                            // Update UI
                            const tempoEl = document.getElementById('tempo-value');
                            const barsEl = document.getElementById('bars-value');
                            const timeSigEl = document.getElementById('time-signature-label');
                            const seqEl = document.querySelector('#seq-btn .seq-value');
                            if (tempoEl) tempoEl.textContent = String(tempo);
                            if (barsEl) barsEl.textContent = String(currentBars);
                            if (timeSigEl) timeSigEl.textContent = currentTimeSignature;
                            if (seqEl) seqEl.textContent = String(currentSequenceIndex + 1);
                            
                            buildStepGrid();
                            
                            // Update the interval calculation to use new tempo
                            const newInterval = (60 / tempo / 2) * 1000;
                            
                            // Restart the play loop with new parameters
                            if (playInterval) {
                                clearInterval(playInterval);
                                playInterval = setInterval(tick, newInterval);
                            }
                        }
                        pendingSequenceIndex = null;
                    }
                    
                    // Handle sequence loops when reaching the end of a sequence
                    if (state.sequenceLoop && candidateNext === 0 && currentStep > 0) {
                        const nextLoopIndex = (state.currentLoopIndex + 1) % state.sequenceLoop.length;
                        const nextSeqIndex = state.sequenceLoop[nextLoopIndex];
                        
                        if (nextSeqIndex !== currentSequenceIndex) {
                            console.log(`Sequence loop advancing: ${currentSequenceIndex + 1} -> ${nextSeqIndex + 1}`);
                            const slot = sequenceSlots[nextSeqIndex];
                            if (slot) {
                                                            currentSequenceIndex = nextSeqIndex;
                            currentBars = Math.max(1, Math.min(8, slot.bars || 2));
                            currentTimeSignature = slot.timeSignature || "4/4";
                            currentBeatsPerBar = slot.beatsPerBar || 8;
                            tempo = Math.max(60, Math.min(300, slot.tempo || 120));
                            progression = Array.isArray(slot.progression) ? slot.progression.slice() : Array(64).fill(null).map((_, i) => ({ id: i, chord: null }));
                                
                                // Update UI
                                const tempoEl = document.getElementById('tempo-value');
                                const barsEl = document.getElementById('bars-value');
                                const timeSigEl = document.getElementById('time-signature-label');
                                const seqEl = document.querySelector('#seq-btn .seq-value');
                                if (tempoEl) tempoEl.textContent = String(tempo);
                                if (barsEl) barsEl.textContent = String(currentBars);
                                if (timeSigEl) timeSigEl.textContent = currentTimeSignature;
                                if (seqEl) seqEl.textContent = String(nextSeqIndex + 1);
                                
                                buildStepGrid();
                                
                                // Update the interval calculation to use new tempo
                                const newInterval = (60 / tempo / 2) * 1000;
                                
                                // Restart the play loop with new parameters
                                if (playInterval) {
                                    clearInterval(playInterval);
                                    playInterval = setInterval(tick, newInterval);
                                }
                            }
                        }
                        
                        state.currentLoopIndex = nextLoopIndex;
                        updateSequenceLoopStatus();
                    }
                    
                    const nextStep = candidateNext;
                    currentStep = nextStep;
                    
                    highlightActiveStep(nextStep);
                    
                    // Click track with safety check - handle different time signatures
                    let isDownbeat = false;
                    if (currentTimeSignature === "3/4") {
                        // 3/4 time: Hi-Lo-Lo pattern (strong-weak-weak)
                        const posInBar = nextStep % 6; // 6 steps per bar in 3/4
                        isDownbeat = posInBar === 0 || posInBar === 3; // Steps 0 and 3 are strong beats
                        

                    } else {
                        // 4/4 time: Hi-Lo-Hi-Lo pattern (strong-weak-strong-weak)
                        const posInBar = nextStep % 8; // 8 steps per bar in 4/4
                        isDownbeat = posInBar === 0 || posInBar === 4; // Steps 0 and 4 are strong beats
                    }
                    
                    if (clickEnabled && audioEngine && typeof audioEngine.playClick === 'function') {
                        audioEngine.playClick(isDownbeat);
                    }
                    
                    // Play chord if present
                    const step = progression[nextStep];
                    if (step && step.chord && step.chord.root && step.chord.type) {
                        audioEngine.stopAllVoices();
                        
                        // Convert flat notes to sharp notes for chord creation
                        const rootNote = convertFlatToSharp(step.chord.root);
                        
                        // Debug: Log the chord info
                        console.log(`Sequencer playing chord: root=${step.chord.root}->${rootNote}, type=${step.chord.type}, originalName=${step.chord.name}`);
                        
                        const chord = createChord(rootNote, step.chord.type, step.chord.octave, step.chord.inversion);
                        if (chord) {
                            console.log(`Created chord:`, chord);
                            const slotIndex = step.chord.slotIndex ?? 0;
                            const bassOverride = (step.chord.bassOffset !== undefined) ? step.chord.bassOffset : 0;
                            playChord(chord, 0.8, slotIndex, 'seq', bassOverride, step.chord.octave, step.chord.inversion);
                        }
                        
                        // Clear existing timer before setting new one
                        if (chordStopTimer) { 
                            clearTimeout(chordStopTimer); 
                            chordStopTimer = null; 
                        }
                        
                        // Stop after chord duration (respects individual chord duration)
                        const chordDuration = step.chord.duration || 2; // Default to 2 if not set
                        const chordDurationMs = (60 / safeTempo / 2) * 1000 * chordDuration;
                        chordStopTimer = setTimeout(() => {
                            if (audioEngine && typeof audioEngine.stopAllVoices === 'function') {
                                audioEngine.stopAllVoices();
                            }
                        }, chordDurationMs);
                    }
                } catch (error) {
                    console.error('Sequencer tick error:', error);
                    // Emergency stop on error
                    handleStop();
                }
            };
            
            // Trigger first tick immediately for responsive start
            tick();
            playInterval = setInterval(tick, interval);
        }

        function highlightActiveStep(index) {
            const slots = document.querySelectorAll('.step-slot[data-step]');
            slots.forEach(slot => slot.classList.remove('active'));
            const slot = document.querySelector(`.step-slot[data-step="${index}"]`);
            if (slot) slot.classList.add('active');
        }

        function handlePlay() {
            if (isPlaying) return;
            isPlaying = true;
            currentStep = -1;
            audioEngine.stopAllVoices();
            if (playInterval) { clearInterval(playInterval); playInterval = null; }
            startPlayLoop();
        }

        function handleStop() {
            // Set state first to prevent new operations
            isPlaying = false;
            
            // Clear any pending sequence changes
            pendingSequenceIndex = null;
            
            // Clean up all timers and intervals
            if (playInterval) { 
                clearInterval(playInterval); 
                playInterval = null; 
            }
            if (chordStopTimer) { 
                clearTimeout(chordStopTimer); 
                chordStopTimer = null; 
            }
            
            // Reset step position
            currentStep = -1;
            
            // Stop all audio
            if (audioEngine && typeof audioEngine.stopAllVoices === 'function') {
                audioEngine.stopAllVoices();
            }
            
            // Send MIDI all-notes-off
            if (audioEngine && typeof audioEngine.allNotesOff === 'function') {
                audioEngine.allNotesOff(15); // Chords on ch 16
                audioEngine.allNotesOff(14); // Bass on ch 15
            }
            
            // Clear visual indicators
            const slots = document.querySelectorAll('.step-slot[data-step]');
            slots.forEach(slot => slot.classList.remove('active'));
            
            // Clear sequence loop status when stopping
            if (state.sequenceLoop) {
                state.sequenceLoop = null;
                state.currentLoopIndex = 0;
                updateSequenceLoopStatus();
            }
        }
        
        // Global cleanup function for stability
        function cleanupSequencer() {
            handleStop();
            
            // Don't reset currentBars and tempo - preserve them from the current sequence
            // Only reset if we don't have valid values
            if (typeof currentBars !== 'number' || currentBars < 1 || currentBars > 8) {
                currentBars = 2;
            }
            if (typeof tempo !== 'number' || tempo < 60 || tempo > 300) {
                tempo = 120;
            }
            currentStep = -1;
            
            // Ensure progression is valid
            if (!Array.isArray(progression) || progression.length === 0) {
                progression = Array(64).fill(null).map((_, i) => ({ id: i, chord: null }));
            }
            
            // Validate current sequence slot
            if (currentSequenceIndex < 0 || currentSequenceIndex >= sequenceSlots.length) {
                currentSequenceIndex = 0;
            }
            
            // Update UI
            const tempoEl = document.getElementById('tempo-value');
            const barsEl = document.getElementById('bars-value');
            if (tempoEl) tempoEl.textContent = String(tempo);
            if (barsEl) barsEl.textContent = String(currentBars);
            
            buildStepGrid();
        }

        function handleClear() {
            progression = progression.map((s, i) => ({ id: i, chord: null }));
            sequenceSlots[currentSequenceIndex].progression = progression.slice();
            refreshStepSelections();
            handleStop();
        }

        function handleStepClick(stepIndex, e) {
            e.preventDefault();
            e.stopPropagation();
            const step = progression[stepIndex];
            
            // Check for SHIFT+CLICK to enter/exit duration edit mode
            if (e.shiftKey) {
                if (step && step.chord) {
                    // Deselect BPM if it's selected (only one can be selected at a time)
                    if (state.selectedControl === 'tempo') {
                        state.selectedControl = null;
                        updateControlValues();
                    }
                    
                    // Multi-selection duration edit mode
                    if (durationEditMode) {
                        // Toggle this step in the selection
                        if (durationEditSteps.has(stepIndex)) {
                            durationEditSteps.delete(stepIndex);
                            console.log(`Removed step ${stepIndex} from duration edit selection`);
                        } else {
                            durationEditSteps.add(stepIndex);
                            console.log(`Added step ${stepIndex} to duration edit selection`);
                        }
                        
                        // If no steps selected, exit duration edit mode
                        if (durationEditSteps.size === 0) {
                            durationEditMode = false;
                            durationEditStep = -1;
                            console.log(`Exiting duration edit mode - no steps selected`);
                        }
                        
                        refreshStepSelections(); // Update display
                    } else {
                        // Enter duration edit mode with this step
                        durationEditMode = true;
                        durationEditStep = stepIndex;
                        durationEditSteps.clear();
                        durationEditSteps.add(stepIndex);
                        console.log(`Entering duration edit mode for step ${stepIndex}, current duration: ${step.chord.duration || 2}`);
                        refreshStepSelections(); // Show duration number and add duration-edit class
                    }
                }
                return;
            }
            
            // If step already has a chord, just play it and do NOT overwrite
            if (step && step.chord) {
                audioEngine.stopAllVoices();
                // Convert flat notes to sharp notes for chord creation
                const rootNote = convertFlatToSharp(step.chord.root);
                const chord = createChord(rootNote, step.chord.type, step.chord.octave, step.chord.inversion);
                const slotIdx = step.chord.slotIndex ?? 0;
                const bassOverride = (step.chord.bassOffset !== undefined) ? step.chord.bassOffset : 0;
                if (chord) playChord(chord, 0.6, slotIdx, 'preview', bassOverride, step.chord.octave, step.chord.inversion);
                setTimeout(() => audioEngine.stopAllVoices(), 300);
                return;
            }

            // Only when empty: add selected/last-played chord
            const chosen = state.selectedChordForStep || (state.lastPlayedChord ? { root: state.lastPlayedChord.root, type: state.lastPlayedChord.type } : null);
            if (!chosen) return;
            const meta = state.selectedChordMeta || {};
            const chosenSlotIndex = (meta.slotIndex !== undefined) ? meta.slotIndex : (state.currentSlotLevel || 0);
            const chosenChordKey = chosen.root + '-' + chosen.type + '-' + chosenSlotIndex;
            const chosenBassOffset = (meta.bassOffset !== undefined) ? meta.bassOffset : (state.bassOffsets[chosenChordKey] || 0);
            const chosenOct = (meta.octave !== undefined) ? meta.octave : state.octave;
            const chosenInv = (meta.inversion !== undefined) ? meta.inversion : state.inversion;
            const chosenDuration = (meta.duration !== undefined) ? meta.duration : 2;
            // Generate the chord name using the current useFlats setting to preserve consistency
            const chordName = MusicEngine.getChordNameWithBass(chosen.root, chosen.type, chosenChordKey, state.bassOffsets, state.useFlats);
            
            progression[stepIndex] = {
                id: stepIndex,
                chord: { 
                    root: chosen.root, 
                    type: chosen.type, 
                    slotIndex: chosenSlotIndex, 
                    bassOffset: chosenBassOffset, 
                    octave: chosenOct, 
                    inversion: chosenInv,
                    name: chordName,
                    duration: chosenDuration // Use copied duration or default to 2 steps
                }
            };
            sequenceSlots[currentSequenceIndex].progression = progression.slice();
            refreshStepSelections();
            // Preview newly set chord quickly
            audioEngine.stopAllVoices();
            const chord = createChord(chosen.root, chosen.type, chosenOct, chosenInv);
            if (chord) {
                playChord(chord, 0.6, chosenSlotIndex, 'user', chosenBassOffset, chosenOct, chosenInv);
            }
            setTimeout(() => audioEngine.stopAllVoices(), 300);
        }

        function handleStepRelease(stepIndex, e) {
            e.preventDefault();
            e.stopPropagation();
            audioEngine.stopAllVoices();
        }

        function handleStepClear(stepIndex) {
            progression[stepIndex] = { id: stepIndex, chord: null };
            refreshStepSelections();
        }
        // Constants from original React component
        const KEYS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        // Comprehensive Modal System - All 28 Modes from 4 Scale Systems
const MODAL_SYSTEMS = {
    major: {
        name: "Major (Ionian) System",
        parentIntervals: [0, 2, 4, 5, 7, 9, 11],
        modes: [
            { id: 'IONIAN', name: 'Ionian', rotation: 0, aliases: ['Major'] },
            { id: 'DORIAN', name: 'Dorian', rotation: 1 },
            { id: 'PHRYGIAN', name: 'Phrygian', rotation: 2 },
            { id: 'LYDIAN', name: 'Lydian', rotation: 3 },
            { id: 'MIXOLYDIAN', name: 'Mixolydian', rotation: 4 },
            { id: 'AEOLIAN', name: 'Aeolian', rotation: 5, aliases: ['Natural Minor'] },
            { id: 'LOCRIAN', name: 'Locrian', rotation: 6 }
        ]
    },
    melodicMinor: {
        name: "Melodic Minor (Jazz Minor) System",
        parentIntervals: [0, 2, 3, 5, 7, 9, 11],
        modes: [
            { id: 'MELODIC_MINOR', name: 'Melodic Minor', rotation: 0, aliases: ['Jazz Minor'] },
            { id: 'DORIAN_B2', name: 'Dorian ♭2', rotation: 1, aliases: ['Phrygian ♮6'] },
            { id: 'LYDIAN_AUG', name: 'Lydian Augmented', rotation: 2, aliases: ['#4 #5'] },
            { id: 'LYDIAN_DOM', name: 'Lydian Dominant', rotation: 3, aliases: ['Lydian ♭7', 'Overtone'] },
            { id: 'MIXOLYDIAN_B6', name: 'Mixolydian ♭6', rotation: 4 },
            { id: 'LOCRIAN_NAT2', name: 'Locrian ♮2', rotation: 5, aliases: ['Half-dim ♮9'] },
            { id: 'ALTERED', name: 'Altered', rotation: 6, aliases: ['Super Locrian'] }
        ]
    },
    harmonicMinor: {
        name: "Harmonic Minor System",
        parentIntervals: [0, 2, 3, 5, 7, 8, 11],
        modes: [
            { id: 'HARMONIC_MINOR', name: 'Harmonic Minor', rotation: 0 },
            { id: 'LOCRIAN_NAT6', name: 'Locrian ♮6', rotation: 1 },
            { id: 'IONIAN_SHARP5', name: 'Ionian ♯5', rotation: 2 },
            { id: 'DORIAN_SHARP4', name: 'Dorian ♯4', rotation: 3 },
            { id: 'PHRYGIAN_DOM', name: 'Phrygian Dominant', rotation: 4 },
            { id: 'LYDIAN_SHARP2', name: 'Lydian ♯2', rotation: 5 },
            { id: 'ULTRA_LOCRIAN', name: 'Ultra-Locrian', rotation: 6 }
        ]
    },
    harmonicMajor: {
        name: "Harmonic Major System",
        parentIntervals: [0, 2, 4, 5, 7, 8, 11],
        modes: [
            { id: 'HARMONIC_MAJOR', name: 'Harmonic Major', rotation: 0 },
            { id: 'DORIAN_B5', name: 'Dorian ♭5', rotation: 1 },
            { id: 'PHRYGIAN_B4', name: 'Phrygian ♭4', rotation: 2 },
            { id: 'LYDIAN_B3', name: 'Lydian ♭3', rotation: 3 },
            { id: 'MIXOLYDIAN_B2', name: 'Mixolydian ♭2', rotation: 4 },
            { id: 'LYDIAN_AUG_SHARP2', name: 'Lydian Aug ♯2', rotation: 5 },
            { id: 'LOCRIAN_BB7', name: 'Locrian ♭♭7', rotation: 6 }
        ]
    },
};

// Flatten all modes into a single array for backward compatibility
const MODES = ['FREE'];
Object.values(MODAL_SYSTEMS).forEach(system => {
    system.modes.forEach(mode => {
        MODES.push(mode.id);
    });
});

// Mode display names mapping - ALL CAPS with split formatting for longer names
const MODE_DISPLAY_NAMES = {
    // Major system
    'IONIAN': 'IONIAN',
    'DORIAN': 'DORIAN', 
    'PHRYGIAN': 'PHRYGIAN',
    'LYDIAN': 'LYDIAN',
    'MIXOLYDIAN': 'MIXOLYDIAN',
    'AEOLIAN': 'AEOLIAN',
    'LOCRIAN': 'LOCRIAN',
    
    // Melodic Minor system
    'MELODIC_MINOR': 'MELODIC\nMINOR',
    'DORIAN_B2': 'DORIAN\n♭2',
    'LYDIAN_AUG': 'LYDIAN\nAUGMENTED',
    'LYDIAN_DOM': 'LYDIAN\nDOMINANT',
    'MIXOLYDIAN_B6': 'MIXOLYDIAN\n♭6',
    'LOCRIAN_NAT2': 'LOCRIAN\n♮2',
    'ALTERED': 'ALTERED',
    
    // Harmonic Minor system
    'HARMONIC_MINOR': 'HARMONIC\nMINOR',
    'LOCRIAN_NAT6': 'LOCRIAN\n♮6',
    'IONIAN_SHARP5': 'IONIAN\n♯5',
    'DORIAN_SHARP4': 'DORIAN\n♯4',
    'PHRYGIAN_DOM': 'PHRYGIAN\nDOMINANT',
    'LYDIAN_SHARP2': 'LYDIAN\n♯2',
    'ULTRA_LOCRIAN': 'ULTRA\nLOCRIAN',
    
    // Harmonic Major system
    'HARMONIC_MAJOR': 'HARMONIC MAJOR',
    'DORIAN_B5': 'DORIAN\n♭5',
    'PHRYGIAN_B4': 'PHRYGIAN\n♭4',
    'LYDIAN_B3': 'LYDIAN\n♭3',
    'MIXOLYDIAN_B2': 'MIXOLYDIAN\n♭2',
    'LYDIAN_AUG_SHARP2': 'LYDIAN\nAUGMENTED\n♯2',
    'LOCRIAN_BB7': 'LOCRIAN\n♭♭7',
    
};

// Diatonic chord qualities for each scale degree
const DIATONIC_CHORD_QUALITIES = {
    // Major scale degrees (7th chords)
    'IONIAN': ['major7', 'minor7', 'minor7', 'major7', '7', 'minor7', 'm7b5'],
    'DORIAN': ['minor7', 'minor7', 'major7', '7', 'minor7', 'm7b5', 'major7'],
    'PHRYGIAN': ['minor7', 'major7', '7', 'minor7', 'm7b5', 'major7', '7'],
    'LYDIAN': ['major7', '7', 'minor7', 'm7b5', 'major7', 'minor7', 'm7b5'],
    'MIXOLYDIAN': ['7', 'minor7', 'm7b5', 'major7', 'minor7', 'm7b5', 'major7'],
    'AEOLIAN': ['minor7', 'm7b5', 'major7', 'minor7', '7', 'major7', '7'],
    'LOCRIAN': ['m7b5', 'major7', '7', 'minor7', 'major7', '7', 'major7'],
    
    // Melodic Minor scale degrees
    'MELODIC_MINOR': ['minorMajor7', 'minor7', 'major7#5', '7', '7', 'm7b5', 'm7b5'],
    'DORIAN_B2': ['minor7', 'major7', '7', 'minor7', 'm7b5', 'major7', '7'],
    'LYDIAN_AUG': ['major7#5', '7', 'minor7', 'm7b5', 'major7', 'minor7', 'm7b5'],
    'LYDIAN_DOM': ['7', '7', 'm7b5', 'm7b5', 'major7', 'minor7', 'm7b5'],
    'MIXOLYDIAN_B6': ['7', 'm7b5', 'm7b5', 'major7', 'minor7', 'major7', '7'],
    'LOCRIAN_NAT2': ['m7b5', 'm7b5', 'major7', 'minor7', '7', 'major7', '7'],
    'ALTERED': ['7', 'major7', '7', 'm7b5', 'major7', '7', 'major7'],
    
    // Harmonic Minor scale degrees
    'HARMONIC_MINOR': ['minorMajor7', 'm7b5', 'major7#5', 'minor7', '7', 'major7', 'dim7'],
    'LOCRIAN_NAT6': ['m7b5', 'major7', '7', 'minor7', '7', 'major7', '7'],
    'IONIAN_SHARP5': ['major7#5', 'minor7', 'm7b5', 'major7', '7', 'm7b5', 'm7b5'],
    'DORIAN_SHARP4': ['minor7', 'minor7', 'major7', 'm7b5', 'minor7', 'm7b5', 'major7'],
    'PHRYGIAN_DOM': ['7', 'major7', 'm7b5', 'minor7', 'major7', '7', 'major7'],
    'LYDIAN_SHARP2': ['major7', 'major7', 'm7b5', 'm7b5', '7', 'minor7', 'dim7'],
    'ULTRA_LOCRIAN': ['dim7', '7', 'major7', 'm7b5', '7', 'major7', '7'],
    
    // Harmonic Major scale degrees
    'HARMONIC_MAJOR': ['major7', 'minor7', 'minor7', '7', '7', 'major7', 'dim7'],
    'DORIAN_B5': ['minor7', 'm7b5', 'major7', 'minor7', '7', 'major7', '7'],
    'PHRYGIAN_B4': ['minor7', 'major7', '7', 'minor7', 'm7b5', 'major7', '7'],
    'LYDIAN_B3': ['minorMajor7', 'minor7', 'major7', 'm7b5', '7', 'minor7', 'm7b5'],
    'MIXOLYDIAN_B2': ['7', 'major7', 'm7b5', 'major7', '7', 'minor7', 'major7'],
    'LYDIAN_AUG_SHARP2': ['major7#5', 'major7', 'm7b5', 'm7b5', 'major7', 'minor7', 'dim7'],
    'LOCRIAN_BB7': ['m7b5', 'major7', '7', 'minor7', '7', 'major7', '7'],
    
};
        const SOUNDS = ['11', '22', '33', '44', '55'];
        const SIZE_MODES = ['XL', 'XXL', 'XXXL', 'X'];
        const BASS_SEQUENCE = [-11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        const SHARP_TO_FLAT = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
        const FLAT_TO_SHARP = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };

        const CHORD_LIBRARY = {
            major: { intervals: [0, 4, 7], display: '' },
            minor: { intervals: [0, 3, 7], display: 'm' },
            dim: { intervals: [0, 3, 6], display: 'dim' },
            augmented: { intervals: [0, 4, 8], display: 'aug' },
            '5': { intervals: [0, 7], display: '5' },
            '7': { intervals: [0, 4, 7, 10], display: '7' },
            major7: { intervals: [0, 4, 7, 11], display: 'maj7' },
            M7: { intervals: [0, 4, 7, 11], display: 'M7' },
            m7: { intervals: [0, 3, 7, 10], display: 'm7' },
            minor7: { intervals: [0, 3, 7, 10], display: 'm7' },
            dim7: { intervals: [0, 3, 6, 9], display: 'dim7' },
            'm7b5': { intervals: [0, 3, 6, 10], display: 'm7b5' },
            'φ7': { intervals: [0, 3, 6, 10], display: 'φ7' },
            minorMajor7: { intervals: [0, 3, 7, 11], display: 'm(maj7)' },
            major9: { intervals: [0, 4, 7, 11, 14], display: 'maj9' },
            m9: { intervals: [0, 3, 7, 10, 14], display: 'm9' },
            minor9: { intervals: [0, 3, 7, 10, 14], display: 'm9' },
            '9': { intervals: [0, 4, 7, 10, 14], display: '9' },
            add9: { intervals: [0, 4, 7, 14], display: 'add9' },
            add2: { intervals: [0, 2, 4, 7], display: 'add2' },
            madd9: { intervals: [0, 3, 7, 14], display: 'madd9' },
            madd2: { intervals: [0, 2, 3, 7], display: 'madd2' },
            '7b9': { intervals: [0, 4, 7, 10, 13], display: '7b9' },
            '7#9': { intervals: [0, 4, 7, 10, 15], display: '7#9' },
            '7b13': { intervals: [0, 4, 7, 10, 20], display: '7b13' },
            '7#11': { intervals: [0, 4, 7, 10, 18], display: '7#11' },
            'maj7#11': { intervals: [0, 4, 7, 11, 18], display: 'maj7#11' },
            '7alt': { intervals: [0, 4, 7, 10, 13, 15, 18, 20], display: '7alt' },
            dim9: { intervals: [0, 3, 6, 9, 14], display: 'dim9' },
            aug9: { intervals: [0, 4, 8, 10, 14], display: 'aug9' },
            '11': { intervals: [0, 4, 7, 10, 14, 17], display: '11' },
            'm11': { intervals: [0, 3, 7, 10, 14, 17], display: 'm11' },
            minor11: { intervals: [0, 3, 7, 10, 14, 17], display: 'm11' },
            'm11add13': { intervals: [0, 3, 7, 10, 14, 17, 21], display: 'm11add13' },
            'm11add9': { intervals: [0, 3, 7, 10, 14, 17], display: 'm11add9' },
            major11: { intervals: [0, 4, 7, 11, 14, 17], display: 'maj11' },
            'major13': { intervals: [0, 4, 7, 11, 14, 21], display: 'maj13' },
            'm13': { intervals: [0, 3, 7, 10, 14, 21], display: 'm13' },
            minor13: { intervals: [0, 3, 7, 10, 14, 21], display: 'm13' },
            '13': { intervals: [0, 4, 7, 10, 14, 21], display: '13' },
            '13sus': { intervals: [0, 5, 7, 10, 14, 21], display: '13sus' },
            '13b9': { intervals: [0, 4, 7, 10, 13, 21], display: '13b9' },
            'm11b5': { intervals: [0, 3, 6, 10, 14, 17], display: 'm11b5' },
            sus2: { intervals: [0, 2, 7], display: 'sus2' },
            sus4: { intervals: [0, 5, 7], display: 'sus4' },
            '7sus': { intervals: [0, 5, 7, 10], display: '7sus' },
            '7sus4': { intervals: [0, 5, 7, 10], display: '7sus4' },
            '9sus': { intervals: [0, 5, 7, 10, 14], display: '9sus' },
            '7sus2': { intervals: [0, 2, 7, 10], display: '7sus2' },
            '7sus2b9': { intervals: [0, 2, 7, 10, 13], display: '7sus2b9' },
            '6': { intervals: [0, 4, 7, 9], display: '6' },
            m6: { intervals: [0, 3, 7, 9], display: 'm6' },
            minor6: { intervals: [0, 3, 7, 9], display: 'm6' },
            '69': { intervals: [0, 4, 7, 9, 14], display: '6/9' },
            'm69': { intervals: [0, 3, 7, 9, 14], display: 'm6/9' },
            'sus2 add13': { intervals: [0, 2, 7, 21], display: 'sus2 add13' },
            'sus2 add13 no5': { intervals: [0, 2, 21], display: 'sus2 add13 no5' },
            'sus2 add11': { intervals: [0, 2, 7, 17], display: 'sus2 add11' },
            '7 add11 no5': { intervals: [0, 4, 10, 17], display: '7 add11 no5' },
            '7 no5': { intervals: [0, 4, 10], display: '7 no5' },
            'maj7 no3': { intervals: [0, 7, 11], display: 'maj7 no3' },
            'add11': { intervals: [0, 4, 7, 17], display: 'add11' },
            'major7#5': { intervals: [0, 4, 8, 11], display: 'maj7#5' },
            'aug7': { intervals: [0, 4, 8, 11], display: 'aug7' }
        };

        // Common shorthand aliases mapping to CHORD_LIBRARY keys
        const CHORD_ALIASES = {
            'maj7': 'major7',
            'M7': 'major7',
            'Maj7': 'major7',
            'maj': 'major',
            'Maj': 'major',
            'aug7': 'major7#5',
            'augmaj7': 'major7#5',
            'augmented7': 'major7#5',
            'maj7#5': 'major7#5',
            'M7#5': 'major7#5',
            'maj7+5': 'major7#5',
            'M7+5': 'major7#5',
            'm': 'minor',
            'min': 'minor',
            'min7': 'm7',
            'min9': 'm9',
            'min11': 'm11',
            'min13': 'm13',
            'min6': 'm6',
            'min69': 'm69',
            'minmaj7': 'minorMajor7',
            'm7': 'm7',
            'maj9': 'major9',
            'm9': 'm9',
            'maj11': 'major11',
            'maj13': 'major13',
            'm11': 'm11',
            'm13': 'm13',
            'aug': 'augmented',
            'dim': 'dim',
            'ø7': 'm7b5',
            'halfdim': 'm7b5',
            'half-diminished': 'm7b5',
            '7sus': '7sus',
            '7sus2': '7sus2',
            '7sus4': '7sus4',
            'sus4': 'sus4',
            'sus2': 'sus2',
            'm6': 'minor6',
            '6/9': '69',
            '6-9': '69',
            'm6/9': 'm69',
            'sus2add13': 'sus2 add13',
            'sus2add13no5': 'sus2 add13 no5',
            'sus2add11': 'sus2 add11',
            '7add11no5': '7 add11 no5',
            '7no5': '7 no5',
            'maj7no3': 'maj7 no3',
            'maj7#11': 'maj7#11',
            'M9': 'major9',
            'M11': 'major11',
            'M13': 'major13',
            'M7': 'major7',
            'minadd9': 'madd9',
            'minadd2': 'madd2'
        };

        // Fixed ordering to match legacy app so imported palette indices map correctly
        const ALL_CHORD_TYPES = [
            'major', 'minor', 'dim', 'augmented', '5',
            'major7', 'm7', '7', 'dim7', 'm7b5', 'φ7', 'minorMajor7', 'aug7',
            'major9', 'm9', '9', 'add9', 'add2', 'madd9', 'madd2', '7b9', '7#9', '7b13', '7#11', 'maj7#11', '7alt', 'dim9', 'aug9',
            '11', 'm11', 'm11add13', 'm11add9', 'major11', 'major13', 'm13', '13', '13sus', '13b9', 'm11b5',
            'sus2', 'sus4', '7sus', '7sus4', '9sus', '7sus2', '7sus2b9',
            '6', 'm6', '69', 'm69',
            'sus2 add13', 'sus2 add13 no5', 'sus2 add11', '7 add11 no5', '7 no5', 'maj7 no3', 'add11'
        ];

        // Global state
        let state = {
            selectedKey: 'C',
            mode: 'FREE',
            octave: 0,
            inversion: -2,
            selectedSound: '11',
            selectedControl: null,
            currentChord: null,
            chordIndices: {},
            slotChordIndices: {},
            lastPressed: null,
            activeKeys: new Set(),
            activeSlots: new Set(),
            lastActiveSlot: null,
            bassOffsets: {},
            bassOffset: 'BASS',
            lastPlayedChord: null,
            // Persist user-selected chord for writing steps even during playback
            selectedChordForStep: null,
            selectedChordMeta: null,
            disabledKeys: new Set(),
            disabledSlots: new Set(),
            useFlats: false,
            midiEnabled: false,
            sustainPedal: false,
            backgroundImage: null,
            sizeMode: 'XL',
            bassEditTarget: null,
            currentSlotLevel: 0,
            filterCutoff: 10,
            globalTranspose: 0,
            // Save/Load removed
            savedPalettes: {},
            longPressExecuted: false,
            xlCycleStart: false,
            // 1.0 = chords full, 0.0 = bass full; default one step under middle (0.32)
            faderBlend: 0.32
            ,
            // Per-slot voicing locks: note-slotIndex → { octave, inversion }
            slotVoicingLocks: {},
            // Sequence loop for continuous playback
            sequenceLoop: null,
            currentLoopIndex: 0,
            // Scale degree display toggle
            showScaleDegrees: false,
            // Effects mode toggle
            effectsMode: true,
            reverbLevel: 1, // Default to 1 for subtle reverb on startup
            delayLevel: 0,
            // Flag to prevent click from de-selecting after long-press toggle
            longPressToggleExecuted: false,
            // === FLAM FEATURE ===
            flamMode: 'off', // 'off', 'slow', 'mid', 'fast'
            flamTiming: { slow: 90, mid: 50, fast: 30 }, // milliseconds between notes
            currentFlamTimeouts: [],
            
            // === RECORDING FEATURE ===
            isRecording: false,
            recordingStartTime: null,
            recordingDuration: 0,
            recordingTimer: null,
            recordingData: [],
            recordingState: 'idle', // 'idle', 'recording', 'prompt', 'naming', 'exporting'
            mediaRecorder: null,
            cancelledNotes: new Set()
        };

        // --- Scale Degree Functions ---
        
        // Chromatic degree mapping (0-11 semitones from tonic)
        const DEGREE_LABELS = [
            "1", "♭ 2", "2", "♭ 3", "3", "4", "♭ 5", "5", "♭ 6", "6", "♭ 7", "7"
        ];
        

        
        // Get chromatic distance from tonic (0-11 semitones)
        function getChromaticDistance(note, tonic) {
            const noteIndex = KEYS.indexOf(note);
            const tonicIndex = KEYS.indexOf(tonic);
            if (noteIndex === -1 || tonicIndex === -1) return null;
            return ((noteIndex - tonicIndex + 12) % 12);
        }
        
        // Get base degree label from chromatic distance
        function getBaseDegreeLabel(distance) {
            if (distance === null || distance < 0 || distance > 11) return null;
            return DEGREE_LABELS[distance];
        }
        
        // Get mode-aware degree label with smart enharmonic choices
        function getModeAwareDegreeLabel(note, tonic, mode) {
            const distance = getChromaticDistance(note, tonic);
            if (distance === null) return null;
            
            const baseLabel = getBaseDegreeLabel(distance);
            if (!baseLabel) return null;
            
            // Mode-specific enhancements
            if (mode === 'LYDIAN' && distance === 6) {
                return '# 4'; // Prefer #4 over ♭5 in Lydian
            }
            if (mode === 'PHRYGIAN' && distance === 1) {
                return '♭ 2'; // Prefer ♭2 over #1 in Phrygian
            }
            if (mode === 'HARMONIC_MINOR' && distance === 6) {
                return '♭ 6'; // Prefer ♭6 over #5 in Harmonic Minor
            }
            
            return baseLabel;
        }
        
        function getScaleDegree(key, mode) {
            if (mode === 'FREE') return null;
            
            const systemInfo = MusicEngine.getSystemForMode(mode);
            if (!systemInfo) return null;
            
            // Get scale notes for the CURRENT SELECTED KEY, not the note being displayed
            const scaleNotes = MusicEngine.getScaleNotes(state.selectedKey, mode);
            if (!scaleNotes || scaleNotes.length === 0) return null;
            
            // Find the position of this key in the scale (1-7)
            const degree = scaleNotes.indexOf(key) + 1;
            return degree >= 1 && degree <= 7 ? degree : null;
        }
        
        // Enhanced scale degree display text with chromatic mapping
        function getScaleDegreeText(key, mode) {
            if (mode === 'FREE') return null;
            
            // Use chromatic degree mapping for more accurate labels
            const chromaticLabel = getModeAwareDegreeLabel(key, state.selectedKey, mode);
            if (chromaticLabel) {
                return chromaticLabel;
            }
            
            // Fallback to traditional scale degree (1-7)
            const degree = getScaleDegree(key, mode);
            if (!degree) return null;
            
            return String(degree);
        }
        
        // Update mode badge display above piano keys
        function updateModeBadge() {
            if (state.mode === 'FREE') {
                // Hide mode badge in FREE mode
                const existingBadge = document.getElementById('mode-badge');
                if (existingBadge) {
                    existingBadge.remove();
                }
                return;
            }
            
            // Get mode template for display
            const modeKey = state.mode.toUpperCase();
            const template = MODE_TEMPLATES[modeKey];
            
            if (!template) {
                // Hide mode badge if no template found
                const existingBadge = document.getElementById('mode-badge');
                if (existingBadge) {
                    existingBadge.remove();
                }
                return;
            }
            
            // Create or update mode badge
            let modeBadge = document.getElementById('mode-badge');
            if (!modeBadge) {
                modeBadge = document.createElement('div');
                modeBadge.id = 'mode-badge';
                modeBadge.style.cssText = `
                    position: absolute;
                    top: -30px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 14px;
                    font-weight: 500;
                    z-index: 1000;
                    border: 1px solid #555;
                `;
                
                // Insert before piano section
                const pianoSection = document.getElementById('piano-section');
                pianoSection.parentNode.insertBefore(modeBadge, pianoSection);
            }
            
            // Update mode badge content
            const modeName = state.mode.charAt(0).toUpperCase() + state.mode.slice(1).toLowerCase();
            const templateText = template.map(deg => typeof deg === 'string' ? deg : deg.toString()).join(' ');
            modeBadge.innerHTML = `${modeName}: ${templateText}`;
        }
        
        // --- Note conversion helpers ---
        function convertFlatToSharp(note) {
            if (!note) return note;
            return FLAT_TO_SHARP[note] || note;
        }
        
        // --- Chord name parsing ---
        function parseChordName(chordName) {
            if (!chordName) return { root: 'C', type: 'major' };
            
            const name = chordName.toString().trim();
            
            // Handle special cases first
            if (name === 'G13') return { root: 'G', type: '13' };
            if (name === 'G13sus') return { root: 'G', type: '13sus' };
            
            // Extract root note (first character or first two characters for sharps/flats)
            let root = name.charAt(0);
            let typeStart = 1;
            
            // Handle sharps and flats
            if (name.length > 1 && (name.charAt(1) === '#' || name.charAt(1) === 'b')) {
                root = name.substring(0, 2);
                typeStart = 2;
            }
            
            // Extract chord type (everything after the root)
            const chordType = name.substring(typeStart);
            
            // Convert common chord type abbreviations
            let finalType = chordType;
            if (chordType === 'maj' || chordType === 'major') finalType = 'major';
            else if (chordType === 'm' || chordType === 'min') finalType = 'minor';
            else if (chordType === 'maj7') finalType = 'major7';
            else if (chordType === 'm7') finalType = 'm7';
            else if (chordType === 'maj9') finalType = 'major9';
            else if (chordType === 'm9') finalType = 'm9';
            else if (chordType === 'maj11') finalType = 'major11';
            else if (chordType === 'm11') finalType = 'm11';
            else if (chordType === 'maj13') finalType = 'major13';
            else if (chordType === 'm13') finalType = 'm13';
            
            return { root, type: finalType };
        }

        // --- Sequence command handling ---
        function handleSequenceCommand(input) {
            const command = input.toUpperCase().trim();
            
            // Single sequence: SEQ2
            if (/^SEQ\s*\d+$/.test(command)) {
                const seqNum = parseInt(command.match(/\d+/)[0]) - 1;
                if (seqNum >= 0 && seqNum < sequenceSlots.length) {
                    if (isPlaying) {
                        pendingSequenceIndex = seqNum;
                        console.log(`Sequence ${seqNum + 1} will play next`);
                        showSequencerMessage(`SEQ ${seqNum + 1} NEXT`, 'info');
                    } else {
                        currentSequenceIndex = seqNum;
                        loadSequence(seqNum);
                        console.log(`Switched to sequence ${seqNum + 1}`);
                    }
                }
                return;
            }
            
            // Sequence loop: SEQ 1,2,3 or SEQ 1-3 or SEQ 1-8
            if (/^SEQ\s*[\d,\-\s]+$/.test(command)) {
                let seqLoop = [];
                
                // Handle range notation (e.g., "SEQ 1-8")
                const rangeMatch = command.match(/SEQ\s*(\d+)\s*-\s*(\d+)/);
                if (rangeMatch) {
                    const start = parseInt(rangeMatch[1]);
                    const end = parseInt(rangeMatch[2]);
                    if (start <= end && start >= 1 && end <= 8) {
                        for (let i = start; i <= end; i++) {
                            seqLoop.push(i - 1); // Convert to 0-based index
                        }
                    }
                } else {
                    // Handle comma-separated list (e.g., "SEQ 1,2,3,4,5,6,7,8")
                    const numbers = command.match(/\d+/g);
                    if (numbers && numbers.length > 0) {
                        seqLoop = numbers.map(n => parseInt(n) - 1).filter(n => n >= 0 && n < sequenceSlots.length);
                    }
                }
                
                if (seqLoop.length > 0) {
                    // Store the sequence loop for continuous playback
                    state.sequenceLoop = seqLoop;
                    state.currentLoopIndex = 0;
                    if (isPlaying) {
                        pendingSequenceIndex = seqLoop[0];
                        console.log(`Sequence loop ${seqLoop.map(i => i + 1).join(',')} will start next`);
                        showSequencerMessage(`LOOPING SEQ ${seqLoop.map(i => i + 1).join(',')}`, 'loop');
                    } else {
                        currentSequenceIndex = seqLoop[0];
                        loadSequence(seqLoop[0]);
                        console.log(`Started sequence loop ${seqLoop.map(i => i + 1).join(',')}`);
                    }
                    updateSequenceLoopStatus();
                }
                return;
            }
            
            console.log('Invalid sequence command. Use: SEQ2, SEQ 1,2,3, or SEQ 1-3');
        }

        // --- Load sequence helper ---
        function loadSequence(seqIndex) {
            const slot = sequenceSlots[seqIndex];
            if (slot) {
                currentSequenceIndex = seqIndex;
                currentBars = Math.max(1, Math.min(8, slot.bars || 2));
                currentTimeSignature = slot.timeSignature || "4/4";
                currentBeatsPerBar = slot.beatsPerBar || 8;
                tempo = Math.max(60, Math.min(300, slot.tempo || 120));
                progression = Array.isArray(slot.progression) ? slot.progression.slice() : Array(64).fill(null).map((_, i) => ({ id: i, chord: null }));
                
                // Detect note naming convention used in the sequence and adjust useFlats accordingly
                if (Array.isArray(slot.progression)) {
                    const hasFlatNotes = slot.progression.some(step => 
                        step && step.chord && step.chord.root && 
                        (step.chord.root.includes('b') || step.chord.root.includes('Bb') || step.chord.root.includes('Eb') || step.chord.root.includes('Ab') || step.chord.root.includes('Db') || step.chord.root.includes('Gb'))
                    );
                    const hasSharpNotes = slot.progression.some(step => 
                        step && step.chord && step.chord.root && 
                        (step.chord.root.includes('#') || step.chord.root.includes('C#') || step.chord.root.includes('D#') || step.chord.root.includes('F#') || step.chord.root.includes('G#') || step.chord.root.includes('A#'))
                    );
                    
                    // If sequence has flat notes but no sharp notes, use flats
                    if (hasFlatNotes && !hasSharpNotes) {
                        state.useFlats = true;
                    }
                    // If sequence has sharp notes but no flat notes, use sharps
                    else if (hasSharpNotes && !hasFlatNotes) {
                        state.useFlats = false;
                    }
                    // Otherwise keep current setting
                }
                
                // Update UI
                const tempoEl = document.getElementById('tempo-value');
                const barsEl = document.getElementById('bars-value');
                const timeSigEl = document.getElementById('time-signature-label');
                const seqEl = document.querySelector('#seq-btn .seq-value');
                if (tempoEl) tempoEl.textContent = String(tempo);
                if (barsEl) barsEl.textContent = String(currentBars);
                if (timeSigEl) timeSigEl.textContent = currentTimeSignature;
                if (seqEl) seqEl.textContent = String(seqIndex + 1);
                
                buildStepGrid();
            }
        }

        // --- Show sequencer message ---
        function showSequencerMessage(message, type = 'info') {
            const statusEl = document.getElementById('status-text');
            if (!statusEl) return;
            
            // Remove existing classes
            statusEl.classList.remove('looping', 'copied', 'info');
            
            // Add appropriate class based on message type
            if (type === 'loop' || message.includes('LOOP')) {
                statusEl.classList.add('looping');
            } else if (type === 'copied' || message.includes('COPIED')) {
                statusEl.classList.add('copied');
            } else {
                statusEl.classList.add('info');
            }
            
            // Update the message
            statusEl.textContent = message;
            
            // Auto-clear certain message types after a delay
            if (type === 'copied' || type === 'info') {
                setTimeout(() => {
                    if (statusEl.textContent === message) {
                        // Only clear if it's still the same message
                        statusEl.textContent = '';
                        statusEl.classList.remove('looping', 'copied', 'info');
                    }
                }, 3000);
            }
        }

        // --- Update sequence loop status ---
        function updateSequenceLoopStatus() {
            if (state.sequenceLoop && state.sequenceLoop.length > 0) {
                const loopText = `LOOPING SEQ ${state.sequenceLoop.map(i => i + 1).join(',')}`;
                showSequencerMessage(loopText, 'loop');
            } else {
                // Clear loop status if no loop is active
                const statusEl = document.getElementById('status-text');
                if (statusEl && statusEl.classList.contains('looping')) {
                    statusEl.textContent = '';
                    statusEl.classList.remove('looping');
                }
            }
        }

        // --- Custom chord type conversion ---
        function convertCustomChordType(chordName) {
            if (!chordName) return 'major';
            
            const name = chordName.toLowerCase();
            
            // Most specific chord types first (order matters!)
            if (name.includes('maj7') || name.includes('maj7')) return 'major7';
            if (name.includes('maj9') || name.includes('maj9')) return 'major9';
            if (name.includes('maj11') || name.includes('maj11')) return 'major11';
            if (name.includes('maj13') || name.includes('maj13')) return 'major13';
            if (name.includes('m7') || name.includes('min7')) return 'm7';
            if (name.includes('m9') || name.includes('min9')) return 'm9';
            if (name.includes('m11add13')) return 'm11add13';
            if (name.includes('m11add9')) return 'm11add9';
            if (name.includes('m11') || name.includes('min11')) return 'm11';
            if (name.includes('m13') || name.includes('min13')) return 'm13';
            if (name.includes('m6') || name.includes('min6')) return 'm6';
            if (name.includes('m69') || name.includes('min69')) return 'm69';
            
            // Complex chord types
            if (name.includes('7b13')) return '7b13';
            if (name.includes('7#11')) return '7#11';
            if (name.includes('7alt')) return '7alt';
            if (name.includes('7b9')) return '7b9';
            if (name.includes('7#9')) return '7#9';
            if (name.includes('13sus')) return '13sus';
            if (name.includes('7sus')) return '7sus';
            if (name.includes('9sus')) return '9sus';
            if (name.includes('7sus4')) return '7sus4';
            if (name.includes('7sus2b9')) return '7sus2b9';
            if (name.includes('sus4')) return 'sus4';
            if (name.includes('sus2')) return 'sus2';
            if (name.includes('add9')) return 'add9';
            if (name.includes('add2')) return 'add2';
            if (name.includes('madd9')) return 'madd9';
            if (name.includes('madd2')) return 'madd2';
            if (name.includes('add13')) return 'add13';
            if (name.includes('13b9')) return '13b9';
            if (name.includes('m11b5')) return 'm11b5';
            if (name.includes('ø7') || name.includes('halfdim')) return 'm7b5';
            if (name.includes('φ7')) return 'φ7';
            if (name.includes('6/9') || name.includes('69')) return '69';
            if (name.includes('m6/9') || name.includes('m69')) return 'm69';
            if (name.includes('dim')) return 'dim';
            if (name.includes('aug')) return 'augmented';
            
            // Basic chord types (check these last to avoid false matches)
            if (name.includes('maj') || name.includes('major')) return 'major';
            if (name.includes('m') || name.includes('min')) return 'minor';
            if (name.includes('7')) return '7';
            if (name.includes('9')) return '9';
            if (name.includes('11')) return '11';
            if (name.includes('13')) return '13';
            if (name.includes('6')) return '6';
            if (name.includes('5')) return '5';
            
            // Default fallback
            return 'major';
        }
        
        // --- Save/Load helpers ---
        function serializeSong(name) {
            const song = {
                meta: { id: crypto?.randomUUID?.() || String(Date.now()), name, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), appVersion: '1.0' },
                settings: {
                    selectedKey: state.selectedKey, mode: state.mode, octave: state.octave, inversion: state.inversion, useFlats: state.useFlats,
                    filterCutoff: state.filterCutoff, globalTranspose: state.globalTranspose, sizeMode: state.sizeMode,
                    flamMode: state.flamMode, flamTiming: state.flamTiming
                },
                palette: {
                    chordIndices: state.chordIndices, slotChordIndices: state.slotChordIndices, bassOffsets: state.bassOffsets,
                    disabledKeys: Array.from(state.disabledKeys), disabledSlots: Array.from(state.disabledSlots)
                },
                sequences: sequenceSlots.map(s => ({ tempo: s.tempo, bars: s.bars, timeSignature: s.timeSignature, beatsPerBar: s.beatsPerBar, progression: s.progression })),
                ui: { clickEnabled }
            };
            
            // Debug logging for FLAM settings export
            console.log('Exported FLAM settings:', { flamMode: song.settings.flamMode, flamTiming: song.settings.flamTiming });
            
            return song;
        }
        function applySettings(s){
            state.selectedKey = s.selectedKey ?? state.selectedKey;
            state.mode = s.mode ?? state.mode;
            state.octave = s.octave ?? state.octave;
            state.inversion = s.inversion ?? state.inversion;
            state.useFlats = !!s.useFlats;
            state.filterCutoff = s.filterCutoff ?? state.filterCutoff; audioEngine.setFilterCutoff(state.filterCutoff);
            state.globalTranspose = s.globalTranspose ?? state.globalTranspose;
            state.sizeMode = s.sizeMode ?? state.sizeMode;
            state.flamMode = s.flamMode ?? state.flamMode;
            state.flamTiming = s.flamTiming ?? state.flamTiming;
            
            // Debug logging for FLAM settings
            console.log('Applied FLAM settings:', { flamMode: state.flamMode, flamTiming: state.flamTiming });
        }
        function loadSong(song){
            handleStop();
            if (song.settings) applySettings(song.settings);
            if (song.palette){
                state.chordIndices = song.palette.chordIndices || {};
                state.slotChordIndices = song.palette.slotChordIndices || {};
                state.bassOffsets = song.palette.bassOffsets || {};
                state.disabledKeys = new Set(song.palette.disabledKeys || []);
                state.disabledSlots = new Set(song.palette.disabledSlots || []);
            }
            if (Array.isArray(song.sequences) && song.sequences.length > 0){
                // Load sequences up to the available slots (8 total)
                const maxSequences = Math.min(song.sequences.length, sequenceSlots.length);
                song.sequences.forEach((sq, i) => {
                    if (i < maxSequences) {
                        sequenceSlots[i].tempo = sq.tempo ?? 85;
                        sequenceSlots[i].bars = sq.bars ?? 2;
                        sequenceSlots[i].timeSignature = sq.timeSignature ?? "4/4";
                        sequenceSlots[i].beatsPerBar = sq.beatsPerBar ?? 8;
                        
                        // Convert custom chord types to actual chord types and flat notes to sharp notes
                        const convertedProgression = Array.isArray(sq.progression) ? sq.progression.map(step => {
                            if (step && step.chord && step.chord.type === 'custom') {
                                const parsedChord = parseChordName(step.chord.name);
                                return {
                                    ...step,
                                    chord: {
                                        ...step.chord,
                                        root: convertFlatToSharp(parsedChord.root),
                                        type: parsedChord.type
                                    }
                                };
                            } else if (step && step.chord) {
                                // Convert flat notes to sharp notes for all chords
                                return {
                                    ...step,
                                    chord: {
                                        ...step.chord,
                                        root: convertFlatToSharp(step.chord.root)
                                    }
                                };
                            }
                            return step;
                        }) : sequenceSlots[i].progression;
                        
                        sequenceSlots[i].progression = convertedProgression;
                    }
                });
                // apply active slot 0
                currentSequenceIndex = 0;
                const s0 = sequenceSlots[0]; 
                tempo = s0.tempo || 85; 
                currentBars = s0.bars || 2; 
                currentTimeSignature = s0.timeSignature || "4/4";
                currentBeatsPerBar = s0.beatsPerBar || 8;
                
                // Convert custom chord types in the current progression too and flat notes to sharp notes
                progression = s0.progression.map(step => {
                    if (step && step.chord && step.chord.type === 'custom') {
                        const parsedChord = parseChordName(step.chord.name);
                        return {
                            ...step,
                            chord: {
                                ...step.chord,
                                root: convertFlatToSharp(parsedChord.root),
                                type: parsedChord.type
                            }
                        };
                    } else if (step && step.chord) {
                        // Convert flat notes to sharp notes for all chords
                        return {
                            ...step,
                            chord: {
                                ...step.chord,
                                root: convertFlatToSharp(step.chord.root)
                            }
                        };
                    }
                    return step;
                });
                document.getElementById('tempo-value').textContent = String(tempo);
                document.getElementById('bars-value').textContent = String(currentBars);
                const seqBtn = document.getElementById('seq-btn'); const v = seqBtn?.querySelector('.seq-value'); if (v) v.textContent = '1';
                buildStepGrid(); refreshStepSelections?.();
            }
            if (song.ui && typeof song.ui.clickEnabled === 'boolean') clickEnabled = song.ui.clickEnabled;
            updateUI();
        }
        const SONGS_KEY = 'pianoXL:songs';

        async function getAllSongs() {
            if (!currentUser) {
                try {
                    return JSON.parse(localStorage.getItem(SONGS_KEY) || '{}');
                } catch {
                    return {};
                }
            }

            try {
                const { data, error } = await supabase
                    .from('saved_songs')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .order('created_at', { ascending: false });

                if (error) throw error;

                const songMap = {};
                (data || []).forEach(row => {
                    songMap[row.title] = {
                        meta: { name: row.title },
                        ...(row.chord_data || {}),
                        settings: row.settings || {},
                        _id: row.id
                    };
                });
                return songMap;
            } catch (error) {
                console.error('Error fetching songs:', error);
                return {};
            }
        }

        async function persistSong(song) {
            if (!currentUser) {
                const map = await getAllSongs();
                map[song.meta.name] = song;
                localStorage.setItem(SONGS_KEY, JSON.stringify(map));
                return;
            }

            try {
                const existingMap = await getAllSongs();
                const existingSong = existingMap[song.meta.name];

                const songData = {
                    user_id: currentUser.id,
                    title: song.meta.name,
                    chord_data: {
                        sequences: song.sequences,
                        palette: song.palette,
                        ui: song.ui
                    },
                    settings: song.settings || {}
                };

                if (existingSong && existingSong._id) {
                    const { error } = await supabase
                        .from('saved_songs')
                        .update(songData)
                        .eq('id', existingSong._id);

                    if (error) throw error;
                } else {
                    const { error } = await supabase
                        .from('saved_songs')
                        .insert([songData]);

                    if (error) throw error;
                }
            } catch (error) {
                console.error('Error saving song:', error);
                throw error;
            }
        }

        async function deleteSong(name) {
            if (!currentUser) {
                const map = await getAllSongs();
                delete map[name];
                localStorage.setItem(SONGS_KEY, JSON.stringify(map));
                return;
            }

            try {
                const map = await getAllSongs();
                const song = map[name];
                if (!song || !song._id) return;

                const { error } = await supabase
                    .from('saved_songs')
                    .delete()
                    .eq('id', song._id);

                if (error) throw error;
            } catch (error) {
                console.error('Error deleting song:', error);
                throw error;
            }
        }

        async function renameSong(oldName, newName) {
            if (!currentUser) {
                const map = await getAllSongs();
                if (!map[oldName]) return;
                map[newName] = map[oldName];
                map[newName].meta.name = newName;
                delete map[oldName];
                localStorage.setItem(SONGS_KEY, JSON.stringify(map));
                return;
            }

            try {
                const map = await getAllSongs();
                const song = map[oldName];
                if (!song || !song._id) return;

                const { error } = await supabase
                    .from('saved_songs')
                    .update({ title: newName })
                    .eq('id', song._id);

                if (error) throw error;
            } catch (error) {
                console.error('Error renaming song:', error);
                throw error;
            }
        }

        // --- MIDI export (simple SMF Type 0) ---
        function exportSequenceToMIDI(seqIndex){
            const seq = sequenceSlots[seqIndex]; if (!seq) return;
            const ppq = 480;
            const tempoBPM = Math.max(60, Math.min(180, seq.tempo || 85));
            const microPerQuarter = Math.round(60000000 / tempoBPM);
            function varNum(n){ const bytes=[]; let val=n>>>0; do{ let b = val & 0x7F; val >>>= 7; if (bytes.length) b |= 0x80; bytes.unshift(b); } while(val>0); return Uint8Array.from(bytes); }
            function clampNote(n){ return Math.max(0, Math.min(127, n)); }
            const stepTicks = ppq/2; // 8th notes
            // Default chord duration (will be overridden by individual chord durations)
            const defaultChordDur = stepTicks*2; // half bar

            // Build absolute-tick event list
            const absEvents = [];
            // Meta tempo at tick 0
            absEvents.push({ tick: 0, data: [0xFF,0x51,0x03,(microPerQuarter>>16)&255,(microPerQuarter>>8)&255,(microPerQuarter)&255] });

            const prog = seq.progression || [];
            prog.forEach((step, i) => {
                if (!step || !step.chord) return;
                // Convert flat notes to sharp notes for chord creation
                const rootNote = convertFlatToSharp(step.chord.root);
                const chord = createChord(rootNote, step.chord.type);
                if (!chord || !Array.isArray(chord.notes)) return;
                const stepTick = i * stepTicks;
                const onVel = 96, bassVel = 100;
                const notes = chord.notes.map(n => clampNote(n + state.globalTranspose));
                // On events for chord
                notes.forEach(n => absEvents.push({ tick: stepTick, data: [0x90, n, onVel] }));
                // Bass
                const rootIndex = KEYS.indexOf(chord.root);
                const originalRoot = 60 + (state.octave * 12) + rootIndex + state.globalTranspose;
                const bassNote = clampNote(MusicEngine.getBassNote(originalRoot, 0, chord.type));
                absEvents.push({ tick: stepTick, data: [0x90, bassNote, bassVel] });
                // Off events after duration
                const chordDuration = step.chord.duration || 2; // Use chord duration or default to 2
                const chordDurTicks = stepTicks * chordDuration;
                const offTick = stepTick + chordDurTicks;
                console.log(`MIDI export: step ${i}, chord duration: ${chordDuration}, ticks: ${chordDurTicks}, off tick: ${offTick}`);
                notes.forEach(n => absEvents.push({ tick: offTick, data: [0x80, n, 0] }));
                absEvents.push({ tick: offTick, data: [0x80, bassNote, 0] });
            });

            // Sort by time; at same tick, send Note Off (0x80) before Note On (0x90)
            absEvents.sort((a,b)=> a.tick - b.tick || (a.data[0]===0x80?-1:1) - (b.data[0]===0x80?-1:1));

            // Convert to delta times
            let lastTick = 0; const trackBytes = [];
            absEvents.forEach(ev => {
                const delta = ev.tick - lastTick; lastTick = ev.tick;
                const d = varNum(delta);
                for (let i=0;i<d.length;i++) trackBytes.push(d[i]);
                ev.data.forEach(x=>trackBytes.push(x));
            });
            // End of track
            trackBytes.push(0x00, 0xFF, 0x2F, 0x00);

            // Assemble file
            function uint32(n){ return Uint8Array.from([(n>>>24)&255,(n>>>16)&255,(n>>>8)&255,(n)&255]); }
            const header = new Uint8Array([0x4D,0x54,0x68,0x64, 0x00,0x00,0x00,0x06, 0x00,0x00, 0x00,0x01, (ppq>>8)&255, ppq&255]);
            const trackData = Uint8Array.from(trackBytes);
            const trkHdr = new Uint8Array([0x4D,0x54,0x72,0x6B, ...uint32(trackData.length)]);
            const blob = new Blob([header, trkHdr, trackData], { type: 'audio/midi' });
            const a = document.createElement('a');
            const songName = (document.getElementById('song-name').value || 'Song');
            a.href = URL.createObjectURL(blob);
            a.download = `${songName}-seq${seqIndex+1}.mid`;
            a.click(); URL.revokeObjectURL(a.href);
        }

        // (Shuffle feature removed)
            const NOTE_TO_INT = {"C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11};
            const INT_TO_NOTE = Object.keys(NOTE_TO_INT).sort((a,b)=>NOTE_TO_INT[a]-NOTE_TO_INT[b]);
            function nearestSignedOffset(root, bass){
                const d = (NOTE_TO_INT[bass] - NOTE_TO_INT[root] + 12) % 12;
                return d > 6 ? d - 12 : d;
            }
            function shortType(t){ const map = {"minor7":"m7","minor9":"m9","m11":"m11","major7":"maj7"}; return map[t] ?? t; }
            function defaultSlotIndex(type, overrides){ const base = {"minor7":3,"minor9":3,"m11":1}; return (overrides&&overrides[type]!==undefined)?overrides[type]:(base[type]??3); }
            function rng(seed){ let x = seed||1; return ()=>{ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/0xFFFFFFFF; }; }
            function majorScale(tonic){ return [0,2,4,5,7,9,11].map(n=>INT_TO_NOTE[(NOTE_TO_INT[tonic]+n)%12]); }
            function minorScale(tonic){ return [0,2,3,5,7,8,10].map(n=>INT_TO_NOTE[(NOTE_TO_INT[tonic]+n)%12]); }
            function scaleDegree(root, scale){ return scale.indexOf(root); }
            function detectKey(chords){
                const majors = INT_TO_NOTE, minors = INT_TO_NOTE; let best={key:"C", mode:"major", score:-1e9};
                for (const mode of ["major","minor"]) {
                    for (const tonic of (mode==="major"?majors:minors)) {
                        let s=0; for (const c of chords){ const scale = mode==="major"?majorScale(tonic):minorScale(tonic); const deg = scaleDegree(c.root, scale); if (deg>=0) s+=2; if (/7|9|11|13/.test(c.type)) s+=1; if (c.type.includes("minor") && mode==="minor") s+=1; }
                        if (s>best.score) best={key:tonic, mode, score:s};
                    }
                }
                return { tonic: best.key, mode: best.mode };
            }
            function functionalLabel(root, mode, tonic){ const deg = scaleDegree(root, mode==="major"?majorScale(tonic):minorScale(tonic)); if (deg===-1) return "X"; if (mode==="major"){ if (deg===0||deg===5) return "T"; if (deg===1||deg===3) return "PD"; if (deg===4) return "D"; if (deg===2) return "T"; if (deg===6) return "D"; } else { if (deg===0||deg===2||deg===5) return "T"; if (deg===3) return "PD"; if (deg===4) return "D"; if (deg===1) return "PD"; if (deg===6) return "D"; } return "X"; }
            function commonTonesScore(a,b){ let s=0; if ((/minor/.test(a.type)&&/minor/.test(b.type)) || (a.type===b.type)) s+=1; if (a.root===b.root) s+=1; const m3=(NOTE_TO_INT[a.root]+3)%12; if ( NOTE_TO_INT[b.root]===m3 ) s+=0.5; return s; }
            function fifthsScore(a,b){ const downFifth=(NOTE_TO_INT[a.root]+7)%12; return NOTE_TO_INT[b.root]===downFifth ? 1 : 0.3 * (Math.abs(NOTE_TO_INT[b.root]-NOTE_TO_INT[a.root])<=2 ? 1 : 0); }
            function bassDistanceScore(a,b){ const ra=NOTE_TO_INT[a.bass??a.root]; const rb=NOTE_TO_INT[b.bass??b.root]; const d=Math.min((rb-ra+12)%12,(ra-rb+12)%12); return d<=2?1:(d<=4?0.5:-0.2*(d-4)); }
            function functionalScore(a,b,K){ return (3*0,0), 0; }
            function scorePair(a,b,K){ return 3*functionalScore(a,b,K) + 2*fifthsScore(a,b) + 3*bassDistanceScore(a,b) + 2*commonTonesScore(a,b); }
            // fix functionalScore separate to keep weights flexible
            (function(){ const _fs=function(a,b,K){ const fa=functionalLabel(a.root,K.mode,K.tonic); const fb=functionalLabel(b.root,K.mode,K.tonic); if (fa==="T"&&fb==="PD") return 1; if (fa==="PD"&&fb==="D") return 1; if (fa==="D"&&fb==="T") return 1; if (fa===fb) return 0.5; return 0; }; functionalScore=_fs; })();
            function withSmoothBass(order){ const thirdMap={"B":"D","C#":"E","D#":"F#","E":"G","F#":"A","G#":"B","A":"C#"}; const fifthMap={"B":"F#","C#":"G#","D#":"A#","E":"B","F#":"C#","G#":"D#","A":"E"}; let prevBass=NOTE_TO_INT[order[0].bass??order[0].root]; const out=[]; for (let i=0;i<order.length;i++){ const c={...order[i]}; const r=NOTE_TO_INT[c.root]; const bass3=thirdMap[c.root]; const bass5=fifthMap[c.root]; const tryBass=(bass)=> bass? Math.min((NOTE_TO_INT[bass]-prevBass+12)%12,(prevBass-NOTE_TO_INT[bass]+12)%12) : 12; const dRoot=Math.min((r-prevBass+12)%12,(prevBass-r+12)%12); const d3=tryBass(bass3); const d5=tryBass(bass5); if (d3<dRoot && d3<=d5) c.bass=bass3; else if (d5<dRoot) c.bass=bass5; prevBass=NOTE_TO_INT[c.bass??c.root]; out.push(c); } return out; }
            function beamSearchOrders(input,K,beamK=24,seed=1){ function keyOf(c){ return c.root+"|"+c.type; } const bag=new Map(); for (const c of input) bag.set(keyOf(c),(bag.get(keyOf(c))||0)+1); const uniques=Array.from(new Map(input.map(c=>[keyOf(c),c])).values()); const rnd=rng(seed); let beam=[{order:[],score:0,last:null}]; for (let i=0;i<input.length;i++){ const next=[]; for (const state of beam){ for (const u of uniques){ const k=keyOf(u); const used=state.order.filter(x=>keyOf(x)===k).length; const avail=bag.get(k); if (used>=avail) continue; const sc= state.last ? scorePair(state.last,u,K) : 0; next.push({order:[...state.order,u], score: state.score + sc + rnd()*1e-6, last:u}); } } next.sort((a,b)=>b.score-a.score); beam = next.slice(0,beamK); } return beam.sort((a,b)=>b.score-a.score).slice(0,12).map(s=>s.order); }
            function phraseBonus(order){ const n=order.length; if (n%2!==0) return 0; const m=n/2; let same=0; for (let i=0;i<m;i++) if (order[i].root===order[i+m].root && order[i].type===order[i+m].type) same++; return same/m; }
            function distinctOrders(list,N){ const out=[]; const seen=new Set(); for (const ord of list){ const sig=ord.map(c=>c.root+"-"+c.type).join("|"); if (!seen.has(sig)){ out.push(ord); seen.add(sig);} if (out.length>=N) break; } return out; }
            function toSequenceFromOrder(order, tempo, stepPattern, slotIndexByType){ const prog=Array.from({length:64},(_,i)=>({id:i, chord:null})); function place(bar, step, c){ const idx=bar*8+step; const name = (c.bass && c.bass!==c.root) ? `${c.root}${shortType(c.type)}/${c.bass}` : `${c.root}${shortType(c.type)}`; const bassOffset = (c.bass && c.bass!==c.root) ? nearestSignedOffset(c.root,c.bass) : 0; prog[idx].chord = { root:c.root, type:c.type, slotIndex: defaultSlotIndex(c.type, slotIndexByType), bassOffset, octave:0, inversion:-1, name }; }
                let k=0; for (let b=0;b<4;b++){ for (const s of stepPattern[b]) place(b,s,order[k]); k++; } for (let b=4;b<8;b++){ for (const s of stepPattern[b-4]) place(b,s,order[k]); k++; } return { tempo, bars:8, progression: prog };
            }
            function chordShuffle(eightChords, opts){
                const bars=8; const stepPattern=opts.stepPattern; const slotIndexByType=opts.slotIndexByType||{"minor7":3,"minor9":3,"m11":1};
                const K = opts.key || detectKey(eightChords);
                const keyOf = (c)=> c.root+"|"+c.type;
                function hasNoAdjDuplicates(order){ for (let i=1;i<order.length;i++){ if (keyOf(order[i])===keyOf(order[i-1])) return false; } return true; }
                function goodVariety(order){ const first4 = new Set(order.slice(0,4).map(keyOf)).size; const all = new Set(order.map(keyOf)).size; return first4>=3 && all>=4; }
                function fallbackOrders(src){
                    // build permutations from the first 4 events without repetition within a phrase
                    const base = src.slice(0,4);
                    const perms = [ [0,2,1,3], [0,3,1,2], [1,3,0,2], [2,0,3,1] ];
                    const out=[]; for (const p of perms){ const ord = p.map(i=>base[i]).concat(p.map(i=>base[i])); out.push(ord); }
                    return out;
                }
                const orders = beamSearchOrders(eightChords, K, 32, opts.seed||1);
                const rescored = orders.map(o=>{ const smooth=withSmoothBass(o); let sc=0; for(let i=0;i<smooth.length-1;i++) sc += scorePair(smooth[i],smooth[i+1],K); sc += phraseBonus(smooth); return {order:smooth, score:sc}; }).sort((a,b)=>b.score-a.score);
                let ranked = rescored.map(r=>r.order).filter(o=>hasNoAdjDuplicates(o) && goodVariety(o));
                if (!ranked.length) ranked = fallbackOrders(eightChords);
                const top = distinctOrders(ranked, 4);
                return top.map(ord=>toSequenceFromOrder(ord, opts.tempo, stepPattern, slotIndexByType));
            }
            function buildStepPatternFromSeq(seq){ const steps=[]; for (let b=0;b<4;b++){ const arr=[]; for (let s=0;s<8;s++){ const st = seq.progression[b*8+s]; if (st && st.chord) arr.push(s); } steps.push(arr.length?arr:[0]); } return steps; }
            window.__pxl_shuffleFromSeq1 = function __pxl_shuffleFromSeq1(srcSeq, opts){
                const tempo = opts && opts.tempo ? opts.tempo : (srcSeq.tempo||85);
                const stepPattern = (opts && opts.stepPattern) ? opts.stepPattern : buildStepPatternFromSeq(srcSeq);
                const events=[]; for (let b=0;b<4;b++){ const idx = stepPattern[b]?.[0] ?? 0; const sc = srcSeq.progression[b*8+idx].chord; const root=sc.root; const type=sc.type; let bass=null; if (sc.bassOffset && sc.bassOffset!==0){ const rI=NOTE_TO_INT[root]; const bI=(rI + sc.bassOffset + 120)%12; bass = INT_TO_NOTE[bI]; } events.push({root, type, bass}); }
                const eight = events.concat(events);
                return chordShuffle(eight, { tempo, stepPattern, key: opts?.key, seed: (opts&&opts.seed)||7, slotIndexByType: opts?.slotIndexByType });
            };
        

// Enhanced MusicEngine class with comprehensive modal support
class MusicEngine {
    // Get scale notes for any mode using interval rotation
    static getScaleNotes(key, mode) {
        if (!key || !mode || mode === 'FREE') return KEYS;
        
        const keyIndex = KEYS.indexOf(key);
        if (keyIndex === -1) return KEYS;
        
        // Check for additional scales first (standalone scales)
        
        // Find the mode in our modal systems
        let modeIntervals = null;
        let systemName = null;
        
        for (const [sysName, system] of Object.entries(MODAL_SYSTEMS)) {
            const foundMode = system.modes.find(m => m.id === mode);
            if (foundMode && system.parentIntervals) {
                modeIntervals = this.rotateIntervals(system.parentIntervals, foundMode.rotation);
                systemName = sysName;
                break;
            }
        }
        
        if (!modeIntervals) {
            // Fallback to legacy interval mapping for backward compatibility
            const legacyIntervalMap = {
                'MAJOR': [0, 2, 4, 5, 7, 9, 11],
                'MINOR': [0, 2, 3, 5, 7, 8, 10]
            };
            modeIntervals = legacyIntervalMap[mode] || [0, 2, 4, 5, 7, 9, 11];
        }
        
        return modeIntervals.map(interval => KEYS[(keyIndex + interval) % 12]);
    }
    
    // Rotate intervals to create mode from parent scale
    static rotateIntervals(intervals, rotation) {
        if (rotation === 0) return intervals;
        
        const rotated = [...intervals];
        for (let i = 0; i < rotation; i++) {
            const first = rotated.shift();
            rotated.push(first);
        }
        
        // Re-root to 0
        const root = rotated[0];
        return rotated.map(interval => (interval - root + 12) % 12);
    }
    
    // Get available chords for a note in a specific mode
    static getAvailableChords(note, mode, selectedKey) {
        if (!note || !mode || !selectedKey) return ['major'];
        if (mode === 'FREE') return ALL_CHORD_TYPES;
        
        const scaleNotes = this.getScaleNotes(selectedKey, mode);
        if (!scaleNotes.includes(note)) return [];
        
        const degree = scaleNotes.indexOf(note);
        
        
        // Get diatonic chord quality for this degree
        const chordQuality = DIATONIC_CHORD_QUALITIES[mode];
        if (chordQuality && chordQuality[degree]) {
            const baseChord = chordQuality[degree];
            
            // Return variations of the base chord type
            switch (baseChord) {
                case 'major7':
                    return ['major', 'major7', 'major9', 'major11', 'major13', '6', '69', 'sus2', 'sus4'];
                case 'minor7':
                    return ['minor', 'm7', 'm9', 'm11', 'm13', 'm6', 'sus2', 'sus4'];
                case '7':
                    return ['major', '7', '9', '11', '13', 'sus2', 'sus4'];
                case 'm7b5':
                    return ['dim', 'm7b5', 'dim7'];
                case 'minorMajor7':
                    return ['minor', 'minorMajor7', 'minor9', 'minor11', 'minor13', 'm6', 'sus2', 'sus4'];
                case 'major7#5':
                    return ['augmented', 'major7#5', 'aug9', 'sus2', 'sus4'];
                case 'dim7':
                    return ['dim', 'dim7', 'dim9'];
                default:
                    return ['major'];
            }
        }
        
        // Fallback to legacy mode qualities
        const legacyMODE_QUALITIES = {
            'MAJOR': {
                0: ['major', 'major7', 'major9', 'major11', 'major13', '6', '69', 'sus2', 'sus4'],
                1: ['minor', 'm7', 'm9', 'm11', 'm13', 'm6', 'sus2', 'sus4'],
                2: ['minor', 'm7', 'm9', 'm11', 'm13', 'm6', 'sus2', 'sus4'],
                3: ['major', 'major7', 'major9', 'major11', 'major13', '6', '69', 'sus2', 'sus4'],
                4: ['major', 'major7', 'major9', 'major11', 'major13', '6', '69', 'sus2', 'sus4'],
                5: ['minor', 'm7', 'm9', 'm11', 'm13', 'm6', 'sus2', 'sus4'],
                6: ['dim', 'm7b5', 'dim7']
            },
            'MINOR': {
                0: ['minor', 'm7', 'm9', 'm11', 'm13', 'm6', 'sus2', 'sus4'],
                1: ['dim', 'm7b5', 'dim7'],
                2: ['major', 'major7', 'major9', 'major11', 'major13', '6', '69', 'sus2', 'sus4'],
                3: ['minor', 'm7', 'm9', 'm11', 'm13', 'm6', 'sus2', 'sus4'],
                4: ['minor', 'm7', 'm9', 'm11', 'm13', 'm6', 'sus2', 'sus4'],
                5: ['major', 'major7', 'major9', 'major11', 'major13', '6', '69', 'sus2', 'sus4'],
                6: ['major', 'major7', 'major9', 'major11', 'major13', '6', '69', 'sus2', 'sus4']
            }
        };
        
        const legacyQualities = legacyMODE_QUALITIES[mode];
        if (legacyQualities && legacyQualities[degree]) {
            return legacyQualities[degree];
        }
        
        return ['major'];
    }
    
    // Get mode display name
    static getModeDisplayName(mode) {
        return MODE_DISPLAY_NAMES[mode] || mode;
    }
    
    // Get all available modes grouped by system
    static getModalSystems() {
        return MODAL_SYSTEMS;
    }
    
    // Get modes for a specific system
    static getModesForSystem(systemId) {
        return MODAL_SYSTEMS[systemId]?.modes || [];
    }
    
    // Get system info for a mode
    static getSystemForMode(modeId) {
        for (const [sysName, system] of Object.entries(MODAL_SYSTEMS)) {
            if (system.modes.some(m => m.id === modeId)) {
                return { systemName: sysName, system };
            }
        }
        return null;
    }
    
    // Keep existing methods for backward compatibility
    static generateChord(root, type, octave, inversion) {
        if (!root || !type) return [60];
        
        const rootIndex = KEYS.indexOf(root);
        if (rootIndex === -1) return [60];
        
        const chordDef = CHORD_LIBRARY[type];
        if (!chordDef || !chordDef.intervals) return [60 + rootIndex];
        
        const baseNote = 60 + (octave * 12) + rootIndex;
        let notes = chordDef.intervals.map(interval => baseNote + interval);
        
        if (inversion > 0) {
            for (let i = 0; i < inversion && i < notes.length; i++) {
                notes[i] += 12;
            }
        } else if (inversion < 0) {
            for (let i = notes.length + inversion; i < notes.length && i >= 0; i++) {
                notes[i] -= 12;
            }
        }
        
        return notes;
    }
    
    static getChordName(note, type, useFlats = false) {
        if (!note) return 'C';
        if (!type) return note;
        
        const displayNote = useFlats && SHARP_TO_FLAT[note] ? SHARP_TO_FLAT[note] : note;
        const chordDef = CHORD_LIBRARY[type];
        const suffix = chordDef && chordDef.display !== undefined ? chordDef.display : '';
        return displayNote + suffix;
    }
    
    static getBassNote(rootNote, bassOffsetSemitones, chordType = null) {
        if (!rootNote || typeof rootNote !== 'number') return 36;
        let bassNote = rootNote - 24 + (bassOffsetSemitones || 0);
        while (bassNote < 24) bassNote += 12;
        return bassNote;
    }
    
    static getChordNameWithBass(note, type, chordKey, bassOffsets, useFlats = false) {
        if (!note || !type) return 'C';
        
        const baseName = this.getChordName(note, type, useFlats);
        
        if (!bassOffsets || !chordKey) return baseName;
        
        const bassOffset = bassOffsets[chordKey];
        if (!bassOffset || bassOffset === 0) return baseName;
        
        const rootIndex = KEYS.indexOf(note);
        if (rootIndex === -1) return baseName;
        
        const bassNoteIndex = (rootIndex + bassOffset + 12) % 12;
        const bassNote = KEYS[bassNoteIndex];
        if (!bassNote) return baseName;
        
        return baseName + '/' + bassNote;
    }
}

        // Audio Engine (converted from React component)
        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.activeVoices = new Set();
                this.bassGain = 0.3;
                this.chordGain = 0.3;
                this.midiAccess = null;
                this.midiInputs = new Map();
                this.midiOutputs = new Map();
                this.midiOutput = null; // selected output
                this.onMidiNote = null;
                this.sustainPedal = false;
                this.sustainedNotes = new Set();
                this.activeNotes = new Set();
                this.filterNode = null;
                this.masterGain = null;
                this.lowEQ = null;
                this.midEQ = null;
                this.highEQ = null;
                
                // Effects nodes
                this.reverbNode = null;
                this.reverbDryGain = null;
                this.reverbWetGain = null;
                this.delayNode1 = null;
                this.delayNode2 = null;
                this.delayFeedback = null;
                this.delayPanner1 = null;
                this.delayPanner2 = null;
                this.delayVolume = null;
                this.delayDryGain = null;
                this.delayWetGain = null;
                
                // Wavetable support
                this.wavetables = new Map();
                this.currentWavetableFrame = 0;
                this.wavetableFrameCount = 0;
                
                // Timing buffer to prevent audio pops
                this.lastNoteTime = 0;
            }

            async initialize() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    this.filterNode = this.audioContext.createBiquadFilter();
                    this.masterGain = this.audioContext.createGain();
                    
                    this.filterNode.type = 'highshelf';
                    this.filterNode.frequency.value = 2000;
                    this.filterNode.gain.value = 0;
                    
                    // Create EQ nodes for synthesis sounds
                    this.lowEQ = this.audioContext.createBiquadFilter();
                    this.lowEQ.type = 'lowshelf';
                    this.lowEQ.frequency.value = 320;
                    this.lowEQ.gain.value = 0;
                    
                    this.midEQ = this.audioContext.createBiquadFilter();
                    this.midEQ.type = 'peaking';
                    this.midEQ.frequency.value = 1000;
                    this.midEQ.Q.value = 1;
                    this.midEQ.gain.value = 0;
                    
                    this.highEQ = this.audioContext.createBiquadFilter();
                    this.highEQ.type = 'highshelf';
                    this.highEQ.frequency.value = 3200;
                    this.highEQ.gain.value = 0;
                    
                    // Connect EQ chain: filterNode -> lowEQ -> midEQ -> highEQ -> masterGain
                    this.filterNode.connect(this.lowEQ);
                    this.lowEQ.connect(this.midEQ);
                    this.midEQ.connect(this.highEQ);
                    this.highEQ.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Load wavetables
                    console.log('🔍 About to call loadWavetables()...');
                    try {
                        await this.loadWavetables();
                        console.log('🔍 loadWavetables() completed');
                    } catch (wavetableError) {
                        console.error('❌ loadWavetables() failed:', wavetableError);
                    }
                    
                    await this.initializeMIDI();
                    return true
                } catch (e) {
                    console.log('Audio initialization failed:', e);
                    return false;
                }
            }

            async loadWavetables() {
                console.log('🚀 ENTERED loadWavetables() method');
                try {
                    console.log('Starting wavetable loading...');
                    console.log('Current working directory context:', window.location.href);
                    
                    // Load BALA SMOOVE wavetable frames
                    const frameCount = 99; // 158 to 256 = 99 frames
                    const wavetableData = [];
                    
                    // Try different path strategies
                    const pathStrategies = [
                        'WAVETABLE/BALA SMOOVE/BALA SMOOVE_',
                        './WAVETABLE/BALA SMOOVE/BALA SMOOVE_',
                        '../WAVETABLE/BALA SMOOVE/BALA SMOOVE_',
                        '/WAVETABLE/BALA SMOOVE/BALA SMOOVE_'
                    ];
                    
                    let successfulPath = null;
                    
                    // Test first frame with different paths
                    for (const basePath of pathStrategies) {
                        const testPath = `${basePath}158.wav`;
                        console.log(`Testing path: ${testPath}`);
                        
                        try {
                            const testResponse = await fetch(testPath);
                            if (testResponse.ok) {
                                successfulPath = basePath;
                                console.log(`✅ Found working path: ${basePath}`);
                                break;
                            } else {
                                console.log(`❌ Path failed: ${testPath} (Status: ${testResponse.status})`);
                            }
                        } catch (pathError) {
                            console.log(`❌ Path error: ${testPath}`, pathError);
                        }
                    }
                    
                    if (!successfulPath) {
                        console.error('❌ No working path found for wavetables');
                        return;
                    }
                    
                    // Load all frames using the working path
                    for (let i = 158; i <= 256; i++) {
                        const frameNumber = i.toString().padStart(3, '0');
                        const filePath = `${successfulPath}${frameNumber}.wav`;
                        
                        try {
                            const response = await fetch(filePath);
                            if (response.ok) {
                                const arrayBuffer = await response.arrayBuffer();
                                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                                wavetableData.push(audioBuffer);
                                console.log(`✅ Loaded frame ${frameNumber}`);
                            } else {
                                console.warn(`⚠️ Failed to load frame ${frameNumber}: ${response.status}`);
                            }
                        } catch (frameError) {
                            console.error(`❌ Error loading frame ${frameNumber}:`, frameError);
                        }
                    }
                    
                    if (wavetableData.length > 0) {
                        this.wavetables.set('BALA SMOOVE', wavetableData);
                        this.wavetableFrameCount = wavetableData.length;
                        console.log(`🎉 Successfully loaded ${wavetableData.length} wavetable frames for BALA SMOOVE`);
                        console.log('Available wavetables:', Array.from(this.wavetables.keys()));
                    } else {
                        console.error('❌ No wavetable frames were loaded successfully');
                    }
                } catch (error) {
                    console.error('❌ Error loading wavetables:', error);
                }
            }

            createWavetableOscillator(freq, velocityGain, wavetableName = 'BALA SMOOVE') {
                console.log(`createWavetableOscillator called with freq: ${freq}, velocityGain: ${velocityGain}, wavetableName: ${wavetableName}`);
                
                if (!this.audioContext) {
                    console.error('No audio context available');
                    return null;
                }
                
                if (!this.wavetables.has(wavetableName)) {
                    console.error(`Wavetable '${wavetableName}' not found. Available wavetables:`, Array.from(this.wavetables.keys()));
                    return null;
                }
                
                const wavetableFrames = this.wavetables.get(wavetableName);
                const frameCount = wavetableFrames.length;
                console.log(`Found ${frameCount} wavetable frames`);
                
                // Create buffer source for current frame
                const currentFrame = this.currentWavetableFrame % frameCount;
                console.log(`Using frame ${currentFrame} of ${frameCount}`);
                
                const bufferSource = this.audioContext.createBufferSource();
                bufferSource.buffer = wavetableFrames[currentFrame];
                
                // Create gain node for volume control
                const gain = this.audioContext.createGain();
                bufferSource.connect(gain);
                gain.connect(this.filterNode);
                
                // Set playback rate to match frequency
                const baseFreq = 22; // Base frequency of the wavetable (F1)
                const playbackRate = freq / baseFreq;
                bufferSource.playbackRate.value = playbackRate;
                console.log(`Set playback rate to ${playbackRate} for frequency ${freq}`);
                
                // Apply envelope
                const now = this.audioContext.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(velocityGain, now + 0.01); // 10ms attack
                gain.gain.exponentialRampToValueAtTime(velocityGain * 0.3, now + 0.3); // 300ms decay
                
                // Start playback
                bufferSource.start();
                console.log('Buffer source started successfully');
                
                // Advance to next frame for next note
                this.currentWavetableFrame = (this.currentWavetableFrame + 1) % frameCount;
                
                const voice = { osc: bufferSource, gain, stopped: false, isBass: false };
                this.activeVoices.add(voice);
                console.log('Voice added to active voices');
                return voice;
            }

            setFilterCutoff(value) {
                if (!this.filterNode) return;
                const gainReduction = -((10 - value) * 7.2);
                this.filterNode.gain.setValueAtTime(gainReduction, this.audioContext.currentTime);
            }

            // Effects methods
            setReverb(wetLevel) {
                console.log('setReverb called with wetLevel:', wetLevel);
                
                // Create reverb effect using convolution
                if (!this.reverbNode) {
                    this.reverbNode = this.audioContext.createConvolver();
                    this.reverbNode.connect(this.masterGain);
                }
                
                // Create dry/wet mix nodes
                if (!this.reverbDryGain) {
                    this.reverbDryGain = this.audioContext.createGain();
                    this.reverbDryGain.connect(this.masterGain);
                }
                if (!this.reverbWetGain) {
                    this.reverbWetGain = this.audioContext.createGain();
                    this.reverbWetGain.connect(this.masterGain);
                }
                
                // Simple impulse response for reverb
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * 3.75; // 3.75 second reverb (extended by 25% from 3.0)
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.3));
                    }
                }
                
                this.reverbNode.buffer = impulse;
                
                // Set dry/wet mix (0 = all dry, 100 = all wet)
                const dryLevel = (100 - wetLevel) / 100;
                const wetLevelNormalized = wetLevel / 100;
                
                this.reverbDryGain.gain.value = dryLevel;
                this.reverbWetGain.gain.value = wetLevelNormalized;
                
                console.log('Reverb mix - Dry:', dryLevel, 'Wet:', wetLevelNormalized);
                
                // Update effects routing without disconnecting
                this.updateEffectsRouting();
            }

            setDelay(time, wetLevel) {
                console.log('setDelay called with time:', time, 'wetLevel:', wetLevel);
                
                // Create stereo delay effect with BPM-linked timing and panning
                if (!this.delayNode) {
                    // Create two delay nodes for stereo effect
                    this.delayNode1 = this.audioContext.createDelay();
                    this.delayNode2 = this.audioContext.createDelay();
                    
                    // Calculate BPM-linked delay times
                    const bpm = tempo || 120; // Use current tempo or default to 120
                    const beatTime = 60 / bpm; // Time per beat in seconds
                    
                    // Set delay times based on BPM (alternating left-right pattern) - PERFECT TIMING
                    this.delayNode1.delayTime.value = beatTime / 2;   // 1/2nd note (left) - perfect
                    this.delayNode2.delayTime.value = beatTime / 4;   // 1/4th note (right) - perfect
                    
                    console.log(`BPM: ${bpm}, 1/2: ${(beatTime / 2).toFixed(3)}s, 1/4: ${(beatTime / 4).toFixed(3)}s`);
                    
                    // Create feedback gain for rhythmic bounces
                    this.delayFeedback = this.audioContext.createGain();
                    this.delayFeedback.gain.value = 0.225; // 22.5% feedback (reduced by 25% from 30%)
                    
                    // Reduce delay volume so they're not too loud
                    this.delayVolume = this.audioContext.createGain();
                    this.delayVolume.gain.value = 0.3; // 30% volume to make delays quieter
                    
                    // Create stereo panner for left delay
                    this.delayPanner1 = this.audioContext.createStereoPanner();
                    this.delayPanner1.pan.value = -0.8; // Pan left
                    
                    // Create stereo panner for right delay  
                    this.delayPanner2 = this.audioContext.createStereoPanner();
                    this.delayPanner2.pan.value = 0.8; // Pan right
                    
                    // Connect the delay chain with feedback and panning
                    this.delayNode1.connect(this.delayPanner1);
                    this.delayNode2.connect(this.delayPanner2);
                    
                    // Connect both panned delays to feedback
                    this.delayPanner1.connect(this.delayFeedback);
                    this.delayPanner2.connect(this.delayFeedback);
                    this.delayFeedback.connect(this.delayNode1); // Feedback loop
                    this.delayFeedback.connect(this.delayNode2); // Feedback loop
                    
                    // Connect panned delays through volume control to master
                    this.delayPanner1.connect(this.delayVolume);
                    this.delayPanner2.connect(this.delayVolume);
                    this.delayVolume.connect(this.masterGain);
                }
                
                // Create dry/wet mix nodes
                if (!this.delayDryGain) {
                    this.delayDryGain = this.audioContext.createGain();
                    this.delayDryGain.connect(this.masterGain);
                }
                if (!this.delayWetGain) {
                    this.delayWetGain = this.audioContext.createGain();
                    this.delayWetGain.connect(this.delayNode1);
                }
                
                // Set dry/wet mix (0 = all dry, 100 = all wet)
                const dryLevel = (100 - wetLevel) / 100;
                const wetLevelNormalized = wetLevel / 100;
                
                this.delayDryGain.gain.value = dryLevel;
                this.delayWetGain.gain.value = wetLevelNormalized;
                
                console.log('3-Delay mix - Dry:', dryLevel, 'Wet:', wetLevelNormalized, 'Feedback: 30%');
                
                // Update effects routing without disconnecting
                this.updateEffectsRouting();
            }

            updateEffectsRouting() {
                // Unified effects routing that handles both reverb and delay simultaneously
                // Disconnect filter from all destinations first
                this.filterNode.disconnect();
                
                // Calculate volume compensation for reverb
                let dryVolume = 1.0; // Default dry volume
                if (this.reverbWetGain && this.reverbWetGain.gain.value > 0) {
                    // Reduce dry volume when reverb is active to prevent overall volume increase
                    const reverbWetLevel = this.reverbWetGain.gain.value;
                    dryVolume = 1.0 - (reverbWetLevel * 0.3); // Reduce dry by 30% of wet level
                    dryVolume = Math.max(dryVolume, 0.4); // Don't go below 40% dry volume
                }
                
                // Connect to masterGain for dry signal (with volume compensation)
                const dryGain = this.audioContext.createGain();
                dryGain.gain.value = dryVolume;
                dryGain.connect(this.masterGain);
                this.filterNode.connect(dryGain);
                
                // Connect to reverb if active
                if (this.reverbWetGain && this.reverbWetGain.gain.value > 0) {
                    this.filterNode.connect(this.reverbWetGain);
                    this.reverbWetGain.connect(this.reverbNode);
                }
                
                // Connect to delay if active
                if (this.delayWetGain && this.delayWetGain.gain.value > 0) {
                    this.filterNode.connect(this.delayWetGain);
                }
                
                console.log('Effects routing updated - reverb volume compensated, both effects can work simultaneously');
            }

            setEqBand(band, value) {
                if (!this.audioContext) return;
                const gain = Math.max(-12, Math.min(12, value)); // Ensure gain is within bounds
                
                switch (band) {
                    case 'low':
                        if (this.lowEQ) {
                            this.lowEQ.gain.value = gain;
                        }
                        break;
                    case 'mid':
                        if (this.midEQ) {
                            this.midEQ.gain.value = gain;
                        }
                        break;
                    case 'high':
                        if (this.highEQ) {
                            this.highEQ.gain.value = gain;
                        }
                        break;
                }
            }

            setInstrument(instrument) {
                // Apply instrument-specific EQ settings
                switch (instrument) {
                    case '11': // Crystal
                        this.setEqBand('low', 0);   // Flat low for precision
                        this.setEqBand('mid', 1);   // Slight mid boost
                        this.setEqBand('high', 4);  // High boost for crystal clarity
                        break;
                    case '22': // ODES
                        this.setEqBand('low', 1);   // Slight low boost
                        this.setEqBand('mid', 2);   // Mid boost for warmth
                        this.setEqBand('high', 0);  // Flat
                        break;
                    case '33': // BRIGHT
                        this.setEqBand('low', 0);   // Flat low for clarity
                        this.setEqBand('mid', 2);   // Mid boost for presence
                        this.setEqBand('high', 3);  // High boost for brightness
                        break;
                    case '44': // TRIANGLE
                        this.setEqBand('low', 0);
                        this.setEqBand('mid', 0);
                        this.setEqBand('high', 0);
                        break;
                    case '55': // SINE
                        this.setEqBand('low', 0);
                        this.setEqBand('mid', 0);
                        this.setEqBand('high', 0);
                        break;
                    default:
                        // Reset to flat
                        this.setEqBand('low', 0);
                        this.setEqBand('mid', 0);
                        this.setEqBand('high', 0);
                        break;
                }
            }

            // Create authentic synthesis sounds using Tone.js for accuracy
            createRichSound(freq, isBass, velocityGain, instrument) {
                if (!this.audioContext || !this.filterNode) return null;
                
                const currentTime = this.audioContext.currentTime;
                
                // Create a simple gain node that connects to our filter chain
                const masterGain = this.audioContext.createGain();
                masterGain.connect(this.filterNode);
                
                // Apply envelope with fader blend - smoother attack to prevent pops
                const blend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                const chordCap = blend;
                const targetGain = this.chordGain * chordCap * velocityGain;
                
                masterGain.gain.setValueAtTime(0, currentTime);
                masterGain.gain.linearRampToValueAtTime(targetGain, currentTime + 0.01); // Increased from 0.005 to 0.01
                masterGain.gain.exponentialRampToValueAtTime(targetGain * 0.3, currentTime + 1.0);
                
                // Minimal buffer to prevent overlapping audio events - keeping latency low
                const bufferTime = 0.001; // Back to 1ms for minimal latency
                if (currentTime < this.lastNoteTime + bufferTime) {
                    currentTime = this.lastNoteTime + bufferTime;
                }
                this.lastNoteTime = currentTime;
                
                switch (instrument) {
                    case '11': // Crystal (Fixed - removed metallic oscillator)
                        // Crystal Clear: Ultra-clean with crisp attack, perfect for complex harmonies
                        const crystalOsc = this.audioContext.createOscillator();
                        
                        const crystalClarityFilter = this.audioContext.createBiquadFilter();
                        const crystalPrecisionFilter = this.audioContext.createBiquadFilter();
                        
                        // Precise attack transient (keeping the click for character)
                        const crystalNoise = this.createNoise();
                        const crystalClickGain = this.audioContext.createGain();
                        const crystalClickFilter = this.audioContext.createBiquadFilter();
                        
                        // Pure sine wave for maximum clarity
                        crystalOsc.type = 'sine';
                        crystalOsc.frequency.value = freq;
                        
                        // Crystal clarity filters
                        crystalClarityFilter.type = 'peaking';
                        crystalClarityFilter.frequency.value = freq * 2;
                        crystalClarityFilter.Q.value = 1;
                        crystalClarityFilter.gain.value = 3;
                        
                        crystalPrecisionFilter.type = 'highpass';
                        crystalPrecisionFilter.frequency.value = freq * 0.3;
                        crystalPrecisionFilter.Q.value = 0.7;
                        
                        // Precise click (reduced gain to prevent random tones)
                        crystalClickFilter.type = 'bandpass';
                        crystalClickFilter.frequency.value = freq * 6;
                        crystalClickFilter.Q.value = 3;
                        crystalClickGain.gain.value = 0.03; // Reduced from 0.08 to prevent random tones
                        crystalClickGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.005);
                        
                        // Connect ultra-clean signal path (no metallic oscillator)
                        crystalOsc.connect(crystalPrecisionFilter);
                        
                        crystalNoise.connect(crystalClickFilter);
                        crystalClickFilter.connect(crystalClickGain);
                        crystalClickGain.connect(crystalPrecisionFilter);
                        
                        crystalPrecisionFilter.connect(crystalClarityFilter);
                        crystalClarityFilter.connect(masterGain);
                        
                        // Apply envelope with fader blend - sustained tone until key release
                        const blend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                        const chordCap = blend;
                        const targetGain = this.chordGain * chordCap * velocityGain;
                        masterGain.gain.setValueAtTime(0, currentTime);
                        masterGain.gain.linearRampToValueAtTime(targetGain, currentTime + 0.01);
                        // No decay - sustain at full strength until key release
                        
                        crystalOsc.start(currentTime);
                        crystalNoise.start(currentTime);
                        // No auto-stop - sustain until finger release (like bass)
                        crystalNoise.stop(currentTime + 0.05); // Only noise stops quickly
                        
                        const crystalVoice = { osc: [crystalOsc, crystalNoise], gain: masterGain, stopped: false, isBass };
                        this.activeVoices.add(crystalVoice);
                        return crystalVoice;
                        
                    case '22': // ODES
                        // Authentic RHODES: Triangle wave with octave harmonic for bell-like character
                        const rhodesOsc1 = this.audioContext.createOscillator();
                        const rhodesOsc2 = this.audioContext.createOscillator();
                        const rhodesGain1 = this.audioContext.createGain();
                        const rhodesGain2 = this.audioContext.createGain();
                        const rhodesMixer = this.audioContext.createGain();
                        const rhodesFilter = this.audioContext.createBiquadFilter();
                        
                        // Main tone: triangle wave
                        rhodesOsc1.type = 'triangle';
                        rhodesOsc1.frequency.value = freq;
                        rhodesGain1.gain.value = 0.7;
                        
                        // Octave harmonic: triangle wave
                        rhodesOsc2.type = 'triangle';
                        rhodesOsc2.frequency.value = freq * 2; // Octave up
                        rhodesGain2.gain.value = 0.5;
                        rhodesOsc2.detune.value = 5; // Slight detune
                        
                        // Filter for warmth
                        rhodesFilter.type = 'lowpass';
                        rhodesFilter.frequency.value = 8000;
                        rhodesFilter.Q.value = 0.2;
                        
                        // Connect: osc1+osc2 -> gains -> mixer -> filter -> masterGain
                        rhodesOsc1.connect(rhodesGain1);
                        rhodesOsc2.connect(rhodesGain2);
                        rhodesGain1.connect(rhodesMixer);
                        rhodesGain2.connect(rhodesMixer);
                        rhodesMixer.connect(rhodesFilter);
                        rhodesFilter.connect(masterGain);
                        
                        // Rhodes envelope: sharp attack, long decay, some sustain (fader blend already applied above)
                        // No need to set gain again - it's already set with fader blend
                        
                        rhodesOsc1.start();
                        rhodesOsc2.start();
                        
                        const rhodesVoice = { osc: [rhodesOsc1, rhodesOsc2], gain: masterGain, stopped: false, isBass };
                        this.activeVoices.add(rhodesVoice);
                        return rhodesVoice;



                    case '33': // BRIGHT
                        // Bright Xylophone: Clean and bright with metallic attack, perfect tuning for clear chord voicing
                        const brightOsc = this.audioContext.createOscillator();
                        const brightMetallic1 = this.audioContext.createOscillator();
                        const brightMetallic2 = this.audioContext.createOscillator();
                        const brightMetallicGain = this.audioContext.createGain();
                        
                        const brightFilter = this.audioContext.createBiquadFilter();
                        const brightResonanceFilter = this.audioContext.createBiquadFilter();
                        
                        // Create sharper attack noise
                        const brightNoise = this.createNoise();
                        const brightAttackGain = this.audioContext.createGain();
                        const brightAttackFilter = this.audioContext.createBiquadFilter();
                        
                        // Pure fundamental
                        brightOsc.type = 'triangle';
                        brightOsc.frequency.value = freq;
                        
                        // Metallic transients at different frequencies
                        brightMetallic1.type = 'square';
                        brightMetallic2.type = 'sawtooth';
                        brightMetallic1.frequency.value = freq * 6;
                        brightMetallic2.frequency.value = freq * 10;
                        
                        brightMetallicGain.gain.value = 0.2;
                        brightMetallicGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.005);
                        
                        // Bright filtering
                        brightFilter.type = 'peaking';
                        brightFilter.frequency.value = freq * 3;
                        brightFilter.Q.value = 2;
                        brightFilter.gain.value = 6;
                        
                        brightResonanceFilter.type = 'bandpass';
                        brightResonanceFilter.frequency.value = freq * 1.1;
                        brightResonanceFilter.Q.value = 4;
                        
                        // Sharp attack
                        brightAttackFilter.type = 'highpass';
                        brightAttackFilter.frequency.value = 2000;
                        brightAttackGain.gain.value = 0.15;
                        brightAttackGain.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.01);
                        
                        // Connect signal
                        brightOsc.connect(brightResonanceFilter);
                        
                        brightMetallic1.connect(brightMetallicGain);
                        brightMetallic2.connect(brightMetallicGain);
                        brightMetallicGain.connect(brightResonanceFilter);
                        
                        brightNoise.connect(brightAttackFilter);
                        brightAttackFilter.connect(brightAttackGain);
                        brightAttackGain.connect(brightResonanceFilter);
                        
                        brightResonanceFilter.connect(brightFilter);
                        brightFilter.connect(masterGain);
                        
                        brightOsc.start();
                        brightMetallic1.start();
                        brightMetallic2.start();
                        brightNoise.start();
                        
                        const brightVoice = { osc: [brightOsc, brightMetallic1, brightMetallic2, brightNoise], gain: masterGain, stopped: false, isBass };
                        this.activeVoices.add(brightVoice);
                        return brightVoice;



                    case '44': // TRIANGLE
                        // Simple triangle wave oscillator
                        const triOsc = this.audioContext.createOscillator();
                        const triGain = this.audioContext.createGain();
                        triOsc.connect(triGain);
                        triGain.connect(this.filterNode);
                        triOsc.frequency.value = freq;
                        triOsc.type = 'triangle';
                        
                        // Apply chord/bass blend from vertical fader
                        const triBlend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                        const triChordCap = triBlend;
                        const triTargetGain = this.chordGain * triChordCap * velocityGain;
                        triGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        triGain.gain.linearRampToValueAtTime(triTargetGain, this.audioContext.currentTime + 0.05);
                        
                        triOsc.start();
                        
                        const triVoice = { osc: triOsc, gain: triGain, stopped: false, isBass };
                        this.activeVoices.add(triVoice);
                        return triVoice;
                        
                    case '55': // SINE
                        // Simple sine wave oscillator
                        const sineOsc = this.audioContext.createOscillator();
                        const sineGain = this.audioContext.createGain();
                        sineOsc.connect(sineGain);
                        sineGain.connect(this.filterNode);
                        sineOsc.frequency.value = freq;
                        sineOsc.type = 'sine';
                        
                        // Apply chord/bass blend from vertical fader
                        const sineBlend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                        const sineChordCap = sineBlend;
                        const sineTargetGain = this.chordGain * sineChordCap * velocityGain;
                        sineGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        sineGain.gain.linearRampToValueAtTime(sineTargetGain, this.audioContext.currentTime + 0.05);
                        
                        sineOsc.start();
                        
                        const sineVoice = { osc: sineOsc, gain: sineGain, stopped: false, isBass };
                        this.activeVoices.add(sineVoice);
                        return sineVoice;
                        
                    default:
                        // Fall back to simple oscillator for TRIANGLE and SINE
                        return null;
                }
            }

            createNoise() {
                const bufferSize = 4096;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                return noise;
            }

            playClick(isDownbeat = false) {
                if (!this.audioContext || !this.masterGain) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.value = isDownbeat ? 1200 : 800;
                osc.type = 'sine';
                const t = this.audioContext.currentTime;
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.15, t + 0.001);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.05);
            }

            async initializeMIDI() {
                try {
                    if (!navigator.requestMIDIAccess) {
                        console.warn('[MIDI] Web MIDI API not supported in this browser.');
                        return false;
                    }
                    console.log('[MIDI] Requesting MIDI access…');
                    this.midiAccess = await navigator.requestMIDIAccess();
                    this.midiAccess.onstatechange = () => {
                        this.setupMIDIInputs();
                        this.setupMIDIOutputs();
                    };
                    this.setupMIDIInputs();
                    this.setupMIDIOutputs();
                    console.log(`[MIDI] Access granted. Inputs: ${this.midiInputs.size}, Outputs: ${this.midiOutputs.size}`);
                    return true;
                } catch (error) {
                    console.error('MIDI init failed:', error);
                    return false;
                }
            }

            setupMIDIInputs() {
                this.midiInputs.clear();
                for (let input of this.midiAccess.inputs.values()) {
                    input.onmidimessage = (message) => this.handleMIDIMessage(message);
                    this.midiInputs.set(input.id, input);
                }
                console.log(`[MIDI] Configured ${this.midiInputs.size} MIDI input(s).`);
            }

            setupMIDIOutputs() {
                this.midiOutputs.clear();
                let firstOutput = null;
                for (let output of this.midiAccess.outputs.values()) {
                    if (!firstOutput) firstOutput = output;
                    this.midiOutputs.set(output.id, output);
                    try {
                        console.log(`[MIDI] Output detected: ${output.name} (id=${output.id})`);
                    } catch {}
                }
                // Preserve existing selection if still available; otherwise choose first
                if (!this.midiOutput || !this.midiOutputs.has(this.midiOutput.id)) {
                    // Prefer common virtual busses when available (IAC / loopMIDI / Virtual / Network)
                    const prefer = Array.from(this.midiOutputs.values()).find(o => /IAC|loopMIDI|Virtual|Network/i.test(o.name || ''));
                    this.midiOutput = prefer || firstOutput || null;
                }
                if (this.midiOutput) {
                    console.log(`[MIDI] Selected output: ${this.midiOutput.name} (id=${this.midiOutput.id})`);
                } else {
                    console.warn('[MIDI] No MIDI outputs available.');
                }
                // Reflect availability in UI
                if (typeof state !== 'undefined') {
                    state.midiEnabled = this.midiOutputs.size > 0;
                    if (typeof updateMIDIIndicator === 'function') updateMIDIIndicator();
                }
            }

            handleMIDIMessage(message) {
                const [status, note, velocity] = message.data;
                const command = status & 0xf0;
                
                switch (command) {
                    case 0x90:
                        if (velocity > 0) {
                            this.handleMIDINoteOn(note, velocity);
                        } else {
                            this.handleMIDINoteOff(note);
                        }
                        break;
                    case 0x80:
                        this.handleMIDINoteOff(note);
                        break;
                    case 0xb0:
                        this.handleMIDIControlChange(note, velocity);
                        break;
                }
            }

            handleMIDINoteOn(midiNote, velocity) {
                const noteIndex = midiNote % 12;
                const noteName = KEYS[noteIndex];
                this.activeNotes.add(noteName);
                if (this.sustainPedal) this.sustainedNotes.add(noteName);
                if (this.onMidiNote) this.onMidiNote(noteName, true, velocity);
            }

            handleMIDINoteOff(midiNote) {
                const noteIndex = midiNote % 12;
                const noteName = KEYS[noteIndex];
                this.activeNotes.delete(noteName);
                if (!this.sustainPedal || !this.sustainedNotes.has(noteName)) {
                    if (this.onMidiNote) this.onMidiNote(noteName, false, 0);
                }
            }

            handleMIDIControlChange(ccNumber, value) {
                switch (ccNumber) {
                    case 64:
                        const wasPressed = this.sustainPedal;
                        this.sustainPedal = value > 63;
                        if (wasPressed && !this.sustainPedal) {
                            this.sustainedNotes.forEach(note => {
                                if (!this.activeNotes.has(note) && this.onMidiNote) {
                                    this.onMidiNote(note, false, 0);
                                }
                            });
                            this.sustainedNotes.clear();
                        }
                        updateSustainIndicator();
                        break;
                }
            }

            setMidiCallbacks(noteCallback) {
                this.onMidiNote = noteCallback;
            }

            midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            }

            // --- MIDI OUT helpers (channel 0) ---
            sendNoteOn(midiNote, velocity = 100, channel = 15) {
                if (!this.midiOutput) {
                    console.warn('[MIDI] NoteOn skipped: no MIDI outputs available.');
                    return;
                }
                const status = 0x90 | (channel & 0x0F);
                const v = Math.max(1, Math.min(127, velocity|0));
                try { this.midiOutput.send([status, midiNote & 0x7F, v & 0x7F]); } catch (e) { console.warn('[MIDI] send failed for output', this.midiOutput && this.midiOutput.name, e); }
                try { console.log(`[MIDI] NoteOn ch=${channel} note=${midiNote} vel=${v} → ${this.midiOutput ? this.midiOutput.name : 'none'}`); } catch {}
            }

            sendNoteOff(midiNote, channel = 15) {
                if (!this.midiOutput) return;
                const status = 0x80 | (channel & 0x0F);
                try { this.midiOutput.send([status, midiNote & 0x7F, 0]); } catch (e) { console.warn('[MIDI] send failed for output', this.midiOutput && this.midiOutput.name, e); }
                try { console.log(`[MIDI] NoteOff ch=${channel} note=${midiNote} → ${this.midiOutput ? this.midiOutput.name : 'none'}`); } catch {}
            }

            startOsc(freq, isBass, velocityGain = 1) {
                console.log(`startOsc called: freq=${freq}, isBass=${isBass}, selectedSound=${state.selectedSound}`);
                
                if (!this.audioContext || !this.filterNode) return null;
                
                // === AGGRESSIVE BLIP SOLUTION ===
                // Very strict voice limiting to prevent audio artifacts
                const maxVoices = 12; // Much lower limit for cleaner audio
                if (this.activeVoices.size >= maxVoices && !isBass) {
                    console.log(`Voice limit reached (${maxVoices}), skipping chord voice`);
                    return null; // Skip chord voices when limit reached, but allow bass
                }
                
                // If we're close to the limit, stop some old voices first
                if (this.activeVoices.size >= maxVoices - 3 && !isBass) {
                    // Stop the oldest voices to make room
                    const voicesArray = Array.from(this.activeVoices);
                    const voicesToStop = voicesArray.slice(0, 3); // Stop 3 oldest voices
                    voicesToStop.forEach(voice => {
                        if (voice && !voice.stopped && voice.gain && voice.osc) {
                            try {
                                voice.stopped = true;
                                const currentTime = this.audioContext?.currentTime || 0;
                                if (voice.gain.gain) {
                                    voice.gain.gain.cancelScheduledValues(currentTime);
                                    voice.gain.gain.setValueAtTime(voice.gain.gain.value || 0, currentTime);
                                    voice.gain.gain.linearRampToValueAtTime(0, currentTime + 0.01); // Very quick stop
                                }
                                if (voice.osc.stop) voice.osc.stop(currentTime + 0.01);
                            } catch (e) {
                                console.log('Voice cleanup error:', e);
                            }
                        }
                    });
                    // Remove stopped voices from the set
                    voicesToStop.forEach(voice => this.activeVoices.delete(voice));
                }
                

                
                // Bass: triangle for low C-E, sine for F and up (regardless of selected sound)
                if (isBass) {
                    // Convert frequency to MIDI note to determine range
                    const midiNote = Math.round(12 * Math.log2(freq / 440) + 69);
                    const octave = Math.floor(midiNote / 12) - 5; // C4 = octave 0
                    const noteInOctave = midiNote % 12; // 0=C, C#, D, D#, E in MIDI octave -3 only
                    
                    // Use triangle ONLY for MIDI octave -3 C-E (octave button -1), sine for everything else
                    if (octave <= -3 && noteInOctave <= 4) { // C, C#, D, D#, E in MIDI octave -3 only
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(this.filterNode);
                        osc.frequency.value = freq;
                        osc.type = 'triangle';
                        
                        // Add low-pass filter to smooth out triangle harmonics for bass
                        const bassFilter = this.audioContext.createBiquadFilter();
                        bassFilter.type = 'lowpass';
                        bassFilter.frequency.value = 150; // Lower cutoff to be gentler
                        bassFilter.Q.value = 0.5; // Lower Q for smoother rolloff
                        
                        // Add 4dB boost for triangle bass to match sine volume
                        const triangleBoost = this.audioContext.createGain();
                        triangleBoost.gain.value = 1.58; // +4dB (10^(4/20) = 1.58)
                        
                        // Connect: osc -> filter -> boost -> gain
                        osc.disconnect();
                        osc.connect(bassFilter);
                        bassFilter.connect(triangleBoost);
                        triangleBoost.connect(gain);
                        
                        // Store filter and boost references for cleanup
                        osc.bassFilter = bassFilter;
                        osc.triangleBoost = triangleBoost;
                        
                        console.log(`TRIANGLE bass: octave ${octave}, note ${noteInOctave}`);
                        
                        // Apply chord/bass blend from vertical fader
                        const blend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                        const bassCap = 1 - blend;
                        const targetGain = this.bassGain * bassCap * velocityGain;
                        gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(targetGain, this.audioContext.currentTime + 0.05);
                        
                        osc.start();
                        
                        const voice = { osc, gain, stopped: false, isBass };
                        this.activeVoices.add(voice);
                        return voice;
                    } else {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(this.filterNode);
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        
                        console.log(`SINE bass: octave ${octave}, note ${noteInOctave}`);
                        
                        // Apply chord/bass blend from vertical fader
                        const blend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                        const bassCap = 1 - blend;
                        const targetGain = this.bassGain * bassCap * velocityGain;
                        gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(targetGain, this.audioContext.currentTime + 0.05);
                        
                        osc.start();
                        
                        const voice = { osc, gain, stopped: false, isBass };
                        this.activeVoices.add(voice);
                        return voice;
                    }
                } else {
                    // Chords use the selected sound type with synthesis sounds
                    console.log(`Processing chord with sound: ${state.selectedSound}`);
                    
                    switch (state.selectedSound) {
                        case 'SINE':
                            const sineOsc = this.audioContext.createOscillator();
                            const sineGain = this.audioContext.createGain();
                            sineOsc.connect(sineGain);
                            sineGain.connect(this.filterNode);
                            sineOsc.frequency.value = freq;
                            sineOsc.type = 'sine';
                            
                            // Apply chord/bass blend from vertical fader
                            const blend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                            const chordCap = blend;
                            const targetGain = this.chordGain * chordCap * velocityGain;
                            sineGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                            sineGain.gain.linearRampToValueAtTime(targetGain, this.audioContext.currentTime + 0.05);
                            
                            sineOsc.start();
                            
                            const voice = { osc: sineOsc, gain: sineGain, stopped: false, isBass };
                            this.activeVoices.add(voice);
                            return voice;
                            
                        case 'TRIANGLE':
                            const triOsc = this.audioContext.createOscillator();
                            const triGain = this.audioContext.createGain();
                            triOsc.connect(triGain);
                            triGain.connect(this.filterNode);
                            triOsc.frequency.value = freq;
                            triOsc.type = 'triangle';
                            
                            // Apply chord/bass blend from vertical fader
                            const triBlend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                            const triChordCap = triBlend;
                            const triTargetGain = this.chordGain * triChordCap * velocityGain;
                            triGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                            triGain.gain.linearRampToValueAtTime(triTargetGain, this.audioContext.currentTime + 0.05);
                            
                            triOsc.start();
                            
                            const triVoice = { osc: triOsc, gain: triGain, stopped: false, isBass };
                            this.activeVoices.add(triVoice);
                            return triVoice;
                            
                        case '11': // Crystal
                            // Use rich synthesis for Crystal Clear
                            return this.createRichSound(freq, isBass, velocityGain, '11');
                        case '22': // ODES
                            // Use rich synthesis for rhodes
                            return this.createRichSound(freq, isBass, velocityGain, '22');
                        case '33': // BRIGHT
                            // Use rich synthesis for Bright Xylophone
                            return this.createRichSound(freq, isBass, velocityGain, '33');
                        case '44': // TRIANGLE
                            // Use rich synthesis for TRIANGLE
                            return this.createRichSound(freq, isBass, velocityGain, '44');
                        case '55': // SINE
                            // Use rich synthesis for SINE
                            return this.createRichSound(freq, isBass, velocityGain, '55');
                        default:
                            const defaultOsc = this.audioContext.createOscillator();
                            const defaultGain = this.audioContext.createGain();
                            defaultOsc.connect(defaultGain);
                            defaultGain.connect(this.filterNode);
                            defaultOsc.frequency.value = freq;
                            defaultOsc.type = 'triangle';
                            
                            // Apply chord/bass blend from vertical fader
                            const defaultBlend = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                            const defaultChordCap = defaultBlend;
                            const defaultTargetGain = this.chordGain * defaultChordCap * velocityGain;
                            defaultGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                            defaultGain.gain.linearRampToValueAtTime(defaultTargetGain, this.audioContext.currentTime + 0.05);
                            
                            defaultOsc.start();
                            
                            const defaultVoice = { osc: defaultOsc, gain: defaultGain, stopped: false, isBass };
                            this.activeVoices.add(defaultVoice);
                            return defaultVoice;
                    }
                }
            }

            stopAllVoices() {
                // === FLAM CANCELLATION ===
                // Cancel any pending flam timeouts for immediate cutoff
                if (state.currentFlamTimeouts && state.currentFlamTimeouts.length > 0) {
                    state.currentFlamTimeouts.forEach(timeoutId => {
                        clearTimeout(timeoutId);
                    });
                    state.currentFlamTimeouts = [];
                    state.cancelledNotes.clear();
                }
                
                // === STRICT MONO MODE WITH CLICK PREVENTION ===
                // Very short fade to prevent clicks while maintaining mono behavior
                this.activeVoices.forEach(voice => {
                    if (!voice.stopped && voice.gain && voice.osc) {
                        try {
                            voice.stopped = true;
                            const currentTime = this.audioContext?.currentTime || 0;
                            if (this.audioContext && voice.gain.gain) {
                                voice.gain.gain.cancelScheduledValues(currentTime);
                                voice.gain.gain.setValueAtTime(voice.gain.gain.value || 0, currentTime);
                                // Very short linear fade to prevent clicks
                                voice.gain.gain.linearRampToValueAtTime(0, currentTime + 0.008); // 8ms fade
                            }
                            if (Array.isArray(voice.osc)) {
                                // Handle dual oscillator voices (SINE blend)
                                voice.osc.forEach(osc => {
                                    if (osc.stop) osc.stop(currentTime + 0.008); // Match gain fade time
                                    // Clean up LFO if present
                                    if (osc.balafonLFO) {
                                        osc.stop();
                                    }
                                });
                            } else if (voice.osc.stop) {
                                // Handle single oscillator voices
                                voice.osc.stop(currentTime + 0.008); // Match gain fade time
                            }
                        } catch (e) {
                            console.log('Voice cleanup error:', e);
                        }
                    }
                });
                this.activeVoices.clear();
            }

            // Send NoteOff for all 128 notes on given channel
            allNotesOff(channel = 15) {
                if (!this.midiOutput) return;
                try {
                    for (let n = 0; n < 128; n++) {
                        const status = 0x80 | (channel & 0x0F);
                        this.midiOutput.send([status, n & 0x7F, 0]);
                    }
                } catch (e) {
                    console.warn('[MIDI] allNotesOff failed:', e);
                }
            }
        }

        // Initialize audio engine
        const audioEngine = new AudioEngine();
        
        // Initialize default reverb effect on startup
        setTimeout(() => {
            if (audioEngine.setReverb) {
                audioEngine.setReverb(10); // Set to level 1 (10% wet)
                console.log('Default reverb initialized on startup');
            }
            // Knob rotations removed - using numbers as indicators instead
            console.log('Default reverb initialized on startup');
        }, 100); // Small delay to ensure audioEngine is ready

        // Helper functions
        function getCurrentChordType(note, slotIndex = 0) {
            if (!note) return 'major';
            
            // Check if note is in scale for current mode/key
            const isInScale = state.mode === 'FREE' || MusicEngine.getScaleNotes(state.selectedKey, state.mode).includes(note);
            if (!isInScale) return null; // Return null for notes not in scale
            
            // 5-row chord level system for PIANO X MODE - all slots are now editable
            // Rows 1-3 (slotIndex 0-2): Follow mode's chord scroll progression (diatonic)
            // Rows 4-5 (slotIndex 3-4): FREE mode for maximum flexibility
            
            const availableChords = MusicEngine.getAvailableChords(note, 
                (state.sizeMode === 'X' && slotIndex >= 3) ? 'FREE' : state.mode, 
                state.selectedKey);
            if (availableChords.length === 0) return 'major';
            
            const slotKey = note + '-' + slotIndex;
            const slotChordIndex = state.slotChordIndices[slotKey];
            if (slotChordIndex !== undefined && availableChords[slotChordIndex]) {
                return availableChords[slotChordIndex];
            }
            
            // Initialize each slot with a different chord from the progression
            // Row 1 (slotIndex 0): First chord in progression
            // Row 2 (slotIndex 1): Second chord in progression  
            // Row 3 (slotIndex 2): Third chord in progression
            const defaultIndex = Math.min(slotIndex, availableChords.length - 1);
            state.slotChordIndices[slotKey] = defaultIndex;
            
            return state.mode === 'FREE' ? 'major' : availableChords[defaultIndex];
        }

        function createChord(note, chordType, octaveOverride = null, inversionOverride = null) {
            if (!note || !chordType || chordType === null) return null;
            
            const octave = (octaveOverride === null || octaveOverride === undefined) ? state.octave : octaveOverride;
            const inversion = (inversionOverride === null || inversionOverride === undefined) ? state.inversion : inversionOverride;
            const chordNotes = MusicEngine.generateChord(note, chordType, octave, inversion);
            const chordKey = note + '-' + chordType;
            
            return {
                root: note,
                type: chordType,
                notes: chordNotes,
                name: MusicEngine.getChordNameWithBass(note, chordType, chordKey, state.bassOffsets, state.useFlats)
            };
        }

        function playChord(chord, velocityGain = 1, slotIndex = 0, source = 'user', bassOffsetOverride = null, octaveOverride = null, inversionOverride = null) {
            if (!chord || !chord.notes || chord.notes.length === 0) return;
            
            // === STRICT MONO MODE WITH CLICK PREVENTION ===
            // Stop ALL voices with short fade for clean mono chord playback
            audioEngine.stopAllVoices();
            
            // Small delay to ensure clean voice stopping before starting new chord
            setTimeout(() => {
                playChordInternal(chord, velocityGain, slotIndex, source, bassOffsetOverride, octaveOverride, inversionOverride);
            }, 12); // 12ms delay - slightly longer than 8ms fade
        }
        
        function playChordInternal(chord, velocityGain = 1, slotIndex = 0, source = 'user', bassOffsetOverride = null, octaveOverride = null, inversionOverride = null) {
            if (!chord || !chord.notes || chord.notes.length === 0) return;
            
            const transposedChordNotes = chord.notes.map(note => note + state.globalTranspose);
            
            // === OPTIMIZED FLAM IMPLEMENTATION ===
            if (state.flamMode === 'off') {
                // FAST PATH: Original chord playback when flam is off
                transposedChordNotes.forEach((midiNote, i) => {
                    const delayMs = i * 15;
                    setTimeout(() => {
                        audioEngine.startOsc(audioEngine.midiToFreq(midiNote), false, velocityGain);
                        // MIDI OUT: channel 0
                        // Chords on channel 16 (0-based 15)
                        audioEngine.sendNoteOn(midiNote, 96, 15);
                        // For user-held notes, do NOT auto-send NoteOff; release will handle it.
                        if (source !== 'user') {
                            setTimeout(() => audioEngine.sendNoteOff(midiNote, 15), 480);
                        }
                    }, delayMs);
                });
            } else {
                // FLAM PATH: Only when flam is active
                // Sort notes by pitch (lowest to highest) for proper flam order
                const sortedNotes = [...transposedChordNotes].sort((a, b) => a - b);
                
                // Store timeout IDs for flam cancellation if needed
                const flamTimeouts = [];
                
                sortedNotes.forEach((midiNote, i) => {
                    const delayMs = i * state.flamTiming[state.flamMode];
                    
                    const timeoutId = setTimeout(() => {
                        // Only play if the note hasn't been cancelled
                        if (!state.cancelledNotes || !state.cancelledNotes.has(midiNote)) {
                            audioEngine.startOsc(audioEngine.midiToFreq(midiNote), false, velocityGain);
                            // MIDI OUT: channel 0
                            // Chords on channel 16 (0-based 15)
                            audioEngine.sendNoteOn(midiNote, 96, 15);
                            // For user-held notes, do NOT auto-send NoteOff; release will handle it.
                            if (source !== 'user') {
                                setTimeout(() => audioEngine.sendNoteOff(midiNote, 15), 480);
                            }
                        }
                    }, delayMs);
                    
                    flamTimeouts.push(timeoutId);
                });
                
                // Store the flam timeouts for potential cancellation
                if (source === 'user') {
                    state.currentFlamTimeouts = flamTimeouts;
                }
            }
            
            const rootIndex = KEYS.indexOf(chord.root);
            const octaveForBass = (octaveOverride === null || octaveOverride === undefined) ? state.octave : octaveOverride;
            let originalRootNote = 60 + (octaveForBass * 12) + rootIndex + state.globalTranspose;
            
            if (state.globalTranspose < 0) {
                originalRootNote += 12;
            }
            
            const chordKey = chord.root + '-' + chord.type + '-' + slotIndex;
            const bassOffsetSemitones = (bassOffsetOverride !== null && bassOffsetOverride !== undefined)
                ? bassOffsetOverride
                : (state.bassOffsets[chordKey] || 0);
            const bassNote = MusicEngine.getBassNote(originalRootNote, bassOffsetSemitones, chord.type);
            audioEngine.startOsc(audioEngine.midiToFreq(bassNote), true, velocityGain);
            // MIDI OUT: bass on channel 15 (0-based 14)
            audioEngine.sendNoteOn(bassNote, 100, 14);
            // For user-held bass, do NOT auto-send NoteOff; release will handle it.
            if (source !== 'user') {
                setTimeout(() => audioEngine.sendNoteOff(bassNote, 14), 480);
            }
            
            const chordWithBass = {
                ...chord,
                name: MusicEngine.getChordNameWithBass(chord.root, chord.type, chordKey, state.bassOffsets, state.useFlats)
            };
            
            state.currentChord = chordWithBass;
            state.lastPlayedChord = chordWithBass;
            // Only user-triggered chords should become candidates for step input
            if (source === 'user') {
                state.selectedChordForStep = { root: chord.root, type: chord.type };
                const usedOct = (octaveOverride === null || octaveOverride === undefined) ? state.octave : octaveOverride;
                const usedInv = (inversionOverride === null || inversionOverride === undefined) ? state.inversion : inversionOverride;
                state.selectedChordMeta = {
                    slotIndex,
                    bassOffset: bassOffsetSemitones,
                    octave: usedOct,
                    inversion: usedInv
                };
            }
            updateChordDisplay();
        }

        function getSlotCount() {
            switch (state.sizeMode) {
                case 'XL': return 1;
                case 'XXL': return 2;
                case 'XXXL': return 3;
                case 'X': return 5;
                default: return 1;
            }
        }

function getModeDisplayName(mode) {
    return MusicEngine.getModeDisplayName(mode);
}

function getModalSystemName(mode) {
    if (mode === 'FREE') return 'CHROMATIC';
    
    const systemInfo = MusicEngine.getSystemForMode(mode);
    if (!systemInfo) return 'MODE';
    
    // Map system names to display names (all caps)
            const systemDisplayNames = {
            'major': 'MAJOR',
            'melodicMinor': 'MELODIC MINOR',
            'harmonicMinor': 'HARMONIC MINOR',
            'harmonicMajor': 'HARMONIC MAJOR'
        };
    
    return systemDisplayNames[systemInfo.systemName] || 'MODE';
}

function adjustModeButtonFontSize(modeValue) {
    const modeButton = document.getElementById('mode-value');
    if (!modeButton) return;
    
    // Check if text contains line breaks (multi-line)
    if (modeValue.includes('\n')) {
        const lines = modeValue.split('\n');
        const lineCount = lines.length;
        
        if (lineCount === 3) {
            // 3-level text: top, middle, bottom
            const middleLine = lines[1];
            const bottomLine = lines[2];
            
            if (bottomLine.length > 8) {
                modeButton.style.fontSize = '11px'; // Very long bottom line
            } else if (bottomLine.length > 6) {
                modeButton.style.fontSize = '12px'; // Long bottom line
            } else {
                modeButton.style.fontSize = '13px'; // Short bottom line
            }
        } else if (lineCount === 2) {
            // 2-level text: top, bottom
            const secondLine = lines[1];
            
            if (secondLine.length > 10) {
                modeButton.style.fontSize = '12px'; // Very long text like "AUGMENTED ♯2"
            } else if (secondLine.length > 8) {
                modeButton.style.fontSize = '13px'; // Long text like "DOMINANT"
            } else if (secondLine.length > 6) {
                modeButton.style.fontSize = '14px'; // Medium text like "AUGMENTED"
            } else {
                modeButton.style.fontSize = '15px'; // Short text like "♭6", "♯5", "♭2"
            }
        }
    } else {
        // Single line - use smaller default size
        modeButton.style.fontSize = '16px';
    }
}

        function jumpToModeByName(modeName) {
            const input = modeName.toLowerCase().trim();
            
            // Check for key + mode combinations first (e.g., "harmonic minor key C#")
            const keyModeMatch = input.match(/^(.*?)\s+key\s+([a-g][#b]?)$/i);
            if (keyModeMatch) {
                const modePart = keyModeMatch[1].trim();
                const keyPart = keyModeMatch[2].toUpperCase();
                
                // Validate the key
                if (!KEYS.includes(keyPart)) {
                    return false;
                }
                
                // First try to find the mode
                let foundMode = null;
                
                // Direct mode ID matches
                if (MODES.includes(modePart.toUpperCase())) {
                    foundMode = modePart.toUpperCase();
                } else {
                    // Search through all mode names and aliases
                    for (const modeId of MODES) {
                        if (modeId === 'FREE') continue;
                        
                        const displayName = MODE_DISPLAY_NAMES[modeId];
                        if (!displayName) continue;
                        
                        // Check if input matches display name (case-insensitive)
                        if (displayName.toLowerCase().includes(modePart) || modePart.includes(displayName.toLowerCase())) {
                            foundMode = modeId;
                            break;
                        }
                        
                        // Check aliases from MODAL_SYSTEMS
                        const systemInfo = MusicEngine.getSystemForMode(modeId);
                        if (systemInfo && systemInfo.system.modes) {
                            const mode = systemInfo.system.modes.find(m => m.id === modeId);
                            if (mode && mode.aliases) {
                                for (const alias of mode.aliases) {
                                    if (alias.toLowerCase().includes(modePart) || modePart.includes(alias.toLowerCase())) {
                                        foundMode = modeId;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // If no specific mode found, check system names
                    if (!foundMode) {
                        const systemNames = {
                            'major': ['major', 'ionian system', 'major system', 'natural major'],
                            'melodicMinor': ['melodic minor', 'jazz minor', 'melodic minor system'],
                            'harmonicMinor': ['harmonic minor', 'harmonic minor system'],
                            'harmonicMajor': ['harmonic major', 'harmonic major system']
                        };
                        
                        for (const [systemId, names] of Object.entries(systemNames)) {
                            for (const name of names) {
                                if (name.toLowerCase().includes(modePart) || modePart.includes(name.toLowerCase())) {
                                    const system = MODAL_SYSTEMS[systemId];
                                    if (system && system.modes.length > 0) {
                                        foundMode = system.modes[0].id;
                                        break;
                                    }
                                }
                            }
                            if (foundMode) break;
                        }
                    }
                }
                
                // If we found a mode, set both mode and key
                if (foundMode) {
                    state.mode = foundMode;
                    state.selectedKey = keyPart;
                    resetOnModeChange();
                    updateUI();
                    return true;
                }
            }
            
            // Check for just "key C", "key C#" etc.
            const keyOnlyMatch = input.match(/^key\s+([a-g][#b]?)$/i);
            if (keyOnlyMatch) {
                const keyPart = keyOnlyMatch[1].toUpperCase();
                if (KEYS.includes(keyPart)) {
                    state.selectedKey = keyPart;
                    updateUI();
                    return true;
                }
            }
            
            // Direct mode ID matches
            if (MODES.includes(input.toUpperCase())) {
                state.mode = input.toUpperCase();
                resetOnModeChange();
                updateUI();
                return true;
            }
            
            // Search through all mode names and aliases
            for (const modeId of MODES) {
                if (modeId === 'FREE') continue;
                
                const displayName = MODE_DISPLAY_NAMES[modeId];
                if (!displayName) continue;
                
                // Check for exact matches first (most specific)
                if (input === displayName.toLowerCase()) {
                    state.mode = modeId;
                    resetOnModeChange();
                    updateUI();
                    return true;
                }
                
                // Check if input starts with the mode name (for variations like "Dorian b2")
                if (input.startsWith(displayName.toLowerCase())) {
                    // Check if this is a specific variation by looking at the rest of the input
                    const remainingInput = input.substring(displayName.toLowerCase().length).trim();
                    if (remainingInput === '' || remainingInput.match(/^[#b]\d+$/)) {
                        // This is either the exact mode or a variation like "b2", "#4", etc.
                        console.log(`Mode variation detected: "${input}" -> ${modeId} (${displayName})`);
                        state.mode = modeId;
                        resetOnModeChange();
                        updateUI();
                        return true;
                    }
                }
                
                // Check aliases from MODAL_SYSTEMS
                const systemInfo = MusicEngine.getSystemForMode(modeId);
                if (systemInfo && systemInfo.system.modes) {
                    const mode = systemInfo.system.modes.find(m => m.id === modeId);
                    if (mode && mode.aliases) {
                        for (const alias of mode.aliases) {
                            // Check for exact alias matches first
                            if (input === alias.toLowerCase()) {
                                state.mode = modeId;
                                resetOnModeChange();
                                updateUI();
                                return true;
                            }
                            
                            // Check if input starts with the alias (for variations)
                            if (input.startsWith(alias.toLowerCase())) {
                                const remainingInput = input.substring(alias.toLowerCase().length).trim();
                                if (remainingInput === '' || remainingInput.match(/^[#b]\d+$/)) {
                                    state.mode = modeId;
                                    resetOnModeChange();
                                    updateUI();
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            
            // Add specific mode aliases
            const modeAliases = {
                'natural minor': 'AEOLIAN',
                'aeolian': 'AEOLIAN',
                'natural major': 'IONIAN',
                'ionian': 'IONIAN'
            };
            
            for (const [alias, modeId] of Object.entries(modeAliases)) {
                // Check for exact alias matches first
                if (input === alias.toLowerCase()) {
                    state.mode = modeId;
                    resetOnModeChange();
                    updateUI();
                    return true;
                }
                
                // Check if input starts with the alias (for variations)
                if (input.startsWith(alias.toLowerCase())) {
                    const remainingInput = input.substring(alias.toLowerCase().length).trim();
                    if (remainingInput === '' || remainingInput.match(/^[#b]\d+$/)) {
                        state.mode = modeId;
                        resetOnModeChange();
                        updateUI();
                        return true;
                    }
                }
            }
            
            return false;
        }

        function splitChordName(chordName, isTopSlot = true) {
            let keyName = '';
            let chordType = '';
            
            if (chordName.length >= 2 && (chordName.charAt(1) === '#' || chordName.charAt(1) === 'b')) {
                keyName = chordName.slice(0, 2);
                chordType = chordName.slice(2);
            } else {
                keyName = chordName.charAt(0);
                chordType = chordName.slice(1);
            }
            
            if (state.useFlats && SHARP_TO_FLAT[keyName]) {
                keyName = SHARP_TO_FLAT[keyName];
            }
            
            let bassNote = '';
            if (chordType.includes('/')) {
                const [baseChord, bass] = chordType.split('/');
                chordType = baseChord;
                bassNote = '/' + bass;
            }
            
            const splitPatterns = [
                { pattern: /^(aug)(Maj7|maj7|M7)$/, groups: [1, 2] },
                { pattern: /^(maj9|M9)(#11|b13|#5)$/, groups: [1, 2] },
                { pattern: /^(7sus2|7sus4)(b9|#9|b13)$/, groups: [1, 2] },
                { pattern: /^(m7)(b5|#5)$/, groups: [1, 2] },
                { pattern: /^(7)(b9|#9|#11|b13|alt)$/, groups: [1, 2] },
                { pattern: /^(9)(#11|b13|sus)$/, groups: [1, 2] },
                { pattern: /^(11|13)(sus|b9)$/, groups: [1, 2] },
                { pattern: /^(maj7|M7)(#11|#5)$/, groups: [1, 2] },
                { pattern: /^(m)\((maj7|Maj7|M7)\)$/, groups: [1, 2] },
                { pattern: /^(dim)(9|7)$/, groups: [1, 2] }
            ];
            
            if (chordType.length >= 5) {
                for (const { pattern, groups } of splitPatterns) {
                    const match = chordType.match(pattern);
                    if (match) {
                        const part1 = match[groups[0]];
                        const part2 = match[groups[1]];
                        
                        if (isTopSlot) {
                            return {
                                top: keyName + part1,
                                bottom: '(' + part2 + ')' + bassNote,
                                shouldSplit: true
                            };
                        } else {
                            return {
                                top: part1,
                                bottom: '(' + part2 + ')' + bassNote,
                                shouldSplit: true
                            };
                        }
                    }
                }
            }
            
            return {
                top: isTopSlot ? chordName : chordType || keyName,
                bottom: '',
                shouldSplit: false
            };
        }

        // UI Update Functions
        function updateUI() {
            updateControlValues();
            updatePianoKeys();
            updateChordDisplay();
            updateSlotIndicator();
            updateMIDIIndicator();
            updateFlamIndicator(); // Initialize flam indicator
            // Knob rotations removed - using numbers as indicators instead
        }

        function updateControlValues() {
            document.getElementById('key-value').textContent = state.useFlats && SHARP_TO_FLAT[state.selectedKey] ? SHARP_TO_FLAT[state.selectedKey] : state.selectedKey;
            document.getElementById('mode-value').textContent = getModeDisplayName(state.mode);
            const modeHeader = document.getElementById('mode-header');
            const modeValue = getModeDisplayName(state.mode);
            const modeButton = document.getElementById('mode-btn');
            
            modeHeader.textContent = getModalSystemName(state.mode);
            
            // Add data-current-mode attribute for CSS targeting
            modeButton.setAttribute('data-current-mode', state.mode);
            
            // Debug: Log when we're setting up easy mode glow
            if (['IONIAN', 'AEOLIAN', 'HARMONIC_MAJOR', 'HARMONIC_MINOR'].includes(state.mode)) {
                console.log(`Easy mode detected: ${state.mode}, selectedControl: ${state.selectedControl}`);
            }
            
            // Add data-system attribute for CSS targeting
            if (state.mode === 'FREE') {
                modeHeader.removeAttribute('data-system');
            } else {
                const systemInfo = MusicEngine.getSystemForMode(state.mode);
                if (systemInfo) {
                    modeHeader.setAttribute('data-system', systemInfo.systemName);
                }
            }
            
            // Add data-current-mode attribute for CSS targeting
            if (modeButton) {
                modeButton.setAttribute('data-current-mode', state.mode);
            }
            
            // Adjust font size based on mode name length
            adjustModeButtonFontSize(modeValue);
            document.getElementById('oct-value').textContent = state.octave;
            document.getElementById('inv-value').textContent = state.inversion;
            document.getElementById('sound-name').textContent = state.selectedSound;
            // Update filter/reverb value display
            if (state.effectsMode) {
                document.getElementById('filter-value').textContent = state.reverbLevel;
            } else {
                document.getElementById('filter-value').textContent = state.filterCutoff;
            }
            
            // Update transpose/delay value display
            if (state.effectsMode) {
                document.getElementById('transpose-value').textContent = state.delayLevel;
            } else {
                document.getElementById('transpose-value').textContent = state.globalTranspose >= 0 ? `+${state.globalTranspose}` : state.globalTranspose;
            }
            document.getElementById('xl-button').textContent = state.sizeMode;
            
            // Update fader value display
            const faderThumb = document.getElementById('fader-thumb');
            if (faderThumb) {
                const faderValue = typeof state.faderBlend === 'number' ? state.faderBlend : 0.32;
                const trackHeight = 114;
                const minTop = 6;
                const maxTop = trackHeight - 6 - faderThumb.offsetHeight;
                const top = minTop + (maxTop - minTop) * (1 - faderValue);
                faderThumb.style.top = `${top}px`;
                console.log('🎚️ updateControlValues: faderValue:', faderValue, 'top:', top);
            }
            
            // Update bass button
            const bassBtn = document.getElementById('bass-btn');
            if (state.selectedControl === 'bass') {
                bassBtn.textContent = state.bassOffset === 'BASS' ? '𝄢' : state.bassOffset;
            } else {
                bassBtn.textContent = '𝄢';
            }
            
            // Update selected control styling
            document.querySelectorAll('.control-btn, .knob, .xl-button, .vertical-fader, #tempo-display').forEach(btn => btn.classList.remove('selected'));
            const selectedIdMap = {
                key: 'key-btn',
                mode: 'mode-btn',
                octave: 'oct-btn',
                inversion: 'inv-btn',
                sounds: 'sounds-btn',
                transpose: 'transpose-knob',
                filter: 'filter-knob',
                bass: 'bass-btn',
                fader: 'vertical-fader',
                tempo: 'tempo-display'
            };
            if (state.selectedControl === 'xl') {
                document.getElementById('xl-button')?.classList.add('selected');
            } else if (state.selectedControl && selectedIdMap[state.selectedControl]) {
                const element = document.getElementById(selectedIdMap[state.selectedControl]);
                console.log('🎯 Adding selected class to:', selectedIdMap[state.selectedControl], 'element:', element);
                element?.classList.add('selected');
            }

            // Extra brown glow for OCT and INV; keep CSS white border from `.selected`
            const glow = '0 0 10px 2px rgba(78, 34, 16, 0.9)';
            const octBtn = document.getElementById('oct-btn');
            const invBtn = document.getElementById('inv-btn');
            if (state.selectedControl === 'octave') {
                octBtn.style.boxShadow = glow; octBtn.style.border = '';
            } else { octBtn.style.boxShadow = ''; octBtn.style.border = ''; }
            if (state.selectedControl === 'inversion') {
                invBtn.style.boxShadow = glow; invBtn.style.border = '';
            } else { invBtn.style.boxShadow = ''; invBtn.style.border = ''; }
        }

        function updateKnobFunctions() {
            const filterKnob = document.getElementById('filter-knob');
            const transposeKnob = document.getElementById('transpose-knob');
            
            if (state.effectsMode) {
                // Switch to effects mode
                filterKnob.querySelector('.knob-name').textContent = 'REVERB';
                transposeKnob.querySelector('.knob-name').textContent = 'DELAY';
                console.log('Switched to effects mode: REVERB + DELAY');
            } else {
                // Switch back to normal mode
                filterKnob.querySelector('.knob-name').textContent = 'HI CUT';
                transposeKnob.querySelector('.knob-name').textContent = 'TRANS\nPOSE';
                console.log('Switched to normal mode: HI CUT + TRANS/POSE');
            }
        }

        function updateReverb() {
            // Update reverb effect based on state.reverbLevel (0-10)
            if (typeof audioEngine !== 'undefined' && audioEngine.setReverb) {
                // Convert 0-10 to 0-100 for wet/dry calculation
                const wetLevel = (state.reverbLevel / 10) * 100;
                audioEngine.setReverb(wetLevel);
            }
            // Knob rotation removed - using numbers as indicators instead
        }

        function updateDelay() {
            // Update delay effect based on state.delayLevel (0-10) and current BPM
            if (typeof audioEngine !== 'undefined' && audioEngine.setDelay) {
                // Convert 0-10 to 0-100 for wet/dry calculation
                const wetLevel = (state.delayLevel / 10) * 100;
                // Pass 0 as time since delay timing is now BPM-linked internally
                audioEngine.setDelay(0, wetLevel);
            }
            // Knob rotation removed - using numbers as indicators instead
        }

        function updateChordDisplay() {
            const chordValue = document.getElementById('chord-value');
            const chordName = state.currentChord?.name || '---';
            
            // Adjust font size based on chord name length (25% larger base)
            if (chordName.length > 12) {
                chordValue.style.fontSize = '12.5px';
            } else if (chordName.length > 8) {
                chordValue.style.fontSize = '15px';
            } else {
                chordValue.style.fontSize = '20px';
            }
            
            chordValue.textContent = chordName;
            

        }

        // === FLAM INDICATOR UPDATE ===
        function updateFlamIndicator() {
            const chordInput = document.getElementById('chord-input');
            if (chordInput) {
                if (state.flamMode === 'off') {
                    chordInput.placeholder = '';
                } else {
                    chordInput.placeholder = `FLAM: ${state.flamMode.toUpperCase()}`;
                }
            }
        }

        function updateSlotIndicator() {
            const indicator = document.getElementById('slot-indicator');
            const slotNumber = document.getElementById('slot-number');
            
            if (getSlotCount() > 1) {
                indicator.classList.add('show');
                slotNumber.textContent = state.currentSlotLevel + 1;
            } else {
                indicator.classList.remove('show');
            }
        }

        function updateMIDIIndicator() {
            const dot = document.getElementById('midi-dot');
            const status = document.getElementById('midi-status');
            
            if (state.midiEnabled) {
                dot.classList.add('active');
                status.textContent = 'ON';
            } else {
                dot.classList.remove('active');
                status.textContent = 'OFF';
            }
        }



        function updateSustainIndicator() {
            // Add sustain indicator if needed
            console.log('Sustain pedal:', audioEngine.sustainPedal);
        }

        // Knob rotation functions removed - using numbers as indicators instead

        function updatePianoKeys() {
            const scaleNotes = MusicEngine.getScaleNotes(state.selectedKey, state.mode);
            const pianoSection = document.getElementById('piano-section');
            
            // Update mode class
            pianoSection.className = `piano-section mode-${state.sizeMode.toLowerCase()}`;
            
            // Update each piano key
            KEYS.forEach(note => {
                const keyElement = document.getElementById(`key-${note}`);
                if (!keyElement) return;
                
                const isInScale = state.mode === 'FREE' || scaleNotes.includes(note);
                const isDisabled = state.disabledKeys.has(note);
                const hasActiveSlot = Array.from(state.activeSlots).some(s => s.startsWith(note + '-'));
                
                // Reset classes
                keyElement.classList.remove('disabled', 'out-of-scale', 'pressed');
                
                // Keep out-of-scale visuals regardless of disabled state
                if (!isInScale) {
                    keyElement.classList.add('out-of-scale');
                }
                // Disabled should not change visuals; class used only for behavior
                if (isDisabled) {
                    keyElement.classList.add('disabled');
                }

                // Press visuals:
                // - XL: entire key goes transparent
                // - Stacked modes: transparency is per-slot only (handled by .key-slot.active)
                if (hasActiveSlot && !isDisabled && state.sizeMode === 'XL') {
                    keyElement.classList.add('pressed');
                }
                
                // Generate slots
                keyElement.innerHTML = generateKeySlots(note);
            });
        }

        function generateKeySlots(note) {
            const slotCount = getSlotCount();
            let slotsHTML = '';
            
            for (let i = 0; i < slotCount; i++) {
                const slotKey = note + '-' + i;
                const isSlotActive = state.activeSlots.has(slotKey);
                const isSlotDisabled = state.disabledSlots.has(slotKey);
                const isInScale = state.mode === 'FREE' || MusicEngine.getScaleNotes(state.selectedKey, state.mode).includes(note);
                const isKeyDisabled = state.disabledKeys.has(note);
                
                let slotClass = 'key-slot';
                if (isSlotActive && !isKeyDisabled) slotClass += ' active';
                if (isSlotDisabled) slotClass += ' disabled';
                
                // When disabled (key or slot), hide chord text but keep visuals unchanged
                const shouldShowText = isInScale && !isKeyDisabled && !isSlotDisabled;
                let displayContent = '';
                
                if (shouldShowText) {
                    // Check if we should show scale degrees instead of chord names
                    if (state.showScaleDegrees && state.mode !== 'FREE') {
                        const scaleDegreeText = getScaleDegreeText(note, state.mode);
                        if (scaleDegreeText) {
                            displayContent = `<span class="slot-text scale-degree">${scaleDegreeText}</span>`;
                        }
                    } else {
                        // Only get chord info for notes that are in scale
                        const chordType = getCurrentChordType(note, i);
                        if (chordType) { // Only proceed if we have a valid chord type
                            const chordKey = note + '-' + chordType + '-' + i;
                            const chordName = MusicEngine.getChordNameWithBass(note, chordType, chordKey, state.bassOffsets, state.useFlats);
                            
                            if (state.sizeMode === 'XL') {
                                // Add lock indicator for XL mode
                                const lock = state.slotVoicingLocks[slotKey];
                                const lockBadge = lock ? `<div style="position:absolute; top:3px; right:5px; font-size:10px; color:#c58a44;">${lock.octave} ${lock.inversion}</div>` : '';
                                
                                const splitResult = splitChordName(chordName, true);
                                if (splitResult.shouldSplit) {
                                    displayContent = `
                                        ${lockBadge}
                                        <div style="display: flex; flex-direction: column; justify-content: flex-end; align-items: center; height: 100%;">
                                            <span style="text-align: center; font-size: 12px; font-weight: 500; line-height: 1.2;">${splitResult.top}</span>
                                            <span style="text-align: center; font-size: 12px; font-weight: 500; line-height: 1.2;">${splitResult.bottom}</span>
                                    </div>
                                `;
                                } else {
                                    displayContent = `${lockBadge}<span class="slot-text">${chordName}</span>`;
                                }
                            } else {
                                const lock = state.slotVoicingLocks[slotKey];
                                const lockBadge = lock ? `<div style="position:absolute; top:3px; right:5px; font-size:10px; color:#c58a44;">${lock.octave} ${lock.inversion}</div>` : '';
                                displayContent = `${lockBadge}<span class="slot-text">${chordName}</span>`;
                            }
                        }
                    }
                }
                
                // Borders and corner rounding handled via CSS; keep inline style minimal
                const borderStyle = '';
                const borderRadius = '0';
                
                slotsHTML += `
                    <div class="${slotClass}" 
                         data-note="${note}" 
                         data-slot="${i}"
                         style="${borderStyle} border-radius: ${borderRadius};">
                        <div style="display: flex; flex-direction: column; height: 100%; justify-content: flex-end; align-items: center; padding: 4px; padding-bottom: ${slotCount === 1 ? '16px' : '4px'};">
                            ${displayContent}
                        </div>
                    </div>
                `;
            }
            
            return slotsHTML;
        }

        // Event Handlers
        function handleSlotPress(note, slotIndex) {
            console.log('🎯 handleSlotPress called with note:', note, 'slotIndex:', slotIndex);
            if (!note) return;
            
            const isInScale = state.mode === 'FREE' || MusicEngine.getScaleNotes(state.selectedKey, state.mode).includes(note);
            const isDisabled = state.disabledKeys.has(note);
            const slotKey = note + '-' + slotIndex;
            const isSlotDisabled = state.disabledSlots.has(slotKey);
            
            if (state.selectedControl === 'disable') {
                if (isSlotDisabled) {
                    state.disabledSlots.delete(slotKey);
                } else if (isDisabled) {
                    state.disabledKeys.delete(note);
                } else {
                    state.disabledSlots.add(slotKey);
                }
                updatePianoKeys();
                return;
            }
            
            // Block interactions when key or slot is disabled
            if (!isInScale || isDisabled || isSlotDisabled) return;
            
            const chordType = getCurrentChordType(note, slotIndex);
            const lock = state.slotVoicingLocks[note + '-' + slotIndex];
            const useOct = lock ? lock.octave : state.octave;
            const useInv = lock ? lock.inversion : state.inversion;
            const chord = createChord(note, chordType, useOct, useInv);
            if (!chord) return;
            
            state.lastPressed = note;
            state.activeSlots.add(slotKey);
            state.lastActiveSlot = slotKey;
            state.currentSlotLevel = slotIndex;
            
            audioEngine.stopAllVoices();
            playChord(chord, 1, slotIndex, 'user', null, useOct, useInv);
            updatePianoKeys();
        }

        function handleSlotRelease(note, slotIndex) {
            const slotKey = note + '-' + slotIndex;
            state.activeSlots.delete(slotKey);
            
            // Send MIDI NoteOffs for the chord and bass that were started on press
            try {
                const isInScale = state.mode === 'FREE' || MusicEngine.getScaleNotes(state.selectedKey, state.mode).includes(note);
                const isDisabled = state.disabledKeys.has(note);
                const isSlotDisabled = state.disabledSlots.has(slotKey);
                if (isInScale && !isDisabled && !isSlotDisabled) {
                    const chordType = getCurrentChordType(note, slotIndex);
                    const lock = state.slotVoicingLocks[note + '-' + slotIndex];
                    const useOct = lock ? lock.octave : state.octave;
                    const useInv = lock ? lock.inversion : state.inversion;
                    const chord = createChord(note, chordType, useOct, useInv);
                    if (chord && chord.notes) {
                        const transposedChordNotes = chord.notes.map(n => n + state.globalTranspose);
                        // Chords NoteOff on channel 16 (0-based 15)
                        transposedChordNotes.forEach(mn => audioEngine.sendNoteOff(mn, 15));
                        const rootIndex = KEYS.indexOf(chord.root);
                        let originalRootNote = 60 + (useOct * 12) + rootIndex + state.globalTranspose;
                        if (state.globalTranspose < 0) originalRootNote += 12;
                        const chordKey = chord.root + '-' + chord.type + '-' + slotIndex;
                        const bassOffsetSemitones = state.bassOffsets[chordKey] || 0;
                        const bassNote = MusicEngine.getBassNote(originalRootNote, bassOffsetSemitones, chord.type);
                        // Bass NoteOff on channel 15 (0-based 14)
                        audioEngine.sendNoteOff(bassNote, 14);
                    }
                }
            } catch {}

            if (!state.sustainPedal) {
                const hasOtherActiveKeys = state.activeSlots.size > 0;
                if (!hasOtherActiveKeys) {
                    audioEngine.stopAllVoices();
                }
            }
            
            updatePianoKeys();
        }

        function handlePlus() {
            // If BPM selected, plus controls tempo exclusively
            if (state.selectedControl === 'tempo') {
                setTempo(tempo + 1);
                return;
            }
            
            // Duration edit mode: adjust chord duration for all selected steps
            if (durationEditMode && durationEditSteps.size > 0) {
                const maxDuration = currentTimeSignature === "3/4" ? 6 : 8;
                let anyChanged = false;
                
                durationEditSteps.forEach(stepIndex => {
                    const step = progression[stepIndex];
                    if (step && step.chord) {
                        const oldDuration = step.chord.duration || 2;
                        const newDuration = Math.min(maxDuration, oldDuration + 1);
                        if (newDuration !== oldDuration) {
                            step.chord.duration = newDuration;
                            anyChanged = true;
                            console.log(`Duration increased: step ${stepIndex}, ${oldDuration} -> ${newDuration}`);
                        }
                    }
                });
                
                if (anyChanged) {
                    sequenceSlots[currentSequenceIndex].progression = progression.slice();
                    refreshStepSelections(); // Update display
                }
                return;
            }
            if (state.selectedControl === 'sequence') {
                // Disable sequence scrolling during playback - use text commands instead
                if (isPlaying) {
                    console.log('Sequence scrolling disabled during playback. Use text commands: SEQ2, SEQ 1,2,3');
                    showSequencerMessage('USE TEXT: SEQ2, SEQ 1,2,3', 'info');
                    return;
                }
                
                const nextIndex = (currentSequenceIndex + 1) % sequenceSlots.length; // 0..7
                const v = document.querySelector('#seq-btn .seq-value');
                if (v) v.textContent = String(nextIndex + 1);
                
                // Safe sequence switching with validation
                try {
                    const slot = sequenceSlots[nextIndex];
                    if (!slot) {
                        console.warn('Invalid sequence slot:', nextIndex);
                        return;
                    }
                    
                    // Switch immediately since we're not playing
                    currentSequenceIndex = nextIndex;
                    currentBars = Math.max(1, Math.min(8, slot.bars || 2));
                    currentTimeSignature = slot.timeSignature || "4/4";
                    currentBeatsPerBar = slot.beatsPerBar || 8;
                    tempo = Math.max(60, Math.min(300, slot.tempo || 120));
                    progression = Array.isArray(slot.progression) ? slot.progression.slice() : Array(64).fill(null).map((_, i) => ({ id: i, chord: null }));
                    
                    // Update UI
                    const tempoEl = document.getElementById('tempo-value');
                    const barsEl = document.getElementById('bars-value');
                    const timeSigEl = document.getElementById('time-signature-label');
                    const seqEl = document.querySelector('#seq-btn .seq-value');
                    if (tempoEl) tempoEl.textContent = String(tempo);
                    if (barsEl) barsEl.textContent = String(currentBars);
                    if (timeSigEl) timeSigEl.textContent = currentTimeSignature;
                    if (seqEl) seqEl.textContent = String(currentSequenceIndex + 1);
                    
                    buildStepGrid();
                } catch (error) {
                    console.error('Sequence switch error:', error);
                    // Fallback to safe values, but try to preserve sequence data if possible
                    const slot = sequenceSlots[nextIndex];
                    if (slot) {
                        currentBars = Math.max(1, Math.min(8, slot.bars || 2));
                        currentTimeSignature = slot.timeSignature || "4/4";
                        currentBeatsPerBar = slot.beatsPerBar || 8;
                        tempo = Math.max(60, Math.min(300, slot.tempo || 120));
                    } else {
                        currentBars = 2;
                        currentTimeSignature = "4/4";
                        currentBeatsPerBar = 8;
                        tempo = 120;
                    }
                    buildStepGrid();
                }
                return;
            }
            if (state.selectedControl === 'transpose') {
                if (state.effectsMode) {
                    // In effects mode, transpose knob controls delay
                    state.delayLevel = Math.min(state.delayLevel + 1, 7); // Cap at 7 to keep original sound audible
                    updateControlValues();
                    updateDelay();
                } else {
                    // Normal mode, transpose knob controls transpose
                    state.globalTranspose = Math.min(state.globalTranspose + 1, 12);
                    updateControlValues();
                }
                return;
            }
            // XL size via plus
            if (state.selectedControl === 'xl') {
                const idx = SIZE_MODES.indexOf(state.sizeMode);
                state.sizeMode = SIZE_MODES[(idx + 1) % SIZE_MODES.length];
                state.currentSlotLevel = 0;
                updateUI();
                return;
            }
            // Sounds (instrument) via plus
            if (state.selectedControl === 'sounds') {
                console.log('handlePlus: sounds selected, current sound:', state.selectedSound);
                const idx = SOUNDS.indexOf(state.selectedSound);
                const newSound = SOUNDS[(idx + 1) % SOUNDS.length];
                console.log('handlePlus: changing sound from', state.selectedSound, 'to', newSound);
                state.selectedSound = newSound;
                // Apply instrument-specific EQ settings
                audioEngine.setInstrument(state.selectedSound);
                updateControlValues();
                return;
            }
            
            if (state.selectedControl === 'filter') {
                if (state.effectsMode) {
                    // In effects mode, filter knob controls reverb
                    state.reverbLevel = Math.min(state.reverbLevel + 1, 10);
                    updateControlValues();
                    updateReverb();
                } else {
                    // Normal mode, filter knob controls filter
                    state.filterCutoff = Math.min(state.filterCutoff + 1, 10);
                    audioEngine.setFilterCutoff(state.filterCutoff);
                    updateControlValues();
                    // Knob rotation removed - using numbers as indicators instead
                }
                return;
            }
            
            if (state.selectedControl === 'bass') {
                // Ensure a target exists when selecting via keyboard
                if (!state.bassEditTarget) {
                    const targetKey = state.lastActiveSlot || (state.lastPressed ? `${state.lastPressed}-0` : null);
                    if (targetKey) {
                        state.bassEditTarget = targetKey;
                        const [tNote, tIdxStr] = targetKey.split('-');
                        const tIdx = parseInt(tIdxStr) || 0;
                        const cType = getCurrentChordType(tNote, tIdx);
                        const cKey = tNote + '-' + cType + '-' + tIdx;
                        if (state.bassOffsets[cKey] === undefined) state.bassOffsets[cKey] = 0;
                    }
                }
                cycleBassOffset('up');
                return;
            }
            
            if (!state.selectedControl && state.lastActiveSlot) {
                const parts = state.lastActiveSlot.split('-');
                const note = parts[0];
                const slotIndex = parseInt(parts[1]);
                cycleSlotChord('up', note, slotIndex);
                return;
            }
            
            if (!state.selectedControl && state.lastPressed) {
                cycleChord('up');
                return;
            }
            
            if (state.selectedControl === 'key') {
                const currentIndex = KEYS.indexOf(state.selectedKey);
                state.selectedKey = KEYS[(currentIndex + 1) % KEYS.length];
                resetOnModeChange();
            }
            if (state.selectedControl === 'mode') {
                const currentIndex = MODES.indexOf(state.mode);
                state.mode = MODES[(currentIndex + 1) % MODES.length];
                resetOnModeChange();
            }
            if (state.selectedControl === 'octave') state.octave = Math.min(state.octave + 1, 2);
            if (state.selectedControl === 'inversion') state.inversion = Math.min(state.inversion + 1, 3);
            if (state.selectedControl === 'fader') {
                console.log('🎚️ Fader plus pressed! Current value:', state.faderBlend);
                state.faderBlend = Math.min((typeof state.faderBlend === 'number' ? state.faderBlend : 0.5) + 0.1, 1.0);
                console.log('🎚️ Fader new value:', state.faderBlend);
                updateControlValues();
            }
            
            updateUI();
        }

        function handleMinus() {
            // If BPM selected, minus controls tempo exclusively
            if (state.selectedControl === 'tempo') {
                setTempo(tempo - 1);
                return;
            }
            
            // Duration edit mode: adjust chord duration for all selected steps
            if (durationEditMode && durationEditSteps.size > 0) {
                let anyChanged = false;
                
                durationEditSteps.forEach(stepIndex => {
                    const step = progression[stepIndex];
                    if (step && step.chord) {
                        const oldDuration = step.chord.duration || 2;
                        const newDuration = Math.max(1, oldDuration - 1);
                        if (newDuration !== oldDuration) {
                            step.chord.duration = newDuration;
                            anyChanged = true;
                            console.log(`Duration decreased: step ${stepIndex}, ${oldDuration} -> ${newDuration}`);
                        }
                    }
                });
                
                if (anyChanged) {
                    sequenceSlots[currentSequenceIndex].progression = progression.slice();
                    refreshStepSelections(); // Update display
                }
                return;
            }
            if (state.selectedControl === 'sequence') {
                // Disable sequence scrolling during playback - use text commands instead
                if (isPlaying) {
                    console.log('Sequence scrolling disabled during playback. Use text commands: SEQ2, SEQ 1,2,3');
                    showSequencerMessage('USE TEXT: SEQ2, SEQ 1,2,3', 'info');
                    return;
                }
                
                const nextIndex = (currentSequenceIndex - 1 + sequenceSlots.length) % sequenceSlots.length;
                const v = document.querySelector('#seq-btn .seq-value');
                if (v) v.textContent = String(nextIndex + 1);
                
                // Safe sequence switching with validation
                try {
                    const slot = sequenceSlots[nextIndex];
                    if (!slot) {
                        console.warn('Invalid sequence slot:', nextIndex);
                        return;
                    }
                    
                    // Switch immediately since we're not playing
                    currentSequenceIndex = nextIndex;
                    currentBars = Math.max(1, Math.min(8, slot.bars || 2));
                    currentTimeSignature = slot.timeSignature || "4/4";
                    currentBeatsPerBar = slot.beatsPerBar || 8;
                    tempo = Math.max(60, Math.min(300, slot.tempo || 120));
                    progression = Array.isArray(slot.progression) ? slot.progression.slice() : Array(64).fill(null).map((_, i) => ({ id: i, chord: null }));
                    
                    // Update UI
                    const tempoEl = document.getElementById('tempo-value');
                    const barsEl = document.getElementById('bars-value');
                    const timeSigEl = document.getElementById('time-signature-label');
                    const seqEl = document.querySelector('#seq-btn .seq-value');
                    if (tempoEl) tempoEl.textContent = String(tempo);
                    if (barsEl) barsEl.textContent = String(currentBars);
                    if (timeSigEl) timeSigEl.textContent = currentTimeSignature;
                    if (seqEl) seqEl.textContent = String(currentSequenceIndex + 1);
                    
                    buildStepGrid();
                } catch (error) {
                    console.error('Sequence switch error:', error);
                    // Fallback to safe values, but try to preserve sequence data if possible
                    const slot = sequenceSlots[nextIndex];
                    if (slot) {
                        currentBars = Math.max(1, Math.min(8, slot.bars || 2));
                        currentTimeSignature = slot.timeSignature || "4/4";
                        currentBeatsPerBar = slot.beatsPerBar || 8;
                        tempo = Math.max(60, Math.min(300, slot.tempo || 120));
                    } else {
                        currentBars = 2;
                        currentTimeSignature = "4/4";
                        currentBeatsPerBar = 8;
                        tempo = 120;
                    }
                    buildStepGrid();
                }
                return;
            }
            if (state.selectedControl === 'transpose') {
                if (state.effectsMode) {
                    // In effects mode, transpose knob controls delay
                    state.delayLevel = Math.max(state.delayLevel - 1, 0); // Min at 0, max at 7
                    updateControlValues();
                    updateDelay();
                } else {
                    // Normal mode, transpose knob controls transpose
                    state.globalTranspose = Math.max(state.globalTranspose - 1, -12);
                    updateControlValues();
                }
                return;
            }
            // XL size via minus
            if (state.selectedControl === 'xl') {
                const idx = SIZE_MODES.indexOf(state.sizeMode);
                state.sizeMode = SIZE_MODES[(idx - 1 + SIZE_MODES.length) % SIZE_MODES.length];
                state.currentSlotLevel = 0;
                updateUI();
                return;
            }
            // Sounds (instrument) via minus
            if (state.selectedControl === 'sounds') {
                const idx = SOUNDS.indexOf(state.selectedSound);
                state.selectedSound = SOUNDS[(idx - 1 + SOUNDS.length) % SOUNDS.length];
                // Apply instrument-specific EQ settings
                audioEngine.setInstrument(state.selectedSound);
                updateControlValues();
                return;
            }
            
            if (state.selectedControl === 'filter') {
                if (state.effectsMode) {
                    // In effects mode, filter knob controls reverb
                    state.reverbLevel = Math.max(state.reverbLevel - 1, 0);
                    updateControlValues();
                    updateReverb();
                } else {
                    // Normal mode, filter knob controls filter
                    state.filterCutoff = Math.max(state.filterCutoff - 1, 0);
                    audioEngine.setFilterCutoff(state.filterCutoff);
                    updateControlValues();
                    // Knob rotation removed - using numbers as indicators instead
                }
                return;
            }
            
            if (state.selectedControl === 'bass') {
                if (!state.bassEditTarget) {
                    const targetKey = state.lastActiveSlot || (state.lastPressed ? `${state.lastPressed}-0` : null);
                    if (targetKey) {
                        state.bassEditTarget = targetKey;
                        const [tNote, tIdxStr] = targetKey.split('-');
                        const tIdx = parseInt(tIdxStr) || 0;
                        const cType = getCurrentChordType(tNote, tIdx);
                        const cKey = tNote + '-' + cType + '-' + tIdx;
                        if (state.bassOffsets[cKey] === undefined) state.bassOffsets[cKey] = 0;
                    }
                }
                cycleBassOffset('down');
                return;
            }
            
            if (!state.selectedControl && state.lastActiveSlot) {
                const parts = state.lastActiveSlot.split('-');
                const note = parts[0];
                const slotIndex = parseInt(parts[1]);
                cycleSlotChord('down', note, slotIndex);
                return;
            }
            
            if (!state.selectedControl && state.lastPressed) {
                cycleChord('down');
                return;
            }
            
            if (state.selectedControl === 'key') {
                const currentIndex = KEYS.indexOf(state.selectedKey);
                state.selectedKey = KEYS[(currentIndex - 1 + KEYS.length) % KEYS.length];
                resetOnModeChange();
            }
            if (state.selectedControl === 'mode') {
                const currentIndex = MODES.indexOf(state.mode);
                state.mode = MODES[(currentIndex - 1 + MODES.length) % MODES.length];
                resetOnModeChange();
            }
            if (state.selectedControl === 'octave') state.octave = Math.max(state.octave - 1, -2);
            if (state.selectedControl === 'inversion') state.inversion = Math.max(state.inversion - 1, -3);
            if (state.selectedControl === 'fader') {
                const oldValue = typeof state.faderBlend === 'number' ? state.faderBlend : 0.5;
                const newValue = Math.max(oldValue - 0.1, 0.0);
                state.faderBlend = newValue;
                console.log('🎚️ Fader minus: oldValue:', oldValue, 'newValue:', newValue);
                updateControlValues();
            }
            
            updateUI();
        }

        function cycleChord(direction) {
            if (!state.lastPressed) return;
            
            const availableChords = MusicEngine.getAvailableChords(state.lastPressed, state.mode, state.selectedKey);
            if (availableChords.length === 0) return;
            
            const currentChordType = getCurrentChordType(state.lastPressed);
            const currentIndex = availableChords.indexOf(currentChordType);
            const next = direction === 'up' 
                ? (currentIndex + 1) % availableChords.length
                : (currentIndex - 1 + availableChords.length) % availableChords.length;
            
            state.chordIndices[state.lastPressed] = next;
            
            const newChordType = availableChords[next];
            const chord = createChord(state.lastPressed, newChordType);
            if (!chord) return;
            
            audioEngine.stopAllVoices();
            playChord(chord, 0.5, 0, 'user');
            updatePianoKeys();
            
            setTimeout(() => {
                audioEngine.stopAllVoices();
            }, 750);
        }

        function cycleSlotChord(direction, note, slotIndex) {
            if (!note) return;
            
            // Check if note is in scale for current mode/key
            const isInScale = state.mode === 'FREE' || MusicEngine.getScaleNotes(state.selectedKey, state.mode).includes(note);
            if (!isInScale) return; // Don't cycle chords for notes not in scale
            
            // 5-row chord level system: All slots in X mode are now editable
            // Rows 1-3 (slotIndex 0-2): Follow mode's chord scroll progression (diatonic)
            // Rows 4-5 (slotIndex 3-4): FREE mode for maximum flexibility
            
            const availableChords = MusicEngine.getAvailableChords(note, 
                (state.sizeMode === 'X' && slotIndex >= 3) ? 'FREE' : state.mode, 
                state.selectedKey);
            if (availableChords.length === 0) return;
            
            const slotKey = note + '-' + slotIndex;
            const currentChordType = getCurrentChordType(note, slotIndex);
            
            // Ensure currentChordType is valid, fallback to first available chord if not
            if (!availableChords.includes(currentChordType)) {
                state.slotChordIndices[slotKey] = 0;
                currentChordType = availableChords[0];
            }
            
            const currentIndex = availableChords.indexOf(currentChordType);
            const next = direction === 'up' 
                ? (currentIndex + 1) % availableChords.length
                : (currentIndex - 1 + availableChords.length) % availableChords.length;
            
            state.slotChordIndices[slotKey] = next;
            // Unlock voicing when chord type changes
            delete state.slotVoicingLocks[slotKey];

            const newChordType = availableChords[next];
            const chord = createChord(note, newChordType);
            if (!chord) return;
            
            audioEngine.stopAllVoices();
            playChord(chord, 0.5, slotIndex, 'user');
            updatePianoKeys();
            
            setTimeout(() => {
                audioEngine.stopAllVoices();
            }, 750);
        }

        function cycleBassOffset(direction) {
            if (!state.bassEditTarget || state.selectedControl !== 'bass') return;
            
            audioEngine.stopAllVoices();
            
            const [targetNote, targetSlotIndex] = state.bassEditTarget.split('-');
            const slotIndex = parseInt(targetSlotIndex) || 0;
            const chordType = getCurrentChordType(targetNote, slotIndex);
            const chordKey = targetNote + '-' + chordType + '-' + slotIndex;
            const currentOffset = state.bassOffsets[chordKey] || 0;
            
            const currentIndex = BASS_SEQUENCE.indexOf(currentOffset);
            let newIndex;
            
            if (direction === 'up') {
                newIndex = (currentIndex + 1) % BASS_SEQUENCE.length;
            } else {
                newIndex = (currentIndex - 1 + BASS_SEQUENCE.length) % BASS_SEQUENCE.length;
            }
            
            const newOffset = BASS_SEQUENCE[newIndex];
            state.bassOffsets[chordKey] = newOffset;
            
            if (newOffset === 0) {
                state.bassOffset = 'BASS';
            } else {
                state.bassOffset = '+' + newOffset;
            }
            
            const chord = createChord(targetNote, chordType);
            if (chord) {
                playChord(chord, 0.3, slotIndex, 'user');
                setTimeout(() => {
                    audioEngine.stopAllVoices();
                }, 2000);
            }
            
            updateControlValues();
            updatePianoKeys();
        }

        function handleBassPress() {
            if (state.selectedControl === 'bass') {
                state.selectedControl = null;
                state.bassOffset = 'BASS';
                state.bassEditTarget = null;
            } else if (state.lastPlayedChord) {
                state.selectedControl = 'bass';
                const targetKey = state.lastActiveSlot || `${state.lastPressed}-0`;
                state.bassEditTarget = targetKey;
                const chordType = getCurrentChordType(state.lastPressed, state.lastActiveSlot ? parseInt(state.lastActiveSlot.split('-')[1]) : 0);
                const chordKey = state.lastPressed + '-' + chordType + '-' + (state.lastActiveSlot ? state.lastActiveSlot.split('-')[1] : '0');
                state.bassOffsets[chordKey] = 0;
                state.bassOffset = 'BASS';
            }
            updateControlValues();
        }

        function handleSizePress() {
            const currentIndex = SIZE_MODES.indexOf(state.sizeMode);
            state.sizeMode = SIZE_MODES[(currentIndex + 1) % SIZE_MODES.length];
            state.currentSlotLevel = 0;
            updateUI();
        }

        function resetOnModeChange() {
            audioEngine.stopAllVoices();
            state.chordIndices = {};
            state.slotChordIndices = {};
            state.bassOffsets = {};
            state.currentChord = null;
            state.lastPlayedChord = null;
            state.lastPressed = null;
            state.activeKeys.clear();
            state.activeSlots.clear();
            state.lastActiveSlot = null;
            state.bassOffset = 'BASS';
            state.bassEditTarget = null;
            state.currentSlotLevel = 0;
            state.disabledSlots.clear();
        }

        // YouTube Chord Analysis
        async function analyzeYouTubeChords(url) {
            const statusEl = document.getElementById('youtubeStatus');
            const progressEl = document.getElementById('youtubeProgress');
            const progressFill = progressEl.querySelector('.progress-fill');
            const progressText = progressEl.querySelector('.progress-text');
            
            try {
                // Validate YouTube URL
                if (!url.includes('youtube.com/watch?v=')) {
                    throw new Error('Please enter a valid YouTube URL');
                }
                
                // Show progress
                progressEl.classList.remove('hidden');
                statusEl.textContent = 'Starting analysis...';
                progressFill.style.width = '10%';
                progressText.textContent = 'Extracting audio...';
                
                // Simulate API call (replace with actual backend)
                await simulateYouTubeAnalysis(progressFill, progressText);
                
                // For demo purposes, use sample chord data
                const sampleChords = [
                    'C', 'Am', 'F', 'G', 'Em', 'Dm', 'Bdim', 'F#m7b5', 'B7', 'E7',
                    'Am7', 'D7', 'G7', 'C7', 'F7', 'Bb7', 'Eb7', 'Ab7', 'Db7', 'Gb7',
                    'Cmaj7', 'Fmaj7', 'Bbmaj7', 'Ebmaj7', 'Abmaj7', 'Dbmaj7', 'Gbmaj7',
                    'Dmaj7', 'Gmaj7', 'Amaj7', 'Emaj7', 'Bmaj7', 'F#maj7', 'C#maj7',
                    'Cm', 'Fm', 'Bbm', 'Ebm', 'Abm', 'Dbm', 'Gbm', 'Dm', 'Gm', 'Am',
                    'Em', 'Bm', 'F#m', 'C#m', 'G#m', 'D#m', 'A#m', 'Fm7', 'Bbm7', 'Ebm7'
                ];
                
                // Populate chord slots
                populateChordSlots(sampleChords);
                
                statusEl.textContent = `Successfully loaded ${sampleChords.length} chords from YouTube video`;
                progressEl.classList.add('hidden');
                
            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                progressEl.classList.add('hidden');
            }
        }
        
        async function simulateYouTubeAnalysis(progressFill, progressText) {
            const steps = [
                { progress: 25, text: 'Extracting audio...' },
                { progress: 50, text: 'Converting to MP3...' },
                { progress: 75, text: 'Analyzing chords...' },
                { progress: 90, text: 'Mapping to slots...' },
                { progress: 100, text: 'Complete!' }
            ];
            
            for (const step of steps) {
                await new Promise(resolve => setTimeout(resolve, 800));
                progressFill.style.width = step.progress + '%';
                progressText.textContent = step.text;
            }
        }
        
        function populateChordSlots(chords) {
            // Clear existing chord assignments
            state.chordIndices = {};
            state.slotChordIndices = {};
            
            // Map chords to available slots (1-60)
            chords.forEach((chord, index) => {
                if (index < 60) {
                    const slotIndex = index + 1;
                    const chordKey = `slot-${slotIndex}`;
                    state.chordIndices[chordKey] = chord;
                    state.slotChordIndices[chordKey] = chord;
                }
            });
            
            // Update UI
            updateChordDisplay();
            showSequencerMessage(`Loaded ${chords.length} chords into slots`, 'success');
        }
        
        // YouTube Chord Analysis with BrowserStack + Chordify
        async function handleYouTubeAnalysis(url) {
            try {
                console.log('=== YOUTUBE ANALYSIS STARTED ===');
                console.log('URL received:', url);
                console.log('Function called successfully');
                
                // Show processing status in input field
                const chordInput = document.getElementById('chord-input');
                chordInput.placeholder = 'Processing YouTube URL...';
                chordInput.disabled = true;
                
                // Show status message
                showSequencerMessage('Analyzing YouTube video with Chordify...', 'info');
                
                // Call the real BrowserStack + Chordify API
                const response = await fetch('http://67.205.187.30:3000/api/analyze-youtube', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ youtubeURL: url })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('Chordify analysis completed:', result.data);
                    
                    // Update status
                    chordInput.placeholder = 'Creating chord palette...';
                    
                    // Create palette name from the API response
                    const paletteName = result.data.paletteName;
                    console.log('Creating palette:', paletteName);
                    
                    // Auto-import as new palette
                    const palette = createPaletteFromChords(result.data.chords, paletteName);
                    console.log('Palette created:', palette);
                    
                    // Add to saved palettes
                    if (!state.savedPalettes) {
                        state.savedPalettes = {};
                    }
                    state.savedPalettes[paletteName] = palette;
                    console.log('Palette saved to state');
                    
                    // Update palette list
                    updatePaletteList();
                    console.log('Palette list updated');
                    
                    // Show success message
                    showSequencerMessage(`Imported ${result.data.chordCount} chords as palette: ${paletteName}`, 'success');
                    
                    // Auto-load the palette
                    loadPalette(paletteName);
                    console.log('Palette loaded');
                    
                    // Show the load tab so user can see the new palette
                    showLoadTab();
                    
                    // Show final success status
                    chordInput.placeholder = `Success! ${result.data.chordCount} chords imported`;
                    
                } else {
                    throw new Error(result.error || 'Chordify analysis failed');
                }
                
            } catch (error) {
                console.error('YouTube analysis error:', error);
                showSequencerMessage(`YouTube analysis failed: ${error.message}`, 'error');
            } finally {
                // Re-enable input field
                const chordInput = document.getElementById('chord-input');
                chordInput.disabled = false;
                chordInput.focus();
            }
        }

        // Manual Login Handler - Opens BrowserStack session for manual Chordify login
        async function handleManualLogin() {
            try {
                console.log('Manual login started');
                
                // Show processing status in input field
                const chordInput = document.getElementById('chord-input');
                chordInput.placeholder = 'Opening login session...';
                chordInput.disabled = true;
                
                // Show status message
                showSequencerMessage('Opening manual login session on server...', 'info');
                
                // Call the server to open a new BrowserStack session
                const response = await fetch('http://67.205.187.30:3000/api/open-login-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('Login session opened:', result);
                    
                    // Show success message
                    showSequencerMessage('Login session opened! Check your server for the browser window.', 'success');
                    
                    // Update input field and ensure it's enabled
                    chordInput.placeholder = 'Login session active - you can now analyze YouTube URLs';
                    chordInput.disabled = false;
                    
                    // Small delay to ensure DOM updates, then focus
                    setTimeout(() => {
                        chordInput.disabled = false;
                        chordInput.focus();
                        console.log('Input field focused and ready for input');
                    }, 100);
                    
                } else {
                    throw new Error(result.error || 'Failed to open login session');
                }
                
            } catch (error) {
                console.error('Manual login error:', error);
                showSequencerMessage(`Login failed: ${error.message}`, 'error');
                chordInput.placeholder = 'Login failed - try again';
            } finally {
                chordInput.disabled = false;
                console.log('Input field re-enabled, disabled state:', chordInput.disabled);
                console.log('Input field value:', chordInput.value);
                console.log('Input field placeholder:', chordInput.placeholder);
            }
        }
        
        async function simulateYouTubeAnalysis(url) {
            // For now, just return sample data immediately
            // Later, this will call the real backend API
            console.log('Simulating YouTube analysis for:', url);
            
            // Simulate a short delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            return [
                'C', 'Am', 'F', 'G', 'Em', 'Dm', 'Bdim', 'F#m7b5', 'B7', 'E7',
                'Am7', 'D7', 'G7', 'C7', 'F7', 'Bb7', 'Eb7', 'Ab7', 'Db7', 'Gb7',
                'Cmaj7', 'Fmaj7', 'Bbmaj7', 'Ebmaj7', 'Abmaj7', 'Dbmaj7', 'Gbmaj7',
                'Dmaj7', 'Gmaj7', 'Amaj7', 'Emaj7', 'Bmaj7', 'F#maj7', 'C#maj7',
                'Cm', 'Fm', 'Bbm', 'Ebm', 'Abm', 'Dbm', 'Gbm', 'Dm', 'Gm', 'Am',
                'Em', 'Bm', 'F#m', 'C#m', 'G#m', 'D#m', 'A#m', 'Fm7', 'Bbm7', 'Ebm7'
            ];
        }
        
        function showLoadTab() {
            // Switch to the load tab in the song modal
            const loadTab = document.querySelector('[data-tab="load"]');
            const loadPanel = document.getElementById('tab-load');
            const songModal = document.getElementById('song-modal');
            
            if (loadTab && loadPanel && songModal) {
                // Remove active class from all tabs
                document.querySelectorAll('.song-tab').forEach(tab => tab.classList.remove('active'));
                // Add active class to load tab
                loadTab.classList.add('active');
                
                // Hide all panels
                document.querySelectorAll('.song-panel').forEach(panel => panel.style.display = 'none');
                // Show load panel
                loadPanel.style.display = 'block';
                
                // Open the modal if it's not already open
                if (!songModal.classList.contains('show')) {
                    songModal.classList.add('show');
                }
            }
        }
        
        function createPaletteFromChords(chords, name) {
            const palette = {
                name: name,
                chordIndices: {},
                slotChordIndices: {},
                bassOffsets: {},
                disabledKeys: [],
                disabledSlots: [],
                selectedKey: state.selectedKey || 'C',
                mode: state.mode || 'FREE',
                octave: state.octave || 0,
                inversion: state.inversion || -2
            };
            
            // Map chords to available slots (1-60)
            chords.forEach((chord, index) => {
                if (index < 60) {
                    const slotIndex = index + 1;
                    const chordKey = `slot-${slotIndex}`;
                    palette.chordIndices[chordKey] = chord;
                    palette.slotChordIndices[chordKey] = chord;
                }
            });
            
            return palette;
        }

        // Enhanced chord parsing from Palette Generator
        function parseChordSymbol(chordSymbol) {
            let chord = chordSymbol.trim();
            let bassNote = null;
            
            if (chord.includes('/')) {
                const parts = chord.split('/');
                chord = parts[0];
                bassNote = parts[1];
            }
            
            // Convert flat symbols to 'b' notation
            chord = chord.replace(/♭/g, 'b');
            if (bassNote) {
                bassNote = bassNote.replace(/♭/g, 'b');
            }
            
            let noteRoot = '';
            let remaining = chord;
            
            if (chord.length >= 2 && (chord[1] === 'b' || chord[1] === '#')) {
                noteRoot = chord.substring(0, 2);
                remaining = chord.substring(2);
            } else {
                noteRoot = chord[0] || 'C';
                remaining = chord.substring(1);
            }
            
            let chordType = 'major';
            
            // Enhanced jazz notation handling
            remaining = remaining
                .replace(/\*[Mm]aj7/g, 'maj7')
                .replace(/\*[Mm]aj9/g, 'maj9')
                .replace(/\*[Mm]aj11/g, 'maj11')
                .replace(/\*[Mm]aj13/g, 'maj13')
                .replace(/\*[Mm]aj/g, 'maj7')
                .replace(/△7/g, 'maj7')
                .replace(/△9/g, 'maj9')
                .replace(/△11/g, 'maj11')
                .replace(/△13/g, 'maj13')
                .replace(/△/g, 'maj7')
                .replace(/°7/g, 'dim7')
                .replace(/°/g, 'dim')
                .replace(/ø7/g, 'm7b5')
                .replace(/ø/g, 'm7b5')
                .replace(/Δ7/g, 'maj7')
                .replace(/Δ9/g, 'maj9')
                .replace(/Δ11/g, 'maj11')
                .replace(/Δ13/g, 'maj13')
                .replace(/Δ/g, 'maj7')
                .replace(/[Mm]aj7/g, 'maj7')
                .replace(/[Mm]aj9/g, 'maj9')
                .replace(/[Mm]aj11/g, 'maj11')
                .replace(/[Mm]aj13/g, 'maj13')
                .replace(/[Mm]aj/g, 'maj7')
                .replace(/[Mm]in/g, 'm')
                .replace(/\(/g, '')
                .replace(/\)/g, '');
            
            // Map chord qualities
            if (remaining === '' || remaining === 'maj' || remaining === 'M') {
                chordType = 'major';
            } else if (remaining === 'm' || remaining === 'min') {
                chordType = 'minor';
            } else if (remaining === 'maj7' || remaining === 'M7') {
                chordType = 'major7';
            } else if (remaining === 'maj9' || remaining === 'M9') {
                chordType = 'major9';
            } else if (remaining === 'maj11' || remaining === 'M11') {
                chordType = 'major11';
            } else if (remaining === 'maj13' || remaining === 'M13') {
                chordType = 'major13';
            } else if (remaining === 'm7') {
                chordType = 'minor7';
            } else if (remaining === 'm9') {
                chordType = 'minor9';
            } else if (remaining === 'm11') {
                chordType = 'm11';
            } else if (remaining === 'm13') {
                chordType = 'minor13';
            } else if (remaining === '7') {
                chordType = '7';
            } else if (remaining === '9') {
                chordType = '9';
            } else if (remaining === 'dim' || remaining === 'dim7') {
                chordType = 'dim7';
            } else if (remaining === 'aug') {
                chordType = 'augmented';
            } else if (remaining === '5') {
                chordType = '5';
            } else if (remaining === 'sus4' || remaining === 'sus') {
                chordType = 'sus4';
            } else if (remaining === 'sus2') {
                chordType = 'sus2';
            } else if (remaining === '6') {
                chordType = '6';
            } else if (remaining === 'm6') {
                chordType = 'minor6';
            } else if (remaining === '11') {
                chordType = '11';
            } else if (remaining === '13') {
                chordType = '13';
            } else if (remaining === 'm7b5') {
                chordType = 'm7b5';
            } else if (remaining === 'add9') {
                chordType = 'add9';
            } else if (remaining.includes('maj7') || remaining.includes('M7')) {
                chordType = 'major7';
            } else if (remaining.includes('m') && remaining.includes('7')) {
                chordType = 'minor7';
            } else if (remaining.includes('7')) {
                chordType = '7';
            } else if (remaining.includes('9')) {
                chordType = '9';
            } else if (remaining.includes('11')) {
                chordType = '11';
            } else if (remaining.includes('13')) {
                chordType = '13';
            } else if (remaining.includes('m')) {
                chordType = 'minor';
            }
            
            return { root: noteRoot, chordType, bassNote, original: chordSymbol };
        }

        // Palette Management
        function savePalette(name) {
            const palette = {
                selectedKey: state.selectedKey,
                mode: state.mode,
                octave: state.octave,
                inversion: state.inversion,
                disabledKeys: Array.from(state.disabledKeys),
                disabledSlots: Array.from(state.disabledSlots),
                bassOffsets: state.bassOffsets,
                chordIndices: state.chordIndices,
                slotChordIndices: state.slotChordIndices,
                timestamp: Date.now()
            };
            
            state.savedPalettes[name] = palette;
            updatePaletteList();
        }

        function loadPalette(name) {
            const palette = state.savedPalettes[name];
            if (!palette) return;
            
            try {
                state.selectedKey = palette.selectedKey || 'C';
                state.mode = palette.mode || 'FREE';
                state.octave = palette.octave || 0;
                state.inversion = palette.inversion || -2;
                state.disabledKeys = new Set(palette.disabledKeys || []);
                state.disabledSlots = new Set(palette.disabledSlots || []);
                state.bassOffsets = palette.bassOffsets || {};
                state.chordIndices = palette.chordIndices || {};
                state.slotChordIndices = palette.slotChordIndices || {};
                
                updateUI();
                hideSaveDropdown();
            } catch (error) {
                console.error('Error loading palette:', error);
            }
        }

        function deletePalette(name) {
            delete state.savedPalettes[name];
            updatePaletteList();
        }

        function updatePaletteList() {
            const songList = document.getElementById('song-list');
            if (!songList) {
                console.log('Song list element not found');
                return;
            }
            
            const palettes = Object.entries(state.savedPalettes || {});
            console.log('Updating palette list with:', palettes);
            
            if (palettes.length === 0) {
                songList.innerHTML = '<div style="color: #666; text-align: center; padding: 24px; font-size: 14px;">No saved palettes yet</div>';
                return;
            }
            
            songList.innerHTML = palettes.map(([name, palette]) => `
                <div class="palette-item">
                    <div class="palette-name">${name}</div>
                    <div class="palette-actions">
                        <button class="palette-btn load" onclick="loadPalette('${name}')">Load</button>
                        <button class="palette-btn delete" onclick="deletePalette('${name}')">✕</button>
                    </div>
                </div>
            `).join('');
        }

        function exportPalettes() {
            if (Object.keys(state.savedPalettes).length === 0) {
                showSequencerMessage('No palettes to export', 'info');
                return;
            }
            
            const now = new Date();
            const year = String(now.getFullYear()).slice(-2);
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            
            const markdownContent = `# Piano XL Chord Palettes

Exported on ${now.toLocaleString()}

\`\`\`json
${JSON.stringify(state.savedPalettes, null, 2)}
\`\`\`

---
*Generated by Piano XL*
`;

            document.getElementById('export-textarea').value = markdownContent;
            document.getElementById('export-modal').classList.add('show');
            hideSaveDropdown();
        }

        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
                    if (!jsonMatch) {
                        showSequencerMessage('No JSON data found in file', 'info');
                        return;
                    }

                    const importedPalettes = JSON.parse(jsonMatch[1]);
                    
                    Object.entries(importedPalettes).forEach(([name, palette]) => {
                        let finalName = name;
                        let counter = 2;
                        
                        while (state.savedPalettes[finalName]) {
                            finalName = `${name} (${counter})`;
                            counter++;
                        }
                        
                        state.savedPalettes[finalName] = palette;
                    });
                    
                    const importCount = Object.keys(importedPalettes).length;
                    showSequencerMessage(`Imported ${importCount} palette${importCount !== 1 ? 's' : ''}`, 'info');
                    updatePaletteList();
                    
                } catch (error) {
                    console.error('Import error:', error);
                    showSequencerMessage('Error parsing file', 'info');
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        function showSaveDropdown() {
            document.getElementById('save-dropdown').classList.add('show');
            updatePaletteList();
        }

        function hideSaveDropdown() {
            document.getElementById('save-dropdown').classList.remove('show');
        }

        // Keyboard handling
        const keyboardToNote = {
            'a': 'C', 's': 'D', 'd': 'E', 'f': 'F', 'g': 'G', 'h': 'A', 'j': 'B',
            'w': 'C#', 'e': 'D#', 't': 'F#', 'y': 'G#', 'u': 'A#'
        };

        let pressedKeys = new Set();
        // Track last SHIFT+note press times to detect double-typing for voicing lock
        let shiftLockLastTimes = {};

        function handleKeyDown(e) {
            console.log('🔍 handleKeyDown called:', e.key, 'target:', e.target.tagName, 'focused:', document.activeElement.tagName);
            
            // Allow keyboard shortcuts if text field is not focused or if it's a special key
            const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
            const isSpecialKey = ['Escape', 'Esc', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', '+', '-', '=', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(e.key.toLowerCase());
            
            console.log('🔍 isInputFocused:', isInputFocused, 'isSpecialKey:', isSpecialKey);
            
            if (isInputFocused && !isSpecialKey) {
                console.log('🚫 Blocking keydown - input focused and not special key');
                return;
            }
            
            const key = e.key.toLowerCase();

            // Spacebar: toggle Start/Stop when sequencer is visible
            if (key === ' ') {
                const sequencer = document.getElementById('sequencer');
                if (sequencer && !sequencer.classList.contains('hidden')) {
                    e.preventDefault();
                    if (isPlaying) {
                        handleStop();
                    } else {
                        // Always start from beginning
                        currentStep = -1;
                        handlePlay();
                    }
                    return;
                } else {
                    // If sequencer is closed, focus the chord input field
                    const chordInputEl = document.getElementById('chord-input');
                    if (chordInputEl) {
                        e.preventDefault();
                        chordInputEl.focus();
                        chordInputEl.select?.();
                        return;
                    }
                }
            }

            // 0 key or ESC key: global de-select
            if (key === '0' || key === 'Escape' || key === 'Esc') {
                // Exit duration edit mode if active
                if (durationEditMode) {
                    durationEditMode = false;
                    durationEditStep = -1;
                    durationEditSteps.clear();
                    refreshStepSelections(); // Restore chord name display
                }
                
                if (state.selectedControl === 'bass') {
                    state.bassOffset = 'BASS';
                    state.bassEditTarget = null;
                }
                if (state.selectedControl === 'sequence') {
                    document.getElementById('seq-btn')?.classList.remove('selected');
                }
                state.selectedControl = null;
                updateControlValues();
                return;
            }
            
            if (key === 'arrowup' || key === 'arrowdown') {
                e.preventDefault();
                const slotCount = getSlotCount();
                
                if (slotCount > 1) {
                    audioEngine.stopAllVoices();
                    state.activeSlots.clear();
                    
                    if (key === 'arrowup') {
                        state.currentSlotLevel = Math.max(0, state.currentSlotLevel - 1);
                    } else {
                        state.currentSlotLevel = Math.min(slotCount - 1, state.currentSlotLevel + 1);
                    }
                    updateSlotIndicator();
                }
                return;
            }

            // Left/Right selection cycling
            if (key === 'arrowleft' || key === 'arrowright') {
                e.preventDefault();
                
                // Custom scroll behavior:
                // RIGHT ARROW: INV → FADER → XL → BASS → (continues right)
                // LEFT ARROW: XL → FADER → INV → OCT → (continues left)
                
                const rightCycle = ['inversion', 'fader', 'xl', 'bass', 'filter', 'transpose', 'sounds', 'key', 'mode', 'octave'];
                const leftCycle = ['xl', 'fader', 'inversion', 'octave', 'mode', 'key', 'sounds', 'transpose', 'filter', 'bass'];
                
                console.log('🔄 Arrow key pressed:', key);
                console.log('🔄 Right cycle:', rightCycle);
                console.log('🔄 Left cycle:', leftCycle);

                if (!state.selectedControl) {
                    // Start from the beginning of each direction
                    if (key === 'arrowleft') {
                        state.selectedControl = 'xl';
                    } else {
                        // Right arrow: check if we should go to BASS after XL deselection
                        if (state.rightArrowAfterXL) {
                            state.selectedControl = 'bass';
                            state.rightArrowAfterXL = false; // Clear the flag
                        } else {
                            state.selectedControl = 'inversion';
                        }
                    }
                    updateUI();
                    return;
                }

                // Deselect conditions - when reaching the end of each direction
                if (key === 'arrowleft' && state.selectedControl === 'bass') {
                    state.selectedControl = null;
                    updateUI();
                    return;
                }
                if (key === 'arrowright' && state.selectedControl === 'xl') {
                    // Special case: after XL, go to NO SELECTION, then next press goes to BASS
                    state.selectedControl = null;
                    // Set a flag to indicate we should go to BASS next
                    state.rightArrowAfterXL = true;
                    updateUI();
                    return;
                }

                // Find current position and move to next in the appropriate cycle
                const currentCycle = key === 'arrowleft' ? leftCycle : rightCycle;
                let idx = currentCycle.indexOf(state.selectedControl);
                
                console.log('🔍 Current control:', state.selectedControl, 'found at index:', idx, 'in', key, 'cycle');
                
                if (idx === -1) {
                    // If current control not in cycle, start from beginning
                    idx = 0;
                    console.log('🔍 Control not found, starting at index 0');
                } else {
                    // Move to next in cycle
                    const oldIdx = idx;
                    idx = (idx + 1) % currentCycle.length;
                    console.log('🔍 Moving from index', oldIdx, 'to index', idx, '(cycle length:', currentCycle.length, ')');
                }
                
                state.selectedControl = currentCycle[idx];
                console.log('🎯 Selected control:', state.selectedControl, 'index:', idx, 'direction:', key);
                
                if (state.selectedControl === 'fader') {
                    console.log('🎚️ FADER SELECTED! Checking element...');
                    const faderElement = document.getElementById('vertical-fader');
                    console.log('🎚️ Fader element found:', faderElement);
                }
                updateUI();
                return;
            }
            
            // Only prevent default for piano keys and plus/minus when text field is not focused
            const chordInput = document.getElementById('chord-input');
            const isTextFieldFocused = chordInput && document.activeElement === chordInput;
            
            if (keyboardToNote[key] || (!isTextFieldFocused && (key === '-' || key === '=' || key === '+'))) {
                e.preventDefault();
            }
            
            if (keyboardToNote[key] && !pressedKeys.has(key)) {
                console.log('🎹 Piano key pressed:', key, 'note:', keyboardToNote[key]);
                const note = keyboardToNote[key];
                // SHIFT + double-type on the same piano key → bake current OCT/INV to current slot
                if (e.shiftKey) {
                    const now = performance.now();
                    const last = shiftLockLastTimes[note] || 0;
                    shiftLockLastTimes[note] = now;
                    if (now - last < 500) {
                        const slotIndex = state.currentSlotLevel || 0;
                        const lockKey = note + '-' + slotIndex;
                        state.slotVoicingLocks[lockKey] = { octave: state.octave, inversion: state.inversion };
                        if (typeof updatePianoKeys === 'function') updatePianoKeys();
                        if (typeof showSequencerMessage === 'function') {
                            showSequencerMessage(`<b style=\"color:#fff;\">LOCKED ${state.octave} ${state.inversion}</b>`);
                        }
                        // Do not trigger play on lock gesture
                        return;
                    }
                }
                const isInScale = state.mode === 'FREE' || MusicEngine.getScaleNotes(state.selectedKey, state.mode).includes(note);
                const isDisabled = state.disabledKeys.has(note);
                
                if (isInScale && !isDisabled) {
                pressedKeys.add(key);
                console.log('🎹 Calling handleSlotPress for note:', note, 'slot:', state.currentSlotLevel);
                handleSlotPress(note, state.currentSlotLevel);
                }
            }
            
            if (key === '-') {
                // Only handle minus if text field is not focused
                const chordInput = document.getElementById('chord-input');
                if (!chordInput || document.activeElement !== chordInput) {
                    // Prevent default to avoid text field interference
                    e.preventDefault();
                    // Keyboard minus with scroll acceleration (same as on-screen button)
                    startKeyboardScroll('minus');
                }
            } else if (key === '=' || key === '+') {
                // Only handle plus if text field is not focused
                const chordInput = document.getElementById('chord-input');
                if (!chordInput || document.activeElement !== chordInput) {
                    // Prevent default to avoid text field interference
                    e.preventDefault();
                    // Keyboard plus with scroll acceleration (same as on-screen button)
                    startKeyboardScroll('plus');
                }
            }
        }

        // Keyboard scroll acceleration (same as on-screen buttons)
        let keyboardScrollTimer = null;
        let keyboardScrollAccelerationTimer = null;
        let keyboardScrollActive = false;
        
        function startKeyboardScroll(direction) {
            // Prevent multiple scrolls from starting
            if (keyboardScrollActive) {
                console.log(`Keyboard scroll already active, ignoring ${direction}`);
                return;
            }
            
            // Stop any existing scroll
            stopKeyboardScroll();
            
            keyboardScrollActive = true;
            console.log(`Starting keyboard scroll: ${direction}`);
            
            // Immediate first action (same as on-screen buttons)
            if (direction === 'plus') {
                handlePlus();
            } else {
                handleMinus();
            }
            
            let currentDelay = 300; // Start with normal speed (same as on-screen buttons)
            
            // Start continuous scroll after initial delay
            keyboardScrollTimer = setTimeout(() => {
                // Start the continuous interval
                keyboardScrollTimer = setInterval(() => {
                    console.log(`Keyboard ${direction} pressed - selectedControl:`, state.selectedControl);
                    if (direction === 'plus') {
                        handlePlus();
                    } else {
                        handleMinus();
                    }
                }, currentDelay);
            }, currentDelay); // Wait 300ms before starting continuous scroll
            
            // Accelerate after 1.5 seconds (same as on-screen buttons)
            keyboardScrollAccelerationTimer = setTimeout(() => {
                console.log(`Keyboard ${direction} accelerating`);
                clearInterval(keyboardScrollTimer);
                currentDelay = 100; // Faster speed (same as on-screen buttons)
                keyboardScrollTimer = setInterval(() => {
                    console.log(`Keyboard ${direction} pressed (accelerated) - selectedControl:`, state.selectedControl);
                    if (direction === 'plus') {
                        handlePlus();
                    } else {
                        handleMinus();
                    }
                }, currentDelay);
            }, 1500);
        }
        
        function stopKeyboardScroll() {
            if (keyboardScrollTimer) {
                // Clear both setTimeout and setInterval
                clearTimeout(keyboardScrollTimer);
                clearInterval(keyboardScrollTimer);
                keyboardScrollTimer = null;
            }
            if (keyboardScrollAccelerationTimer) {
                clearTimeout(keyboardScrollAccelerationTimer);
                keyboardScrollAccelerationTimer = null;
            }
            keyboardScrollActive = false;
            console.log('Keyboard scroll stopped');
        }

        function handleKeyUp(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            const key = e.key.toLowerCase();
            
            // Stop keyboard scroll when plus/minus keys are released
            if (key === '-' || key === '=' || key === '+') {
                stopKeyboardScroll();
                return;
            }
            
            if (keyboardToNote[key]) {
                const note = keyboardToNote[key];
                pressedKeys.delete(key);
                handleSlotRelease(note, state.currentSlotLevel);
            }
        }

        // Image handling
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    state.backgroundImage = event.target.result;
                    const img = document.getElementById('background-image');
                    const overlay = document.getElementById('background-overlay');
                    img.src = state.backgroundImage;
                    img.style.display = 'block';
                    overlay.style.display = 'block';
                    try { localStorage.setItem('pianoXL:bg', state.backgroundImage); } catch {}
                };
                reader.readAsDataURL(file);
            }
        }

        function removeBackgroundImage() {
            state.backgroundImage = null;
            const img = document.getElementById('background-image');
            const overlay = document.getElementById('background-overlay');
            img.style.display = 'none';
            overlay.style.display = 'none';
            
            // Also clear preset skins from body
            document.body.style.backgroundImage = '';
            
            // Clear saved skin preference
            try { 
                localStorage.removeItem('pianoXL:bg'); 
                localStorage.removeItem('pianoxl-skin');
            } catch {}
            
            // Reset skin cycling to start from first image (27.jpg)
            if (window.resetSkinCycle) {
                window.resetSkinCycle();
            }
        }

        // === RECORDING FUNCTIONS ===
        function startRecording() {
            if (state.isRecording) return;
            
            state.isRecording = true;
            state.recordingStartTime = Date.now();
            state.recordingDuration = 0;
            state.recordingData = [];
            state.recordingState = 'recording';
            
            // Stop all voices before recording to prevent stuck notes
            audioEngine.stopAllVoices();
            
            // Blur text field so keyboard shortcuts work
            blurTextField();
            
            // Also ensure text field is not focused
            const textField = document.getElementById('chord-input');
            if (textField && document.activeElement === textField) {
                textField.blur();
            }
            
            // Initialize audio recording
            try {
                // Check if audio engine is ready
                if (!audioEngine.audioContext || !audioEngine.masterGain) {
                    throw new Error('Audio engine not initialized');
                }
                
                // Create a MediaStreamDestination to capture audio
                const destination = audioEngine.audioContext.createMediaStreamDestination();
                
                // Connect the master gain to the recording destination
                audioEngine.masterGain.connect(destination);
                
                // Check supported MIME types
                let mimeType = 'audio/webm';
                if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    mimeType = 'audio/webm;codecs=opus';
                } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                    mimeType = 'audio/webm';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    mimeType = 'audio/mp4';
                }
                
                console.log('Using MIME type:', mimeType);
                
                // Create MediaRecorder
                const mediaRecorder = new MediaRecorder(destination.stream, {
                    mimeType: mimeType
                });
                state.mediaRecorder = mediaRecorder;
                
                // Collect audio data
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        state.recordingData.push(event.data);
                    }
                };
                
                // Start recording
                mediaRecorder.start(100); // Collect data every 100ms
                
            } catch (error) {
                console.error('Failed to start recording:', error);
                console.error('Error details:', error.message);
                state.isRecording = false;
                updateTextField("Recording failed: " + error.message);
                enableTextField(); // Re-enable text field on error
                return;
            }
            
            // Start recording timer
            state.recordingTimer = setInterval(() => {
                state.recordingDuration = Date.now() - state.recordingStartTime;
                const remainingSeconds = Math.max(0, 60 - Math.floor(state.recordingDuration / 1000));
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                updateTextField(`REC ${timeString}`);
                
                // Auto-stop at 1 minute
                if (remainingSeconds === 0) {
                    stopRecording();
                }
            }, 100);
            
            console.log('Recording started');
        }

        function stopRecording() {
            if (!state.isRecording) return;
            
            state.isRecording = false;
            clearInterval(state.recordingTimer);
            state.recordingTimer = null;
            
            // Stop MediaRecorder
            if (state.mediaRecorder && state.mediaRecorder.state === 'recording') {
                state.mediaRecorder.stop();
            }
            
            state.recordingState = 'prompt';
            enableTextField(); // Re-enable text field for user input
            updateTextField("Save? 'Y' or 'N'");
            
            console.log('Recording stopped');
        }

        function updateTextField(text) {
            const textField = document.getElementById('chord-input');
            if (textField) {
                textField.value = text;
                // Auto-select all text for easy replacement
                textField.select();
            }
        }
        
        function blurTextField() {
            const textField = document.getElementById('chord-input');
            if (textField) {
                // Clear the text field first
                textField.value = '';
                // Force blur multiple ways
                textField.blur();
                if (document.activeElement === textField) {
                    document.activeElement.blur();
                }
                // Remove focus completely
                if (document.activeElement && document.activeElement.blur) {
                    document.activeElement.blur();
                }
                // Disable the text field during recording to prevent keyboard capture
                textField.disabled = true;
            }
        }
        
        function enableTextField() {
            const textField = document.getElementById('chord-input');
            if (textField) {
                textField.disabled = false;
            }
        }

        function processRecordingInput(input) {
            const lowerInput = input.toLowerCase().trim();
            
            if (state.recordingState === 'prompt') {
                if (lowerInput === 'y') {
                    state.recordingState = 'naming';
                    // Temporarily disable keyboard shortcuts during naming
                    document.removeEventListener('keydown', handleKeyDown);
                    updateTextField("Enter filename:");
                } else if (lowerInput === 'n') {
                    discardRecording();
                }
            } else if (state.recordingState === 'naming') {
                if (input.trim()) {
                    exportRecording(input.trim());
                }
            }
        }

        function discardRecording() {
            state.recordingState = 'idle';
            state.recordingData = [];
            updateTextField("");
            // Re-enable keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);
            console.log('Recording discarded');
        }

        function exportRecording(filename) {
            state.recordingState = 'exporting';
            updateTextField("Exporting...");
            
            try {
                // Convert WebM to WAV using Web Audio API
                const audioBlob = new Blob(state.recordingData, { type: 'audio/webm' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Create audio context for conversion
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createBufferSource();
                
                fetch(audioUrl)
                    .then(response => response.arrayBuffer())
                    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        // Convert to WAV
                        const wavBlob = createWAVBlob(audioBuffer);
                        const wavUrl = URL.createObjectURL(wavBlob);
                        
                        // Create download link
                        const a = document.createElement('a');
                        a.href = wavUrl;
                        a.download = `${filename}.wav`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(wavUrl);
                        URL.revokeObjectURL(audioUrl);
                        
                        // Reset state
                        state.recordingState = 'idle';
                        state.recordingData = [];
                        state.mediaRecorder = null;
                        updateTextField("");
                        // Re-enable keyboard shortcuts
                        document.addEventListener('keydown', handleKeyDown);
                        
                        console.log(`Recording exported as ${filename}.wav`);
                    })
                    .catch(error => {
                        console.error('WAV conversion failed:', error);
                        updateTextField("Export failed");
                        state.recordingState = 'idle';
                        document.addEventListener('keydown', handleKeyDown);
                    });
                
            } catch (error) {
                console.error('Export failed:', error);
                updateTextField("Export failed");
                state.recordingState = 'idle';
                // Re-enable keyboard shortcuts
                document.addEventListener('keydown', handleKeyDown);
            }
        }

        function createWAVBlob(audioBuffer) {
            // Convert AudioBuffer to WAV
            const sampleRate = audioBuffer.sampleRate;
            const numberOfChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const buffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
            const view = new DataView(buffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numberOfChannels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * numberOfChannels * 2, true);
            
            // Convert float32 to int16 (interleaved)
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = audioBuffer.getChannelData(channel)[i];
                    const intSample = Math.max(-1, Math.min(1, sample));
                    view.setInt16(offset, intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }

        // Page visibility handler for stability
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && isPlaying) {
                console.log('Page hidden, stopping sequencer for stability');
                handleStop();
            }
        });
        
        // Global error handler for stability
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
            if (isPlaying) {
                console.log('Error occurred while playing, cleaning up sequencer');
                cleanupSequencer();
            }
        });
        
        // Make cleanup function globally available for debugging
        window.cleanupSequencer = cleanupSequencer;
        
        // Debug: Test if script is running
        console.log('🚀 Script loaded and running');
        
        // Event Listeners
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🚀 DOMContentLoaded event fired');
            
            try {
                // Reset recording state to ensure chord typing works
                state.recordingState = 'idle';
                
                // Initialize audio engine
                console.log('🔍 About to initialize audio engine...');
                state.midiEnabled = await audioEngine.initialize();
                console.log('✅ Audio engine initialized, MIDI enabled:', state.midiEnabled);
                
                audioEngine.setFilterCutoff(state.filterCutoff);
            
                            // Initialize instrument settings
                audioEngine.setInstrument(state.selectedSound);
                
                // Set up MIDI callbacks
                audioEngine.setMidiCallbacks((note, isOn, velocity) => {
                    if (isOn) {
                        handleSlotPress(note, state.currentSlotLevel);
                    } else {
                        handleSlotRelease(note, state.currentSlotLevel);
                    }
                });
                
                // Initialize UI
                updateUI();
                
                // Control button events
                document.getElementById('bass-btn').addEventListener('click', handleBassPress);
            } catch (error) {
                console.error('❌ Error during app initialization:', error);
            }
            

            // Sequencer controls
            document.getElementById('play-btn').addEventListener('click', handlePlay);
            document.getElementById('stop-btn').addEventListener('click', handleStop);
            // Long-press STOP to CLEAR (1 second)
            (function wireStopLongPress(){
                const stopBtn = document.getElementById('stop-btn');
                if (!stopBtn) return;
                let timer = null;
                const start = (e) => { e.preventDefault(); timer = setTimeout(handleClear, 1000); };
                const cancel = () => { if (timer) { clearTimeout(timer); timer = null; } };
                stopBtn.addEventListener('mousedown', start);
                stopBtn.addEventListener('touchstart', start);
                stopBtn.addEventListener('mouseup', cancel);
                stopBtn.addEventListener('mouseleave', cancel);
                stopBtn.addEventListener('touchend', cancel);
                stopBtn.addEventListener('touchcancel', cancel);
            })();
            // Remove old cycle-on-click behavior from BPM
            const barsDisplay = document.getElementById('bars-display');
            if (barsDisplay) {
                barsDisplay.addEventListener('click', () => {
                    switch(currentBars) {
                        case 1: currentBars = 2; break;
                        case 2: currentBars = 3; break;
                        case 3: currentBars = 4; break;
                        case 4: currentBars = 5; break;
                        case 5: currentBars = 6; break;
                        case 6: currentBars = 7; break;
                        case 7: currentBars = 8; break;
                        case 8: currentBars = 1; break;
                        default: currentBars = 2;
                    }
                    // Persist the new bar count to the current sequence slot
                    sequenceSlots[currentSequenceIndex].bars = currentBars;
                    document.getElementById('bars-value').textContent = currentBars;
                    buildStepGrid();
                    if (isPlaying) handleStop();
                });
                
                // Long-press to open time signature modal
                let barsLongPressTimer = null;
                barsDisplay.addEventListener('mousedown', (e) => {
                    barsLongPressTimer = setTimeout(() => {
                        openTimeSignatureModal();
                    }, 500);
                });
                barsDisplay.addEventListener('mouseup', () => {
                    if (barsLongPressTimer) {
                        clearTimeout(barsLongPressTimer);
                        barsLongPressTimer = null;
                    }
                });
                barsDisplay.addEventListener('mouseleave', () => {
                    if (barsLongPressTimer) {
                        clearTimeout(barsLongPressTimer);
                        barsLongPressTimer = null;
                    }
                });
                
                // Touch events for mobile
                barsDisplay.addEventListener('touchstart', (e) => {
                    barsLongPressTimer = setTimeout(() => {
                        openTimeSignatureModal();
                    }, 500);
                });
                barsDisplay.addEventListener('touchend', () => {
                    if (barsLongPressTimer) {
                        clearTimeout(barsLongPressTimer);
                        barsLongPressTimer = null;
                    }
                });
                barsDisplay.addEventListener('touchcancel', () => {
                    if (barsLongPressTimer) {
                        clearTimeout(barsLongPressTimer);
                        barsLongPressTimer = null;
                    }
                });
            }
            // BPM selection (white border) and bars work with +/- keys
            const tempoDisplay = document.getElementById('tempo-display');
            if (tempoDisplay) tempoDisplay.addEventListener('click', () => {
                // Toggle BPM selection; when selected, +/- controls tempo only
                state.selectedControl = state.selectedControl === 'tempo' ? null : 'tempo';
                
                // If selecting BPM, exit duration edit mode (only one can be selected at a time)
                if (state.selectedControl === 'tempo' && durationEditMode) {
                    durationEditMode = false;
                    durationEditStep = -1;
                    durationEditSteps.clear();
                    refreshStepSelections(); // Restore chord name display
                }
                
                updateControlValues();
            });
            const tapBtn = document.getElementById('tap-btn');
            if (tapBtn) tapBtn.addEventListener('click', handleTapTempo);

            // Tabs in song modal
            const panels = {
                save: document.getElementById('tab-save'),
                load: document.getElementById('tab-load'),
                json: document.getElementById('tab-json'),
                midi: document.getElementById('tab-midi'),
            };
            document.querySelectorAll('.song-tab').forEach(btn => {
                btn.addEventListener('click', ()=>{
                    document.querySelectorAll('.song-tab').forEach(b=>b.classList.remove('active'));
                    btn.classList.add('active');
                    Object.values(panels).forEach(p=>p.style.display='none');
                    const key = btn.getAttribute('data-tab');
                    if (panels[key]) panels[key].style.display='block';
                });
            });

            // Save song
            document.getElementById('song-save').addEventListener('click', async () => {
                const name = (document.getElementById('song-name').value || '').trim();
                if (!name) return showSequencerMessage('Enter a song name', 'info');
                const song = serializeSong(name);
                try {
                    await persistSong(song);
                    showSequencerMessage('Saved', 'info');
                    await refreshSongList();
                } catch (error) {
                    showSequencerMessage('Save failed', 'info');
                    console.error('Save error:', error);
                }
            });

            // Load list
            async function refreshSongList(){
                const list = document.getElementById('song-list');
                const map = await getAllSongs();
                const names = Object.keys(map).sort();
                list.innerHTML = names.map(n => `
                    <div class="song-item">
                        <div class="song-name">${n}</div>
                        <div class="song-actions">
                            <button class="song-btn" data-act="load" data-name="${n}">Load</button>
                            <button class="song-btn" data-act="rename" data-name="${n}">Rename</button>
                            <button class="song-btn" data-act="delete" data-name="${n}">Delete</button>
                        </div>
                    </div>`).join('');
                list.querySelectorAll('button').forEach(b=>{
                    b.addEventListener('click', async (e)=>{
                        const name = b.getAttribute('data-name');
                        const act = b.getAttribute('data-act');
                        if (act === 'load') {
                            const map = await getAllSongs();
                            const song = map[name];
                            if (song) { loadSong(song); closeSongModal(); }
                        } else if (act === 'rename') {
                            // Create inline rename input
                            const songItem = b.closest('.song-item');
                            const songNameDiv = songItem.querySelector('.song-name');
                            const originalName = songNameDiv.textContent;
                            
                            // Create input field
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.value = originalName;
                            input.className = 'rename-input';
                            input.style.cssText = 'width: 100%; padding: 2px; border: 1px solid #666; background: #333; color: white;';
                            
                            // Replace name with input
                            songNameDiv.innerHTML = '';
                            songNameDiv.appendChild(input);
                            input.focus();
                            input.select();
                            
                            // Handle input events
                            const handleRename = async () => {
                                const newName = input.value.trim();
                                if (newName && newName !== originalName) {
                                    await renameSong(originalName, newName);
                                    await refreshSongList();
                                    showSequencerMessage(`Renamed to: ${newName}`, 'info');
                                } else {
                                    await refreshSongList(); // Restore original
                                }
                            };

                            input.addEventListener('blur', handleRename);
                            input.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') {
                                    handleRename();
                                } else if (e.key === 'Escape') {
                                    refreshSongList(); // Restore original
                                }
                            });
                        } else if (act === 'delete') {
                            await deleteSong(name);
                            await refreshSongList();
                        }
                    });
                });
            }
            refreshSongList();

            // Import/Export JSON
            document.getElementById('song-import-btn').addEventListener('click', ()=> document.getElementById('song-import').click());
            document.getElementById('song-import').addEventListener('change', (e)=>{
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = async () => {
                    try {
                        let text = String(reader.result || '');
                        // Support .md wrapped JSON: extract first ```json ... ``` block if present
                        const mdMatch = text.match(/```json[\s\S]*?```/i);
                        if (mdMatch) {
                            text = mdMatch[0].replace(/```json/i,'').replace(/```/,'').trim();
                        }
                        const json = JSON.parse(text);
                        // If imported file is a palette map (name→palette), create one song per entry
                        if (!json.meta && !json.sequences && typeof json === 'object' && !Array.isArray(json)) {
                            const entries = Object.entries(json);
                            let count = 0;
                            for (const [name, pal] of entries) {
                                if (!pal || typeof pal !== 'object') continue;
                                const s = serializeSong(name);
                // Map palette fields into song (ensure ALL_CHORD_TYPES index mapping is identical to legacy)
                                s.settings.selectedKey = pal.selectedKey ?? s.settings.selectedKey;
                                s.settings.mode = pal.mode ?? s.settings.mode;
                                s.settings.octave = pal.octave ?? s.settings.octave;
                                s.settings.inversion = pal.inversion ?? s.settings.inversion;
                                s.palette.disabledKeys = pal.disabledKeys ?? [];
                                s.palette.disabledSlots = pal.disabledSlots ?? [];
                s.palette.bassOffsets = pal.bassOffsets ?? {};
                s.palette.chordIndices = pal.chordIndices ?? {};
                // If the palette used a numeric index mapping against a different order, attempt to realign by names when possible
                s.palette.slotChordIndices = pal.slotChordIndices ?? {};
                                await persistSong(s); count++;
                            }
                            await refreshSongList();
                            showSequencerMessage(`Imported ${count} song${count===1?'':'s'} from palettes`, 'info');
                            return;
                        }
                        loadSong(json);
                        await persistSong(json);
                        // Update Load tab immediately and switch to it
                        try { if (typeof refreshSongList === 'function') await refreshSongList(); } catch {}
                        const panels = { save: document.getElementById('tab-save'), load: document.getElementById('tab-load'), json: document.getElementById('tab-json'), midi: document.getElementById('tab-midi') };
                        document.querySelectorAll('.song-tab').forEach(b=>{
                            const isLoad = b.getAttribute('data-tab') === 'load';
                            if (isLoad) b.classList.add('active'); else b.classList.remove('active');
                        });
                        Object.values(panels).forEach(p=>{ if (p) p.style.display = 'none'; });
                        if (panels.load) panels.load.style.display = 'block';
                        showSequencerMessage('Imported', 'info');
                    } catch { showSequencerMessage('Invalid JSON/MD', 'info'); }
                };
                reader.readAsText(file);
                // Allow re-importing the same file without a page refresh
                e.target.value = '';
            });
            document.getElementById('song-export-btn').addEventListener('click', ()=>{
                const name = (document.getElementById('song-name').value || 'Song');
                const song = serializeSong(name);
                const md = `# ${name}\n\nExported on ${new Date().toLocaleString()}\n\n\`\`\`json\n${JSON.stringify(song, null, 2)}\n\`\`\`\n\n---\n*Generated by Piano XL*\n`;
                const blob = new Blob([md], { type: 'text/markdown' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `${name}.md`;
                a.click();
                URL.revokeObjectURL(a.href);
            });



            // Export MIDI (selected sequences)
            document.getElementById('song-export-midi').addEventListener('click', ()=>{
                const checks = Array.from(document.querySelectorAll('.seq-check'));
                checks.forEach(chk => { if (chk.checked) exportSequenceToMIDI(parseInt(chk.value)); });
            });
            document.getElementById('filter-knob').addEventListener('click', () => {
                // Only toggle selection if no long-press toggle occurred
                if (!state.longPressToggleExecuted) {
                    state.selectedControl = state.selectedControl === 'filter' ? null : 'filter';
                    updateControlValues();
                }
                state.longPressToggleExecuted = false; // Reset flag
            });
            document.getElementById('filter-knob').addEventListener('mousedown', function(e) {
                e.preventDefault();
                const timer = setTimeout(() => {
                    // Toggle both knobs to effects mode
                    state.effectsMode = !state.effectsMode;
                    updateKnobFunctions();
                    updateControlValues();
                    // Auto-select this knob after toggle for immediate editing
                    state.selectedControl = 'filter';
                    updateControlValues();
                    // Set flag to prevent click from de-selecting
                    state.longPressToggleExecuted = true;
                }, 1000);
                const handleMouseUp = () => {
                    clearTimeout(timer);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                document.addEventListener('mouseup', handleMouseUp);
            });

            document.getElementById('transpose-knob').addEventListener('click', () => {
                // Only toggle selection if no long-press toggle occurred
                if (!state.longPressToggleExecuted) {
                    state.selectedControl = state.selectedControl === 'transpose' ? null : 'transpose';
                    updateControlValues();
                }
                state.longPressToggleExecuted = false; // Reset flag
            });
            document.getElementById('transpose-knob').addEventListener('mousedown', function(e) {
                e.preventDefault();
                const timer = setTimeout(() => {
                    // Toggle both knobs to effects mode
                    state.effectsMode = !state.effectsMode;
                    updateKnobFunctions();
                    updateControlValues();
                    // Auto-select this knob after toggle for immediate editing
                    state.selectedControl = 'transpose';
                    updateControlValues();
                    // Set flag to prevent click from de-selecting
                    state.longPressToggleExecuted = true;
                }, 1000);
                const handleMouseUp = () => {
                    clearTimeout(timer);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                document.addEventListener('mouseup', handleMouseUp);
            });
            document.getElementById('sounds-btn').addEventListener('click', () => {
                // First click selects; second click de-selects. Value changes only via +/-
                if (state.selectedControl !== 'sounds') {
                    state.selectedControl = 'sounds';
                } else {
                    state.selectedControl = null;
                }
                updateControlValues();
            });
            document.getElementById('key-btn').addEventListener('click', function(e) {
                if (!state.longPressExecuted) {
                    state.selectedControl = state.selectedControl === 'key' ? null : 'key';
                    updateControlValues();
                }
                state.longPressExecuted = false;
            });
            document.getElementById('key-btn').addEventListener('mousedown', function(e) {
                e.preventDefault();
                const timer = setTimeout(() => {
                    state.longPressExecuted = true;
                    state.useFlats = !state.useFlats;
                    updateControlValues();
                }, 500);
                const handleMouseUp = () => {
                    clearTimeout(timer);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                document.addEventListener('mouseup', handleMouseUp);
            });
            document.getElementById('mode-btn').addEventListener('click', function(e) {
                if (!state.longPressExecuted) {
                    state.selectedControl = state.selectedControl === 'mode' ? null : 'mode';
                    updateControlValues();
                }
                state.longPressExecuted = false;
            });
            document.getElementById('mode-btn').addEventListener('mousedown', function(e) {
                e.preventDefault();
                const timer = setTimeout(() => {
                    state.longPressExecuted = true;
                    if (state.mode === 'FREE') {
                        resetOnModeChange();
                    } else {
                        state.mode = 'FREE';
                        resetOnModeChange();
                    }
                    state.selectedControl = null;
                    updateUI();
                }, 500);
                const handleMouseUp = () => {
                    clearTimeout(timer);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                document.addEventListener('mouseup', handleMouseUp);
            });
            document.getElementById('oct-btn').addEventListener('click', () => {
                state.selectedControl = state.selectedControl === 'octave' ? null : 'octave';
                updateControlValues();
            });
            document.getElementById('inv-btn').addEventListener('click', () => {
                state.selectedControl = state.selectedControl === 'inversion' ? null : 'inversion';
                updateControlValues();
            });
            
            // XL button
            document.getElementById('xl-button').addEventListener('click', () => {
                // First click selects; second click de-selects. Size changes only via +/-
                if (state.selectedControl !== 'xl') {
                    state.selectedControl = 'xl';
                    updateControlValues();
                } else {
                    state.selectedControl = null;
                    updateControlValues();
                }
            });
            
            // Plus/Minus buttons
            // Individual click functionality
            document.getElementById('plus-btn').addEventListener('click', () => {
                handlePlus();
            });
            
            document.getElementById('minus-btn').addEventListener('click', () => {
                handleMinus();
            });
            
            // Plus/Minus buttons with continuous hold functionality and acceleration
            document.getElementById('plus-btn').addEventListener('mousedown', () => {
                let timer;
                let currentDelay = 300; // Start with normal speed
                
                // Start continuous increment
                timer = setInterval(() => {
                    console.log('Plus button pressed - selectedControl:', state.selectedControl);
                    handlePlus();
                }, currentDelay);
                
                // Accelerate after 1.5 seconds
                const accelerationTimer = setTimeout(() => {
                    clearInterval(timer);
                    currentDelay = 100; // Faster speed
                    timer = setInterval(() => {
                        console.log('Plus button pressed (accelerated) - selectedControl:', state.selectedControl);
                        handlePlus();
                    }, currentDelay);
                }, 1500);
                
                // Stop on mouse up
                const handleMouseUp = () => {
                    clearInterval(timer);
                    clearTimeout(accelerationTimer);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                document.addEventListener('mouseup', handleMouseUp);
            });
            
            document.getElementById('minus-btn').addEventListener('mousedown', () => {
                let timer;
                let currentDelay = 300; // Start with normal speed
                
                // Start continuous decrement
                timer = setInterval(() => {
                    console.log('Minus button pressed - selectedControl:', state.selectedControl);
                    handleMinus();
                }, currentDelay);
                
                // Accelerate after 1.5 seconds
                const accelerationTimer = setTimeout(() => {
                    clearInterval(timer);
                    currentDelay = 100; // Faster speed
                    timer = setInterval(() => {
                        console.log('Minus button pressed (accelerated) - selectedControl:', state.selectedControl);
                        handleMinus();
                    }, currentDelay);
                }, 1500);
                
                // Stop on mouse up
                const handleMouseUp = () => {
                    clearInterval(timer);
                    clearTimeout(accelerationTimer);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                document.addEventListener('mouseup', handleMouseUp);
            });
            
            // Sequence button: toggle selection; +/- cycles 1..8 when selected
            (function wireSequenceSelection(){
                const seqBtn = document.getElementById('seq-btn');
                if (!seqBtn) return;
                seqBtn.addEventListener('click', () => {
                    if (state.selectedControl === 'sequence') {
                        state.selectedControl = null;
                        seqBtn.classList.remove('selected');
                    } else {
                        state.selectedControl = 'sequence';
                        seqBtn.classList.add('selected');
                    }
                    updateControlValues();
                });
            })();
            
            // Bottom buttons
            // Camera: click opens Finder directly, long-press clears
            const bgMenu = null;
            const bgPresetsBtn = null;
            const bgFinderBtn = null;
            const bgPresetsList = null;
            const cameraBtnEl = document.getElementById('camera-btn');

            // Presets removed
            const PRESET_IMAGES = [];

            function applyBackgroundImage(src) {
                state.backgroundImage = src;
                const img = document.getElementById('background-image');
                const overlay = document.getElementById('background-overlay');
                img.src = src;
                img.style.display = 'block';
                overlay.style.display = 'block';
                try { localStorage.setItem('pianoXL:bg', src); } catch {}
            }

            function hideBgMenu(){}

            function positionBgMenu() {
                // Centered via CSS transform, no-op function kept for call sites
            }

            // Presets UI removed

            cameraBtnEl.addEventListener('click', function(e) {
                // If a long-press just cleared the background, suppress the trailing click
                if (state.longPressExecuted) {
                    e.preventDefault();
                    e.stopPropagation();
                    state.longPressExecuted = false;
                    return;
                }
                document.getElementById('file-input').click();
            });
            // Long-press functionality for both mouse and touch
            let cameraLongPressTimer = null;
            
            function startCameraLongPress(e) {
                e.preventDefault();
                cameraLongPressTimer = setTimeout(() => {
                    state.longPressExecuted = true;
                    removeBackgroundImage(); hideBgMenu();
                }, 500);
            }
            
            function endCameraLongPress() {
                if (cameraLongPressTimer) {
                    clearTimeout(cameraLongPressTimer);
                    cameraLongPressTimer = null;
                }
            }
            
            // Mouse events
            document.getElementById('camera-btn').addEventListener('mousedown', startCameraLongPress);
            document.addEventListener('mouseup', endCameraLongPress);
            document.addEventListener('mouseleave', endCameraLongPress);
            
            // Touch events
            document.getElementById('camera-btn').addEventListener('touchstart', startCameraLongPress);
            document.addEventListener('touchend', endCameraLongPress);
            document.addEventListener('touchcancel', endCameraLongPress);

            // Menu buttons removed

            // Click-outside handler removed
            
            document.getElementById('disable-btn').addEventListener('click', () => {
                state.selectedControl = state.selectedControl === 'disable' ? null : 'disable';
                const svg = document.querySelector('#disable-btn svg');
                // Use the same brown hue used for active accents
                const brown = '#7c4c27';
                if (state.selectedControl === 'disable') {
                    svg.style.stroke = brown;
                } else {
                    svg.style.stroke = '#888';
                }
            });
            
            // Save button opens modal (centered)
            const songModal = document.getElementById('song-modal');
            function openSongModal(){ songModal.classList.add('show'); }
            function closeSongModal(){ songModal.classList.remove('show'); }
            // Save button with long-press recording functionality
            let saveButtonPressStart = null;
            let saveButtonLongPressTimer = null;
            
            document.getElementById('save-btn').addEventListener('mousedown', function(e) {
                e.preventDefault();
                saveButtonPressStart = Date.now();
                saveButtonLongPressTimer = setTimeout(() => {
                    // Long press detected - start/stop recording
                    if (state.isRecording) {
                        stopRecording();
                    } else {
                        startRecording();
                    }
                }, 500); // 500ms long press
            });
            
            document.getElementById('save-btn').addEventListener('mouseup', function(e) {
                e.preventDefault();
                if (saveButtonLongPressTimer) {
                    clearTimeout(saveButtonLongPressTimer);
                    saveButtonLongPressTimer = null;
                }
                
                // Short press - open save modal
                if (saveButtonPressStart && Date.now() - saveButtonPressStart < 500) {
                    openSongModal();
                }
                saveButtonPressStart = null;
            });
            
            document.getElementById('save-btn').addEventListener('mouseleave', function(e) {
                if (saveButtonLongPressTimer) {
                    clearTimeout(saveButtonLongPressTimer);
                    saveButtonLongPressTimer = null;
                }
                saveButtonPressStart = null;
            });
            document.getElementById('song-close').addEventListener('click', closeSongModal);
            songModal.addEventListener('click', (e)=>{ if(e.target===songModal) closeSongModal(); });

            // Sequencer toggle
            document.getElementById('progression-btn').addEventListener('click', () => {
                const sequencer = document.getElementById('sequencer');
                if (sequencer.classList.contains('hidden')) {
                    sequencer.classList.remove('hidden');
                    // Build grid immediately on open using current sequence's bar count
                    // Don't override currentBars - use what's already loaded from the sequence
                    buildStepGrid();
                } else {
                    sequencer.classList.add('hidden');
                }
            });
            
            // Piano key events
            let dragStartPos = null;
            let dragThreshold = 30; // pixels - more forgiving for normal hand movement
            
            document.addEventListener('mousedown', function(e) {
                const slot = e.target.closest('.key-slot');
                if (slot) {
                    const note = slot.dataset.note;
                    const slotIndex = parseInt(slot.dataset.slot);
                    // SHIFT + double-click: bake current OCT/INV into this slot (voicing lock)
                    if (e.shiftKey && e.detail === 2) {
                        const key = note + '-' + slotIndex;
                        state.slotVoicingLocks[key] = { octave: state.octave, inversion: state.inversion };
                        updatePianoKeys();
                        return;
                    }
                    
                    // Prevent text selection and drag behavior
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Store drag start position
                    dragStartPos = { x: e.clientX, y: e.clientY, note: note, slotIndex: slotIndex };
                    
                    handleSlotPress(note, slotIndex);
                    // Visual feedback per-slot in stacked modes, only when interactive
                    const isInScale = state.mode === 'FREE' || MusicEngine.getScaleNotes(state.selectedKey, state.mode).includes(note);
                    const isKeyDisabled = state.disabledKeys.has(note);
                    const isSlotDisabled = state.disabledSlots.has(`${note}-${slotIndex}`);
                    if (state.sizeMode !== 'XL' && isInScale && !isKeyDisabled && !isSlotDisabled) {
                        slot.classList.add('active');
                    }
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                const slot = e.target.closest('.key-slot');
                if (slot) {
                    const note = slot.dataset.note;
                    const slotIndex = parseInt(slot.dataset.slot);
                    handleSlotRelease(note, slotIndex);
                    if (state.sizeMode !== 'XL') {
                        slot.classList.remove('active');
                    }
                    // (no per-key copy feedback)
                }
            });
            
            // Prevent accidental drags while holding mouse down
            document.addEventListener('mousemove', function(e) {
                if (e.buttons > 0) { // Mouse button is pressed
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check if we're dragging too far and should release the chord
                    if (dragStartPos) {
                        const dragDistance = Math.sqrt(
                            Math.pow(e.clientX - dragStartPos.x, 2) + 
                            Math.pow(e.clientY - dragStartPos.y, 2)
                        );
                        
                        if (dragDistance > dragThreshold) {
                            // Dragged too far - release the chord
                            handleSlotRelease(dragStartPos.note, dragStartPos.slotIndex);
                            
                            // Remove visual feedback
                            const el = document.querySelector(`.key-slot[data-note="${dragStartPos.note}"][data-slot="${dragStartPos.slotIndex}"]`);
                            if (el && state.sizeMode !== 'XL') el.classList.remove('active');
                            
                            // Reset drag tracking
                            dragStartPos = null;
                        }
                    }
                }
            });
            
            // Ensure release if cursor leaves window while holding
            document.addEventListener('mouseleave', function() {
                if (state.lastActiveSlot) {
                    const [note, idx] = state.lastActiveSlot.split('-');
                    handleSlotRelease(note, parseInt(idx));
                    const el = document.querySelector(`.key-slot[data-note="${note}"][data-slot="${idx}"]`);
                    if (el && state.sizeMode !== 'XL') el.classList.remove('active');
                }
            });
            
            // File input events
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            // Click toggle
            const clickBtn = document.getElementById('click-btn');
            if (clickBtn) clickBtn.addEventListener('click', () => { clickEnabled = !clickEnabled; clickBtn.classList.toggle('active'); });
            // Legacy sequence cycling on SEQ click removed.
            // Click behavior for SEQ is handled above in wireSequenceSelection()
            // so that clicking only toggles selection ON/OFF.

            // Fader init (snap ping-pong)
            (function initFader() {
                const fader = document.getElementById('vertical-fader');
                const thumb = document.getElementById('fader-thumb');
                if (!fader || !thumb) return;
                const trackHeight = 114;
                const minTop = 6;
                const maxTop = trackHeight - 6 - thumb.offsetHeight;
                function setThumb(position01) {
                    const clamped = Math.max(0, Math.min(1, position01));
                    const top = minTop + (maxTop - minTop) * (1 - clamped);
                    thumb.style.top = `${top}px`;
                    // Don't update state.faderBlend - let plus/minus control it
                }
                // Initialize fader thumb position from state
                setTimeout(() => {
                    const currentValue = typeof state.faderBlend === 'number' ? state.faderBlend : 0.32;
                    setThumb(currentValue);
                }, 0);
                // Ping-pong logic removed - fader now controlled by plus/minus only
                
                fader.addEventListener('mousedown', (e)=>{ 
                    console.log('🎚️ Fader clicked! selectedControl:', state.selectedControl);
                    e.preventDefault();
                    // Select fader when clicked
                    state.selectedControl = 'fader';
                    updateControlValues();
                    console.log('✅ Fader selected via click');
                });
                thumb.addEventListener('mousedown', (e)=>{ 
                    console.log('🎚️ Fader thumb clicked! selectedControl:', state.selectedControl);
                    e.preventDefault(); 
                    e.stopPropagation();
                    // Select fader when thumb clicked
                    state.selectedControl = 'fader';
                    updateControlValues();
                    console.log('✅ Fader selected via thumb click');
                });
                fader.addEventListener('touchstart', (e)=>{ 
                    e.preventDefault();
                    // Select fader when touched
                    state.selectedControl = 'fader';
                    updateControlValues();
                    console.log('✅ Fader selected via touch');
                });
                thumb.addEventListener('touchstart', (e)=>{ 
                    e.preventDefault(); 
                    e.stopPropagation();
                    // Select fader when thumb touched
                    state.selectedControl = 'fader';
                    updateControlValues();
                    console.log('✅ Fader selected via thumb touch');
                });
                
                // Continuous snapping removed - fader now controlled by plus/minus only
            })();

            // Save/load UI removed

            // Add chord button long-press functionality for scale degree toggle
            const chordBtn = document.getElementById('chord-btn');
            let chordLongPressTimer = null;
            
            chordBtn.addEventListener('mousedown', function(e) {
                chordLongPressTimer = setTimeout(() => {
                    if (state.mode !== 'FREE') {
                        state.showScaleDegrees = !state.showScaleDegrees;
                        updateUI();
                    }
                }, 500); // 500ms long press
            });
            
            chordBtn.addEventListener('mouseup', function(e) {
                if (chordLongPressTimer) {
                    clearTimeout(chordLongPressTimer);
                    chordLongPressTimer = null;
                }
            });
            
            chordBtn.addEventListener('mouseleave', function(e) {
                if (chordLongPressTimer) {
                    clearTimeout(chordLongPressTimer);
                    chordLongPressTimer = null;
                }
            });
            
            // Touch events for mobile
            chordBtn.addEventListener('touchstart', function(e) {
                chordLongPressTimer = setTimeout(() => {
                    if (state.mode !== 'FREE') {
                        state.showScaleDegrees = !state.showScaleDegrees;
                        updateUI();
                    }
                }, 500);
            });
            
            chordBtn.addEventListener('touchend', function(e) {
                if (chordLongPressTimer) {
                    clearTimeout(chordLongPressTimer);
                    chordLongPressTimer = null;
                }
            });
            
            chordBtn.addEventListener('touchcancel', function(e) {
                if (chordLongPressTimer) {
                    clearTimeout(chordLongPressTimer);
                    chordLongPressTimer = null;
                }
            });
            
            // Chord type jump (FREE mode only)
            const chordInput = document.getElementById('chord-input');
            
            // Add keyup listener for immediate 'y'/'n' recognition in recording mode
            chordInput.addEventListener('keyup', function(e) {
                if (state.recordingState === 'prompt') {
                    const key = e.key.toLowerCase();
                    if (key === 'y') {
                        e.preventDefault();
                        processRecordingInput('y');
                    } else if (key === 'n') {
                        e.preventDefault();
                        processRecordingInput('n');
                    }
                }
            });
            
            // Font size adjustment function - starts large, reduces to half size when wrapping to 2 lines
            function adjustFontSize() {
                const text = chordInput.value;
                if (!text) {
                    chordInput.style.fontSize = '28px'; // Reset to large size (28px base)
                    chordInput.style.lineHeight = '36px'; // Reset to base line-height for centering
                    return;
                }
                
                // Check if text contains line breaks (SHIFT+ENTER was used)
                const hasLineBreaks = text.includes('\n');
                
                if (hasLineBreaks) {
                    // Multi-line text: use larger font (20px) to fit nicely and be readable
                    chordInput.style.fontSize = '20px';
                    chordInput.style.lineHeight = '24px'; // Adjusted line-height for multi-line
                } else {
                    // Single line: calculate if text will wrap
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.font = '28px SF Pro Display, -apple-system, system-ui, sans-serif';
                    const textWidth = ctx.measureText(text).width;
                    const fieldWidth = 390 - 24; // 390px width minus 24px padding (12px each side)
                    
                    if (textWidth > fieldWidth) {
                        // Text will wrap, reduce to readable size (20px) to fit 2 lines nicely
                        chordInput.style.fontSize = '20px';
                        chordInput.style.lineHeight = '24px'; // Adjusted line-height for multi-line
                    } else {
                        // Text fits on one line, keep large size
                        chordInput.style.fontSize = '28px';
                        chordInput.style.lineHeight = '36px'; // Perfect line-height for single line centering
                    }
                }
            }
            
            chordInput.addEventListener('keydown', async function(e) {
                // Allow ESC to exit the text field and duration edit mode
                if (e.key === 'Escape' || e.key === 'Esc') {
                    e.preventDefault();
                    chordInput.value = '';
                    chordInput.blur();
                    
                    // Also exit duration edit mode if active
                    if (durationEditMode) {
                        durationEditMode = false;
                        durationEditStep = -1;
                        durationEditSteps.clear();
                        refreshStepSelections(); // Restore chord name display
                    }
                    
                    // Don't return - let the event bubble up to the global handler
                    // so ESC can also work for global de-selection
                }

                // Only process ENTER key (not SHIFT+ENTER)
                if (e.key !== 'Enter' || e.shiftKey) {
                    return; // Not Enter key, or SHIFT+ENTER (allow new line)
                }

                // ENTER pressed: Send prompt
                e.preventDefault();
                const rawInput = chordInput.value.trim();
                if (!rawInput) return;
                
                // Check if we're in recording mode
                if (state.recordingState === 'prompt' || state.recordingState === 'naming') {
                    processRecordingInput(rawInput);
                    return;
                }

                // Command: shuffle seq 1 → generate 4 shuffled variations into sequences 5–8
                const m = rawInput.toLowerCase().match(/^shuffle\s+seq\s+(\d+)$/);
                if (m) {
                    const srcIdx = Math.max(1, Math.min(8, parseInt(m[1], 10))) - 1; // 0-based
                    const src = sequenceSlots[srcIdx];
                    if (src && Array.isArray(src.progression) && src.progression.some(p=>p && p.chord)) {
                        try {
                            const stepPattern = (function(){
                                const steps=[]; for (let b=0;b<4;b++){ const arr=[]; for (let s=0;s<8;s++){ const st = src.progression[b*8+s]; if (st && st.chord) arr.push(s); } steps.push(arr.length?arr:[0]); } return steps;
                            })();
                            // 5–6: shuffled chords, same rhythm
                            const keepRhythm = window.__pxl_shuffleFromSeq1({ tempo: src.tempo||85, progression: src.progression }, { tempo: src.tempo||85, stepPattern, seed: 7 });
                            // 7: shuffled chords on a fixed 4-step pattern per 4-bar phrase: [1,5,1,5] then repeat (bars 5–8)
                            const pattern4 = [[0,4],[0,4],[0,4],[0,4]]; // steps 1 and 5 (0-based: 0 and 4)
                            const seq7Arr = window.__pxl_shuffleFromSeq1({ tempo: src.tempo||85, progression: src.progression }, { tempo: src.tempo||85, stepPattern: pattern4, seed: 9 });
                            // 8: shuffled chords on a fixed 3-step pattern per phrase: [1,5,1]
                            const pattern3 = [[0,4,0],[0,4,0],[0,4,0],[0,4,0]];
                            const seq8Arr = window.__pxl_shuffleFromSeq1({ tempo: src.tempo||85, progression: src.progression }, { tempo: src.tempo||85, stepPattern: pattern3, seed: 11 });

                            const outSeqs = [ keepRhythm[0]||keepRhythm[keepRhythm.length-1], keepRhythm[1]||keepRhythm[keepRhythm.length-1], seq7Arr[0]||seq7Arr[seq7Arr.length-1], seq8Arr[0]||seq8Arr[seq8Arr.length-1] ];
                            for (let i=0;i<4;i++) {
                                const dstIdx = 4 + i;
                                const sq = outSeqs[i]; if (!sq || !sequenceSlots[dstIdx]) continue;
                                sequenceSlots[dstIdx].tempo = sq.tempo;
                                sequenceSlots[dstIdx].bars = sq.bars;
                                sequenceSlots[dstIdx].progression = sq.progression;
                            }
                            // If currently looking at any of 5..8, refresh grid
                            if (currentSequenceIndex >= 4) {
                                const cur = sequenceSlots[currentSequenceIndex];
                                tempo = cur.tempo; currentBars = cur.bars; progression = cur.progression.slice();
                                document.getElementById('tempo-value').textContent = String(tempo);
                                document.getElementById('bars-value').textContent = String(currentBars);
                                buildStepGrid(); refreshStepSelections?.();
                            }
                        } catch (err) {
                            console.error('Shuffle failed', err);
                        }
                    }
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // Sequence commands: SEQ2, SEQ 1,2,3, SEQ 1-3
                if (rawInput.toUpperCase().startsWith('SEQ')) {
                    handleSequenceCommand(rawInput);
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // Clear sequence loop command
                if (rawInput.toUpperCase() === 'CLEAR LOOP' || rawInput.toUpperCase() === 'CLEARLOOP') {
                    state.sequenceLoop = null;
                    state.currentLoopIndex = 0;
                    updateSequenceLoopStatus();
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // AI Prompt: Ask AI, ask ai, ask AI, ask a.i.
                const aiPrompt = rawInput.toLowerCase();
                if (aiPrompt === 'ask ai' || aiPrompt === 'ask a.i.' || aiPrompt === 'askai' || aiPrompt === 'ask a.i') {
                    window.open('https://chatgpt.com/g/g-689ec681b5748191b23fe9f769a60556-genius-peace', '_blank');
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // === FLAM COMMANDS ===
                const flamPrompt = rawInput.toLowerCase();
                if (flamPrompt === 'flam slow') {
                    state.flamMode = 'slow';
                    updateFlamIndicator();
                    console.log('Flam mode set to SLOW');
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }
                if (flamPrompt === 'flam mid') {
                    state.flamMode = 'mid';
                    updateFlamIndicator();
                    console.log('Flam mode set to MID');
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }
                if (flamPrompt === 'flam fast') {
                    state.flamMode = 'fast';
                    updateFlamIndicator();
                    console.log('Flam mode set to FAST');
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }
                if (flamPrompt === 'flam off') {
                    state.flamMode = 'off';
                    updateFlamIndicator();
                    console.log('Flam mode set to OFF');
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // YouTube Chord Analysis: chords from youtube, youtube chords, youtube
                const youtubePrompt = rawInput.toLowerCase();
                if (youtubePrompt === 'chords from youtube' || youtubePrompt === 'youtube chords' || youtubePrompt === 'youtube') {
                    showYouTubePlatformSelector();
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }



                // Command: login - opens manual login session on server
                if (rawInput.toLowerCase() === 'login') {
                    handleManualLogin();
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // Check if input is a mode name
                if (jumpToModeByName(rawInput)) {
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }



                // Require a key to be selected/last pressed (works in all modes)
                if (!state.lastPressed) {
                    chordInput.value = '';
                    return;
                }

                // Prepare variants (preserve case first to differentiate m7 vs M7)
                const rawNoSpaces = rawInput.replace(/\s+/g, '');
                // Support slash-bass, e.g., "sus4/D", "m9/Eb"
                const parts = rawNoSpaces.split('/');
                const typeToken = parts[0];
                const bassToken = parts.length > 1 ? parts[1] : null;
                const lowerType = typeToken.toLowerCase();

                let targetType = null;
                // Support bare slash-bass like "/G" to keep current type and only set bass
                if (typeToken === '' && bassToken) {
                    targetType = getCurrentChordType(state.lastPressed, state.currentSlotLevel);
                }
                // 1) Exact match against chord library keys (case-sensitive)
                if (!targetType && ALL_CHORD_TYPES.includes(typeToken)) {
                    targetType = typeToken;
                }
                // 2) Exact alias match (case-sensitive)
                if (!targetType && CHORD_ALIASES[typeToken]) {
                    targetType = CHORD_ALIASES[typeToken];
                }
                // 3) Case-insensitive alias
                if (!targetType && CHORD_ALIASES[lowerType]) {
                    targetType = CHORD_ALIASES[lowerType];
                }
                // 4) Case-insensitive direct chord library match (fallback)
                if (!targetType) {
                    const found = ALL_CHORD_TYPES.find(t => t.toLowerCase() === lowerType);
                    if (found) targetType = found;
                }

                if (!targetType || !CHORD_LIBRARY[targetType]) {
                    // No match; clear and exit field
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // Find index in current mode's chord list
                // For X mode bottom slots (3-4), use FREE mode to allow any chord type
                const modeForTyping = (state.sizeMode === 'X' && state.currentSlotLevel >= 3) ? 'FREE' : state.mode;
                const availableList = MusicEngine.getAvailableChords(state.lastPressed, modeForTyping, state.selectedKey);
                const targetIndex = availableList.indexOf(targetType);
                if (targetIndex === -1) {
                    chordInput.value = '';
                    chordInput.blur();
                    return;
                }

                // Update state to jump to this chord type for the current slot only
                const skey = state.lastPressed + '-' + state.currentSlotLevel;
                state.slotChordIndices[skey] = targetIndex;
                // Unlock voicing when chord type changes on this slot
                delete state.slotVoicingLocks[skey];

                // If typed with slash-bass, set bass offset for this slot's chord
                if (bassToken) {
                    // Normalize bass note to sharps used by KEYS
                    const norm = (s) => {
                        if (!s) return null;
                        const up = s.toUpperCase();
                        const FLAT_TO_SHARP = { 'DB': 'C#', 'EB': 'D#', 'GB': 'F#', 'AB': 'G#', 'BB': 'A#' };
                        if (FLAT_TO_SHARP[up]) return FLAT_TO_SHARP[up];
                        // Handle edge enharmonics
                        if (up === 'CB') return 'B';
                        if (up === 'FB') return 'E';
                        if (up === 'E#') return 'F';
                        if (up === 'B#') return 'C';
                        // Standard forms: C, C#, D, ...
                        return up;
                    };
                    const bassName = norm(bassToken);
                    const bassIdx = KEYS.indexOf(bassName || '');
                    const rootIdx = KEYS.indexOf(state.lastPressed);
                    if (bassIdx !== -1 && rootIdx !== -1) {
                        // Choose the nearest signed offset in semitones (-11..+11)
                        let offset = (bassIdx - rootIdx + 12) % 12; // 0..11
                        if (offset > 6) offset -= 12; // make it negative if closer
                        const chordKey = state.lastPressed + '-' + targetType + '-' + state.currentSlotLevel;
                        state.bassOffsets[chordKey] = offset;
                    }
                } else {
                    // No slash provided: clear any existing bass offsets for this slot (all types)
                    const prefix = state.lastPressed + '-';
                    const suffix = '-' + state.currentSlotLevel;
                    Object.keys(state.bassOffsets).forEach(k => {
                        if (k.startsWith(prefix) && k.endsWith(suffix)) delete state.bassOffsets[k];
                    });
                    state.bassOffset = 'BASS';
                }

                // Create and play chord instantly
                const chord = createChord(state.lastPressed, targetType);
                if (chord) {
                    // Preview: play briefly then stop
                    audioEngine.stopAllVoices();
                    playChord(chord, 1, state.currentSlotLevel, 'user');
                    setTimeout(() => {
                        audioEngine.stopAllVoices();
                    }, 500);
                }

                updateUI();
                chordInput.value = '';
                // Exit the text field after applying
                chordInput.blur();
            });

            // Clear input whenever it loses focus
            chordInput.addEventListener('blur', function() {
                chordInput.value = '';
            });

            // Clear AI responses when user clicks to type again
            chordInput.addEventListener('click', function() {
                if (chordInput.classList.contains('ai-response') || chordInput.classList.contains('ai-status')) {
                    chordInput.value = '';
                    chordInput.classList.remove('ai-response', 'ai-status');
                    chordInput.placeholder = '';
                }
            });
            
            // Adjust font size as user types
            chordInput.addEventListener('input', adjustFontSize);
            
            // Ensure proper font size when field is focused
            chordInput.addEventListener('focus', adjustFontSize);

            // Ask A.I. button event listener
            const askAiBtn = document.getElementById('ask-ai-btn');
            if (askAiBtn) {
                askAiBtn.addEventListener('click', function() {
                    const isAiMode = askAiBtn.textContent === 'Exit A.i.';
                    
                    if (isAiMode) {
                        // Exit AI mode - return to commands
                        askAiBtn.textContent = 'Ask A.i.';
                        askAiBtn.classList.remove('active');
                        chordInput.placeholder = '';
                        console.log('Switched to COMMANDS mode');
                    } else {
                        // Enter AI mode
                        askAiBtn.textContent = 'Exit A.i.';
                        askAiBtn.classList.add('active');
                        chordInput.placeholder = 'Peace Genius';
                        console.log('Switched to AI mode');
                    }
                });
            }
            


            // Keyboard help: click P I A N O to toggle; panel appears to the LEFT of the image picker
            (function wireKeyboardHelp(){
                const label = document.getElementById('piano-label');
                const help = document.getElementById('kbd-help');
                if (!label || !help) return;
                const container = document.body;
                function ensureInBody(){ try { if (help.parentElement !== container) container.appendChild(help); } catch {} }
                function positionPanel(){
                    const cam = document.getElementById('camera-btn');
                    if (!cam) return;
                    ensureInBody();
                    help.style.right = 'auto';
                    help.style.left = '50%';
                    help.style.top = '50%';
                    help.style.transform = 'translate(-50%, -50%)';
                }
                function openPanel(){ positionPanel(); help.classList.add('show'); }
                function closePanel(){ help.classList.remove('show'); }
                function isOpen(){ return help.classList.contains('show'); }
                // PIANO click handler removed - no action when clicking PIANO
                document.addEventListener('click', (e)=>{
                    if (!isOpen()) return;
                    if (!help.contains(e.target) && e.target !== label) closePanel();
                });
                document.addEventListener('keydown', (e)=>{
                    if (!isOpen()) return;
                    if (e.key === 'Escape') closePanel();
                });
            })();

            // Skin cycling functionality
            (function initSkinCycling(){
                console.log('🎨 initSkinCycling IIFE started');
                const skins = [
                    '', // NO IMAGE state
                    '27.jpg',
                    '21.jpg',
                    '25.jpg',
                    '23.jpg',
                    '29.jpg',
                    '22.jpg',
                    '30.jpg',
                    '24.jpg',
                    '28.jpg',
                    '20.jpg'
                ];

                let currentSkinIndex = 0; // Start at NO IMAGE

                // Expose reset function globally
                window.resetSkinCycle = function() {
                    currentSkinIndex = 0; // Reset to NO IMAGE, next click will go to 27.png
                };

                // Load saved skin preference only if it exists
                const savedSkin = localStorage.getItem('pianoxl-skin');
                if (savedSkin && savedSkin !== '') {
                    const savedIndex = skins.indexOf(savedSkin);
                    if (savedIndex !== -1) {
                        currentSkinIndex = savedIndex;
                        document.body.style.backgroundImage = `url('${savedSkin}')`;
                    }
                }

                // Add click handler to P I A N O text
                const pianoLabel = document.getElementById('piano-label');
                console.log('🎹 pianoLabel element:', pianoLabel);
                if (pianoLabel) {
                    console.log('✅ Adding click event listener to P I A N O text');
                    pianoLabel.addEventListener('click', function() {
                        console.log('🖱️ P I A N O clicked! Current index:', currentSkinIndex);
                        // Cycle to next skin
                        currentSkinIndex = (currentSkinIndex + 1) % skins.length;
                        const newSkin = skins[currentSkinIndex];
                        
                        if (newSkin === '') {
                            // NO IMAGE state - clear background
                            document.body.style.backgroundImage = '';
                            localStorage.removeItem('pianoxl-skin');
                        } else {
                            // Check if this is transitioning from no background to first image
                            const isFirstImage = !document.body.style.backgroundImage || document.body.style.backgroundImage === '';
                            
                            if (isFirstImage) {
                                // For first image, use a temporary overlay to create fade effect
                                const fadeOverlay = document.createElement('div');
                                fadeOverlay.style.cssText = `
                                    position: fixed;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    background-image: url('${newSkin}');
                                    background-size: cover;
                                    background-position: center;
                                    background-repeat: no-repeat;
                                    opacity: 0;
                                    z-index: -1;
                                    transition: opacity 0.5s ease-in-out;
                                    pointer-events: none;
                                `;
                                
                                document.body.appendChild(fadeOverlay);
                                
                                // Force reflow and fade in
                                fadeOverlay.offsetHeight;
                                fadeOverlay.style.opacity = '1';
                                
                                // After fade completes, apply to body and remove overlay
                                setTimeout(() => {
                                    document.body.style.backgroundImage = `url('${newSkin}')`;
                                    document.body.removeChild(fadeOverlay);
                                }, 500);
                            } else {
                                // Normal transition between images (existing behavior)
                                document.body.style.backgroundImage = `url('${newSkin}')`;
                            }
                            
                            // Save preference
                            localStorage.setItem('pianoxl-skin', newSkin);
                        }
                        
                        // Visual feedback removed - no color change
                    });

                    // Hover effects removed - no color change
                } else {
                    console.error('❌ piano-label element not found!');
                }
            })();

            // Keyboard events
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Debug: Test if ANY keydown events are captured
            document.addEventListener('keydown', function(e) {
                console.log('🚨 ANY keydown event:', e.key, 'target:', e.target.tagName);
            });
            
            // ESC key handler for AI response overlay and text field
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' || e.key === 'Esc') {
                    // Handle text field ESC
                    const chordInput = document.getElementById('chord-input');
                    if (chordInput && document.activeElement === chordInput) {
                        e.preventDefault();
                        chordInput.value = '';
                        chordInput.blur();
                        console.log('Text field cleared and blurred with ESC');
                        return;
                    }
                    
                    // Handle AI response overlay
                    const overlay = document.getElementById('ai-response-overlay');
                    if (overlay && overlay.style.display !== 'none') {
                        overlay.style.display = 'none';
                        console.log('AI response overlay closed with ESC');
                    }
                }
            });
            
            // AI Response Action Button Handlers
            document.addEventListener('DOMContentLoaded', function() {
                const loadBtn = document.getElementById('load-into-sequencer');
                const addToListBtn = document.getElementById('add-to-load-list');
                
                if (loadBtn) {
                    loadBtn.addEventListener('click', function() {
                        const overlay = document.getElementById('ai-response-overlay');
                        const jsonData = overlay.dataset.jsonSequence;
                        if (jsonData) {
                            try {
                                const sequence = JSON.parse(jsonData);
                                const result = loadJSONSequenceIntoSequencer(sequence);
                                showAIResponse(result, AI_RESPONSE_TYPES.STATUS, 3000);
                            } catch (error) {
                                showAIResponse('ERROR: Failed to load sequence', AI_RESPONSE_TYPES.STATUS, 3000);
                            }
                        }
                    });
                }
                
                if (addToListBtn) {
                    addToListBtn.addEventListener('click', function() {
                        const overlay = document.getElementById('ai-response-overlay');
                        const jsonData = overlay.dataset.jsonSequence;
                        if (jsonData) {
                            try {
                                const sequence = JSON.parse(jsonData);
                                const result = addJSONSequenceToLoadList(sequence);
                                showAIResponse(result, AI_RESPONSE_TYPES.STATUS, 3000);
                            } catch (error) {
                                showAIResponse('ERROR: Failed to add to load list', AI_RESPONSE_TYPES.STATUS, 3000);
                            }
                        }
                    });
                }
            });
            
            // Save/load dropdown removed

            // Build initial sequencer grid from current sequence slot (index 0)
            const seq0 = sequenceSlots[currentSequenceIndex];
            currentBars = seq0.bars || 2; // Ensure default if not set
            currentTimeSignature = seq0.timeSignature || "4/4"; // Ensure default if not set
            currentBeatsPerBar = seq0.beatsPerBar || 8; // Ensure default if not set
            tempo = seq0.tempo || 85; // Ensure default if not set
            progression = seq0.progression.slice();
            document.getElementById('tempo-value').textContent = String(tempo);
            document.getElementById('bars-value').textContent = String(currentBars);
            
            const timeSignatureLabel = document.getElementById('time-signature-label');
            if (timeSignatureLabel) timeSignatureLabel.textContent = currentTimeSignature;
            const seqBtn0 = document.getElementById('seq-btn');
            if (seqBtn0) {
                const v0 = seqBtn0.querySelector('.seq-value');
                if (v0) v0.textContent = String(currentSequenceIndex + 1);
            }
            buildStepGrid();
            
            // Initialize UI
            updateUI();
            
            // Time signature modal event listeners
            const timeSignatureModal = document.getElementById('time-signature-modal');
            if (timeSignatureModal) {
                // Close button
                const closeBtn = timeSignatureModal.querySelector('#time-signature-close');
                if (closeBtn) {
                    closeBtn.addEventListener('click', closeTimeSignatureModal);
                }
                
                // Click outside to close
                timeSignatureModal.addEventListener('click', (e) => {
                    if (e.target === timeSignatureModal) {
                        closeTimeSignatureModal();
                    }
                });
                
                // Time signature options
                const options = timeSignatureModal.querySelectorAll('.time-signature-option');
                options.forEach(option => {
                    option.addEventListener('click', () => {
                        const timeSig = option.dataset.signature;
                        if (timeSig) {
                            setTimeSignature(timeSig);
                        }
                    });
                });
            }
            
            console.log('Piano XL HD initialized successfully');
        });

        // Load default or persisted background on first paint
        (function initBackground(){
            try {
                const saved = localStorage.getItem('pianoXL:bg');
                if (saved) {
                    const img = document.getElementById('background-image');
                    const overlay = document.getElementById('background-overlay');
                    img.src = saved;
                    img.style.display = 'block';
                    overlay.style.display = 'block';
                    state.backgroundImage = saved;
                }
            } catch {}
        })();

        // Save/Load logic removed
        
        // YouTube Platform Selector Function
        function showYouTubePlatformSelector() {
            const platforms = [
                { name: 'Site 1', url: 'https://ytmp3.cc/' },
                { name: 'Site 2', url: 'https://www.y2mate.com/' },
                { name: 'Site 3', url: 'https://www.mp3juices.cc/' }
            ];
            
            // Create popup HTML
            const popupHTML = `
                <div id="youtube-platform-popup" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                ">
                    <div style="
                        background: #2a2a2a;
                        border: 2px solid #555;
                        border-radius: 16px;
                        padding: 32px;
                        text-align: center;
                        max-width: 400px;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                    ">
                        <h3 style="
                            color: white;
                            margin: 0 0 24px 0;
                            font-size: 20px;
                            font-weight: 600;
                        ">Choose a YouTube to MP3 Platform</h3>
                        <div style="
                            display: flex;
                            flex-direction: column;
                            gap: 12px;
                        ">
                            ${platforms.map(platform => `
                                <button onclick="openYouTubePlatform('${platform.url}')" style="
                                    background: linear-gradient(145deg, #4a4a4a 0%, #2a2a2a 50%, #1a1a1a 100%);
                                    border: 1px solid #555;
                                    border-radius: 12px;
                                    color: white;
                                    padding: 16px 24px;
                                    font-size: 16px;
                                    font-weight: 500;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 10px 20px rgba(0,0,0,0.8)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 16px rgba(0,0,0,0.8)'">
                                    ${platform.name}
                                </button>
                            `).join('')}
                        </div>
                        <button onclick="closeYouTubePlatformSelector()" style="
                            background: #555;
                            border: none;
                            border-radius: 8px;
                            color: white;
                            padding: 12px 24px;
                            margin-top: 20px;
                            font-size: 14px;
                            cursor: pointer;
                            transition: background 0.2s ease;
                        " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            // Add popup to page
            document.body.insertAdjacentHTML('beforeend', popupHTML);
        }
        
        // Open selected YouTube platform
        function openYouTubePlatform(url) {
            window.open(url, '_blank');
            closeYouTubePlatformSelector();
        }
        
        // Close YouTube platform selector
        function closeYouTubePlatformSelector() {
            const popup = document.getElementById('youtube-platform-popup');
            if (popup) {
                popup.remove();
            }
        }
        
    </script>
</body>
</html>
